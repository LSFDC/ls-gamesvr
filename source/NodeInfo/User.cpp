// User.cpp: implementation of the User class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "../Util/IORandom.h"
#include "../Util/ioHashString.h"

#include "User.h"
#include "UserNodeManager.h"
#include "RoomNodeManager.h"
#include "Room.h"
#include "BattleRoomManager.h"
#include "LadderTeamManager.h"
#include "MemoNodeManager.h"
#include "ServerNodeManager.h"
#include "ChannelNodeManager.h"
#include "ShuffleRoomManager.h"
#include "ShuffleRoomReserveMgr.h"
#include "HeroRankManager.h"
#include "ChannelNode.h"
#include "ModeHelp.h"
#include "HiddenkingMode.h"
#include "HeadquartersMode.h"

#include "ioPresentHelper.h"
#include "ioItemInfoManager.h"

#include "ioSetItemInfo.h"
#include "ioSetItemInfoManager.h"
#include "ioDecorationPrice.h"
#include "LevelMatchManager.h"

#include "GrowthManager.h"
#include "ioUserGrowthLevel.h"
#include "FishingManager.h"

#include "ioEtcItemManager.h"
#include "ioExtraItemInfoManager.h"
#include "ioItemCompoundManager.h"
#include "TradeInfoManager.h"
#include "ioExtraItemGrowthCatalystMgr.h"

#include "../DataBase/DBClient.h"
#include "../DataBase/LogDBClient.h"

#include "../Network/ioServerSecurity.h"
#include "../Network/ioPacketQueue.h"
#include "../Network/GameServer.h"
#include "../MainServerNode/MainServerNode.h"
#include "../EtcHelpFunc.h"

//#include "../Window.h"
#include "../MainProcess.h"
#include "../ioEtcLogManager.h"
#include "AnnounceMgr.h"
#include "ioExerciseCharIndexManager.h"
#include "ioMyLevelMgr.h"
#include "ioEventUserNode.h"
#include "NewPublicIDRefresher.h"
#include "ioExcavationManager.h"
#include "iomedaliteminfomanager.h"
#include "ioUserExpandMedalSlot.h"
#include "iofirstsoldiermanager.h"
#include "ioUserSelectShutDown.h"
#include "ioAlchemicMgr.h"
#include "TournamentManager.h"
#include "ioClover.h"
#include "ioBingoManager.h"
#include "ioRelativeGradeManager.h"
#include "ioSuperGashaponMgr.h"
#include "ioPirateRouletteManager.h"
 
#include "../BillingRelayServer/BillingRelayServer.h"
#include "../channeling/iochannelingnodeparent.h"
#include "../channeling/iochannelingnodemanager.h"
#include "../local/iolocalmanager.h"
#include "../Local/ioLocalParent.h"
#include "ioShutDownManager.h"
#include "ioPetInfoManager.h"
#include "ioPetGashaponManager.h"
#include "ioCharAwakeManager.h"
#include "../IPBlocker/IPBlockerManager.h"
#include "ioPowerUpManager.h"
#include "CostumeManager.h"
#include "CostumeShopGoodsManager.h"
#include "SpecialGoodsManager.h"
#include "MissionManager.h"
#include "RollBookManager.h"
#include "ioUserRollBook.h"
#include "GuildRewardManager.h"
#include "GuildRoomsBlockManager.h"
#include "GuildRoomInfos.h"
#include "ServerGuildInvenInfo.h"
#include "ioBlockPropertyManager.h"
#include "CompensationMgr.h"
#include "HouseMode.h"
#include "HomeModeBlockManager.h"
#include "PersonalHomeInfo.h"
#include "TimeCashManager.h"
#include "TitleManager.h"
#include "UserTitleInfo.h"
#include "UserTitleInven.h"
#include "TradeSyncManger.h"
#include "AccessoryManager.h"

#include "../Filter/WordFilterManager.h"
#include "ioSaleManager.h"

#include <strsafe.h>
#ifdef NPROTECT
#include "../nProtect/ionprotect.h"
#endif
#ifdef XIGNCODE
#include "../XignCode/ioXignCode.h"
#endif
#ifdef HACKSHIELD
#include "../HackShield/ioHackShield.h"
#endif


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern CLog HackLOG;
extern CLog EventLOG;
extern CLog RateCheckLOG;
extern CLog TradeLOG;
extern CLog CheatUser;


bool User::m_bUseSecurity = false;
int  User::m_iSecurityOneSecRecv = 30;

int User::m_iDefaultMaxCharSlot;
int User::m_iLimiteMaxCharSlot;
int User::m_RefCount;
int User::m_iRevision;

static int GENERIC_ENTITY = 0;

void User::LoadHackCheckValue()
{
	ioINILoader kLoader( "ls_config_game.ini" );
	kLoader.SetTitle( "SECURITY" );

	if( kLoader.LoadInt( "ON", 0 ) == 1 )
		m_bUseSecurity = true;
	else
		m_bUseSecurity = false;

	m_iSecurityOneSecRecv = kLoader.LoadInt( "ONE_SEC_RCV", 30 );

	m_iRevision = kLoader.LoadInt( "REVISION", 1 );
}

void User::LoadCharSlotValue()
{
	ioINILoader kLoader( "config/CharSlotInfo.ini" );
	kLoader.SetTitle( "common" );

	m_iLimiteMaxCharSlot = kLoader.LoadInt( "limite_max_char_slot", 12 );
	m_iDefaultMaxCharSlot = kLoader.LoadInt( "default_max_char_slot", 12 );

	m_iDefaultMaxCharSlot = min( m_iDefaultMaxCharSlot, m_iLimiteMaxCharSlot );
}

void User::LoadNagleReferenceValue( int refCount )
{
	if( refCount == 0 )
	{
		ioINILoader kLoader( "ls_config_game.ini" );
		kLoader.SetTitle( "Nagle" );

		m_RefCount = kLoader.LoadInt( "Nagle_RefCnt", 5 );
	}
	else
	{
		m_RefCount = refCount;
	}
}

User::User( SOCKET s, DWORD dwSendBufSize, DWORD dwRecvBufSize ) : CConnectNode( s, dwSendBufSize, dwRecvBufSize ), m_entity(0)
{
	// 유저고유번호
	m_entity = ++GENERIC_ENTITY;

	m_pMyRoom   = NULL;
	m_pEncLoginKey  = NULL;	
#ifdef NPROTECT
#ifndef NPROTECT_CSAUTH3
	m_pNProtectAuth = new CCSAuth3();
#endif
#endif // NPROTECT
	
	// 임시
	m_iCurMaxCharSlot = m_iDefaultMaxCharSlot;

	InitData();

	if( m_bUseSecurity )
	{
		SetNS( new ioServerSecurity );
	}
}

User::~User()
{	
	SAFEDELETE( m_pNS );
	SAFEDELETE(m_pEncLoginKey);

#ifdef NPROTECT
#ifndef NPROTECT_CSAUTH3
	SAFEDELETE( m_pNProtectAuth );
#endif
#endif // NPROTECT
}

void User::InitData()
{
	LeaveRoom();
	m_iRelayServerID = 0;
	m_dwDBAgentID    = 0;
	m_dwMyBattleRoom = 0;
	m_dwMyLadderTeam  = 0;
	m_dwMyShuffleRoom = 0;

	m_iMyVictories = 0;
	m_vChannelNode.clear();

	// 래더전
	m_iCompetitorIndex = 0;

	m_user_data.Initialize();
	m_user_relative_grade_data.Initialize();

	m_save_time = 0;
	m_dwSaveCheckTime = 1800000;

	m_sync_time = 0;
	m_dwSyncCheckTime = 300000;
	m_ping_total_send_index = 0;

	m_ping_less_error_count = 0;
	m_ping_over_error_count = 0;
	m_total_ping_error_count = 0;
	m_prev_over_ping_time = 0;
	m_first_heart_beat = true;
	m_bDeveloper       = false;
	m_ladder_point_change = false;
	m_hero_expert_change  = false;
	m_first_login_user    = false;
	m_dwSpeedHackQuizLimitTime  = 0;
	m_iCurSpeedHackAnswerChance = 0;

	m_dwAbuseQuizLimitTime  = 0;
	m_iCurAbuseAnswerChance = 0;

	m_iCurCheckKingIndex = 0;
	m_iCurRecvKingPingCnt = 0;

	m_select_char = 0;

	m_Inventory.Initialize( this );
	m_UserEtcItem.Initialize( this );
	m_ClassExpert.Initialize( this );
	m_Award.Initialize( this );
	m_Friend.Initialize();
	m_Quest.Initialize( this );
	m_UserRecord.Initialize( this );
	m_UserGuild.Initialize( this );
	m_UserPresent.Initialize( this );
	m_UserGrowthLevel.Initialize( this );
	m_UserFishingItem.Initialize( this );
	m_UserExtraItem.Initialize( this );
	m_UserMedalItem.Initialize( this );
	m_UserExpandMedalSlot.Initialize( this );
	m_UserHeroData.Initialize();
	m_CharRentalData.Initialize();
	m_UserHeadquartersData.Initialize();
	m_UserSelectShutDown.Initialize();
	m_AlchemicInventory.Initialize( this );
	m_UserTournament.Initialize( this );

	m_UserSubscription.Initialize( this );

	m_Clover.Initialize( this );
	m_Bingo.Initialize( this );
	m_PirateRoulette.Initialize( this );
	m_UserTournament.Initialize( this );
	m_UserAttendance.Initialize( this );
	m_UserPetItem.Initialize( this );
	m_UserCostume.Init(this);
	m_UserAccessory.Init(this);
	m_PersonalHQInven.Init(this);
	m_TitleInven.Initialize(this);
	m_UserBonusCash.Init(this);
	m_UserCoin.Initialize(this);

	m_UserPcRoom.Initialize();
	m_SyncTable.Initialize();

	m_BonusTable.Init();
	m_BonusTableBackup.Init();

	m_FriendRecommendData.Init();
	m_UserMission.Initialize(this);
	m_UserRollBook.Init(this);

	m_UserTimeCashTabel.Init(this);

	InitCharList();
	
	m_Team = TEAM_NONE;
	m_ShamBattleTeam = TEAM_NONE;
	m_bExitRoomReserved = false;

	m_dwExitRoomTime	= 0;
	m_dwCurExitRoomTime = 0;

	m_dwStartTimeLog = 0;

	m_dwConnectTime    = 0;
		
	m_PreRoomNum = -1;

	m_iServerMovingValue = 0;

	m_iCreateCharCount           = 0;
	m_bExitLobby = true;	

	m_iLeaveRoomIndex		= -1;
	m_dwLeaveRoomTime		= 0;    
	m_dwMemoryLeaveRoomTime = 0;

	m_iSearchBatleRoomIndex = -1;
	m_iLeaveBattleRoomIndex = -1;
	m_dwLeaveBattleRoomTime = 0;      
	m_dwMemoryLeaveBattleRoomTime = 0;
	
	m_vLevelUpClass.clear();
	m_vLevelUpAndPresentCreateClass.clear();

	m_eSessionState       = SS_DISCONNECT;
	m_bSessionDestroySave = true;

	m_bReserveServerMoving = false;
	m_bReserveBattleRoom   = false;
	m_bReserveLadderTeam   = false;
	m_bShuffleGlobalSearch = false;
	m_bReserveShuffleRoom  = false;	

	m_dwMyIP               = 0;
	m_dwPingStep		   = 0;
	m_dwGuildMarkChangeKeyValue = 0;

	m_dwPCRoomNumber       = 0;
	m_bMovieCapturing      = false;
	SetSendLogOutUserState(false);

	//HRYOON 아이템 구매 실패 관련 처리
	m_UserOutputStatus = false;

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID(szTempGUID, sizeof(szTempGUID) );
	m_szGUID = szTempGUID;

#ifdef XTRAP
	ZeroMemory( m_XtrapSessionBuf, sizeof( m_XtrapSessionBuf ) );
	m_dwXtrapCheckTime = 0;
#endif
#ifdef NPROTECT
	m_dwNProtectCheckTime  = 0;
	m_iSentNProtectCheckCnt= 0;
#endif 
#ifdef HACKSHIELD
	m_hHackShield = ANTICPX_INVALID_HANDLE_VALUE;
	m_dwHackShieldCheckTime = 0;
#endif 
	m_szBillingGUID.Clear();
	m_bJoinServerLobby = false;

	m_szNewPublicID.Clear();
	m_szPublicIPForNewPublicID.Clear();

	m_dwFishingStartTime = 0;
	m_dwFishingLoopTime = 0;

	m_iFishingRodType = 0;
	m_iFishingBaitType = 0;

	m_szBillingUserKey.Clear();
	m_szAuthInfo.Clear();
	m_dwSessionID = 0;

	m_bFirstChangeID = false;

	m_dwExcavatingTime   = 0;
	m_dwTryExcavatedTime = 0;

	m_iModeConsecutivelyCnt = 0;

	m_kControlKeys.Clear();

	m_bStealth = false;

	m_bNeedSendPushStruct = false;
	m_iSendPushStructIndex = 0;
	m_iNeedSendPushStructMaxIndex = 0;
	m_dwSendPushStructCheckTime = 0;

	m_dwMyHeadquartersIndex = 0;

	m_bSendCheckPCRoom = false;
	m_bShutDownUser    = false;
	m_dwOldServerIndex = 0;
	m_cLoginTime = 0;
	m_iDropKing = 0;
	ClearSelectExtraItemCodes();

	m_CharAwakeDataMap.clear();
	m_iUserIPType = IP_DEFAULT;
	m_bOnPopup = false;
	m_dwTotalMoney = m_dwMonthMoney = m_dwTotalPlayTime = 0;

	bTutorial = FALSE;

	m_dwFisheryCode	= 0;
	
	m_iLimitSecForLatin = 0;

#ifdef ANTIHACK
	m_dwUserSeed = m_dwNPCSeed = 0;
#endif

	m_dwTotalMoney = m_dwMonthMoney = m_dwTotalPlayTime = 0;

	m_bUsedCoin = false;

	m_nRisingBuyCount = 0;
	m_vRisingGetIndex.clear();
}

void User::InitCharList()
{
	vCharList::iterator iter;
	iter = m_CharList.begin();
	while ( iter != m_CharList.end() )
	{
		ioCharacter *kChar = (*iter);
		kChar->Initialize();
		SAFEDELETE( kChar );
		iter++; 
	}
	m_CharList.clear();
}

void User::SaveData()
{
	if( GetUserIndex() == 0 )
		return;

	if( !IsSessionDestroySave() ) 
		return;

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Save Process (%s) :%d", GetPublicID().c_str(), GetUserDBAgentID() );
	SaveUserData();             //유저 정보 저장
	SaveUserLadderData();       //유저 래더 포인트 저장
	SaveUserHeroExpert();       //유저 영웅전 경험치 저장
	SaveClassExpert();          //클래스 숙련 정보 저장
	SaveCharacter();            //캐릭터 저장
	SaveInventory();            //인벤토리 저장
	SaveEtcItem();			    //특별아이템 저장	
	SaveAward();                //시상내역 저장
	SaveRecord();               //레코드 저장
	SaveGrowth();				//성장 저장
	SaveFishItem();				//낚시 저장
	SaveExtraItem();			//추가장비 저장
	SaveControlKeys();			//조작키 저장
	SaveQuest();				//퀘스트 저장
	SaveExpandMedalSlot();		//확장메달슬롯 저장
	SaveMedalItem();			//메달 아이템 저장
	SaveBestFriend();           //절친 저장
	SaveUserHeadquarters();     //본부 저장
	SaveAlchemicInventory();	//조합 저장
	SaveClover();				// 나의 정보
	SaveFriendClover();			// 친구목록의 클로버 정보.
	SaveBingo();				// 빙고
	SavePet();					// 펫
	SaveTimeMission();			// 시간 미션
	SavePirateRoulette();		// 해적룰렛

	m_EventUserMgr.Save( GetUserDBAgentID(), GetAgentThreadID() );

	m_save_time = TIMEGETTIME();
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Save Process End" );
}

void User::SaveUserData()
{
	//유저 정보 저장
	if( m_user_data.IsChange() )     
	{
		g_DBClient.OnUpdateUserData( GetUserDBAgentID(), GetAgentThreadID(), m_user_data, m_user_relative_grade_data, m_dwConnectTime );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "SaveUserData(%s) :%d", GetPublicID().c_str(), GetUserDBAgentID() );
		m_dwConnectTime = TIMEGETTIME();
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][user]User data save is invalid : [%d] [%d]", m_user_data.m_user_idx, (int)m_user_data.m_bSavePossible );
	}
}

void User::SaveUserLadderData()
{
	if( m_ladder_point_change )
	{
		g_DBClient.OnUpdateUserLadderPoint( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_user_data.m_accumulation_ladder_point, m_user_data.m_ladder_point );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "SaveUserLadderData(%s:%d - %d)", GetPublicID().c_str(), m_user_data.m_accumulation_ladder_point, m_user_data.m_ladder_point );
		m_ladder_point_change = false;
	}
}

void User::SaveUserHeroExpert()
{
	if( m_hero_expert_change )
	{
		g_DBClient.OnUpdateUserHeroExpert( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_user_data.m_iHeroExpert );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "SaveUserHeroExpert(%s:%d - %d)", GetPublicID().c_str(), m_user_data.m_iHeroExpert, m_user_data.m_iAccrueHeroExpert );
		m_hero_expert_change = false;
	}
}

void User::SaveClassExpert()
{
	m_ClassExpert.SaveData();
}

void User::SaveCharacter()
{
	for( int i=0 ;i < GetCharCount();i++)
	{
		m_CharList[i]->CheckRentalLimitTime();
		if( m_CharList[i]->IsChange() && m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) // 연습용병은 DB에 저장하지 않음.
		{
			g_DBClient.OnUpdateCharData( GetUserDBAgentID(), GetAgentThreadID(), *m_CharList[i] );
			
			if( !m_CharList[i]->IsActive() && m_CharList[i]->IsChangeActive() )
				g_DBClient.OnUpdateCharRegDate( GetUserDBAgentID(), GetAgentThreadID(), m_CharList[i]->GetCharIndex() ); // for delete char

			m_CharList[i]->BackUp();
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "SaveCharacter(%s:%d)", GetPublicID().c_str(), i );
		}
	}
}

void User::SaveInventory()
{
	m_Inventory.SaveData();
}

void User::SaveEtcItem()
{
	m_UserEtcItem.SaveData();
}

void User::SaveAward()
{
	m_Award.SaveData();
}

void User::SaveQuest()
{
	m_Quest.SaveData();
}

void User::SaveRecord()
{
	m_UserRecord.SaveRecordData();
}

void User::SaveGrowth()
{
	m_UserGrowthLevel.SaveGrowthLevel();
}

void User::SaveFishItem()
{
	m_UserFishingItem.SaveData();
}

void User::SaveExtraItem()
{
	m_UserExtraItem.SaveData();
}

void User::SaveAlchemicInventory()
{
	m_AlchemicInventory.SaveData();
}

void User::SaveClover()
{
	m_Clover.IsSaveRemainTime();
	m_Clover.SaveData();
}

void User::SaveFriendClover()
{
	m_Friend.SaveFriendClover( this );
}

void User::SaveBingo()
{
	m_Bingo.SaveData();
}

void User::SavePirateRoulette()
{
	m_PirateRoulette.SaveData();
}


void User::SavePet()
{
	m_UserPetItem.SaveData();
}

void User::SaveControlKeys()
{
	if( !m_kControlKeys.IsRight() )
		return;
	g_DBClient.OnUpdateControlKeys( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_kControlKeys );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s %d)%s", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
	m_kControlKeys.Clear();
}

void User::SaveMedalItem()
{
	m_UserMedalItem.SaveData();
}

void User::SaveExpandMedalSlot()
{
	m_UserExpandMedalSlot.SaveData();
}

void User::SaveBestFriend()
{
	m_Friend.SaveBestFriend( this );
}

void User::SaveUserHeadquarters()
{
	if( m_UserHeadquartersData.m_bChangeOption )
	{
		m_UserHeadquartersData.m_bChangeOption = false;
		g_DBClient.OnUpdateHeadquartersData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_UserHeadquartersData );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "SaveUserHeadquarters(%s)", GetPublicID().c_str() );
	}
}

void User::InitServerMovingValue()
{ 
	m_iServerMovingValue = 0; 
}

bool User::IsServerMoving()
{ 
	if( m_iServerMovingValue != 0 )
		return true;
	return false; 
}

int User::GetServerMovingValue()
{
	return m_iServerMovingValue; 
}
float User::GetExpBonusEvent()
{ 
	if( m_fExpBonusEventValue > 0.0f)
		return m_fExpBonusEventValue/100.0f; 
	else 
		return 0.0f;
}
int User::SetServerMoving()
{
	m_sync_time = TIMEGETTIME();
	m_iServerMovingValue = rand()%10000 + 1; 
	ReserveServerMoving();
	return m_iServerMovingValue;
}

void User::ReserveServerMoving()
{
	LeaveRoom();       //룸은 이탈한다.
	m_bReserveServerMoving = true;
}

bool User::IsReserveServerMoving()
{
	return m_bReserveServerMoving;
}

DWORD User::GetUserDBAgentID() const
{
	return m_dwDBAgentID;	
}

void User::ConnectProcessSelectChar()
{
	m_select_char = 0;

	int iSlotIndex = 99999999;
	int iMaxCharCount = GetCharCount();
	for(int i = 0;i < iMaxCharCount;i++)
	{
		ioCharacter *rkChar = m_CharList[i];
		if( rkChar == NULL ) continue;

		const CHARACTER &rkCharInfo = rkChar->GetCharInfo();
		if( iSlotIndex > rkCharInfo.m_iSlotIndex )
		{
			iSlotIndex = rkCharInfo.m_iSlotIndex;
			m_select_char = i;
		}
	}
}

void User::ConnectProcessComplete()
{
	if( GetUserIndex() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ConnectProcessComplete None User Index : %s", GetPublicID().c_str() );
		return;
	}
	// 로그인시 필요한 DB 정보를 전부 받았다. 
	// 이 때부터 유저정보(m_user_data) 저장이 가능해진다.
	
	// 저장 여부 확인
	m_user_data.m_bSavePossible = true;
	
	// 아이템 가격 정보 전송
	g_ItemPriceMgr.SendClassBuyPriceInfo( this );
/*	SP2Packet kClassPricePacket( STPK_CLASSPRICE );
	g_ItemPriceMgr.FillClassBuyPriceInfo( kClassPricePacket );
	SendMessage( kClassPricePacket );
*/
	// 최초 선택 용병 결정
	ConnectProcessSelectChar();

	// 유저 접속 인증 완료.
	SP2Packet kLoginPacket( STPK_CONNECT );

	PACKET_GUARD_VOID( kLoginPacket.Write(CONNECT_OK) );
	PACKET_GUARD_VOID( kLoginPacket.Write(GetPrivateID()) );

	FillConnectUserData( kLoginPacket );
	SendMessage( kLoginPacket );

	SyncUserLogin();  // 타서버에 입장 알림.
	SetStartTimeLog( TIMEGETTIME() );

	if( IsGuild() )   // 길드가 있으면 길드도 동기화
	{
		SyncUserGuild();
	}

	// 정규 리그 요청
	SP2Packet kMainPacket( MSTPK_TOURNAMENT_REGULAR_INFO );
	PACKET_GUARD_VOID( kMainPacket.Write( GetUserIndex() ) );
	g_MainServer.SendMessage( kMainPacket );

	// 현재 총 가입자수 전송
	SP2Packet kTotalRegUser( STPK_TOTAL_REG_USER_CNT );
	PACKET_GUARD_VOID( kTotalRegUser.Write( g_MainServer.GetTotalUserRegCount()) );
	SendMessage( kTotalRegUser );

	// 서버 다운 예약이 되어있는지 확인
	g_MainServer.SendReserveCloseAnn( this );

	if( !IsFirstJoinUser() )
	{
		CTimeSpan cGapTime = CTime::GetCurrentTime() - GetLastLogOutTime();

		// 코인 리필 = 처음 접속한 유저는 최종 접속 시간이 없으므로 코인 리필 없음.
		CheckRefillMonsterCoin( max( 0, cGapTime.GetTotalSeconds() ), true );

		// 레이드 코인 리필
		CheckRefillRaidTicket( true );

		// 시간 체크 가챠폰 
		m_UserEtcItem.SendGashaponRealTime( cGapTime.GetTotalMinutes() );
	}	

	// 진행중인 이벤트 퀘스트 전송
	g_QuestMgr.SendAliveEventQuest( this );

	if( g_EventMgr.IsAlive( EVT_FREEDAY_HERO, GetChannelingType() ) )
	{
		LOG.PrintTimeAndLog(0, "EVT_FREEDAY_HERO on");
		if( GetPCRoomNumber() == 0 )
		{
			SendFreeDayEvent(FREEDAY_EVENT_CODE);
			GivePCRoomRodAndBait();	
		}
	}
	else
	{
		LOG.PrintTimeAndLog(0, "EVT_FREEDAY_HERO off");
		if( GetPCRoomNumber() == FREEDAY_EVENT_CODE )
			SendFreeDayEvent(0);
	}

	
	SP2Packet kPacket( STPK_PCROOM_AUTHORITY );
	PACKET_GUARD_VOID( kPacket.Write( GetPCRoomNumber() ) );
	PACKET_GUARD_VOID( kPacket.Write( m_UserPcRoom.GetPcRoomCharMax() ) );
	SendMessage( kPacket );
	

#ifdef NPROTECT
	// 첫 체크 패킷 전송
	if( !SendNProtectCheck() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : First Send Error : %s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		ExceptionClose( 0 );
		return;
	}
#endif
#ifdef SRC_LATIN
	LOG.PrintTimeAndLog( 0, "Apex L Msg Send, User::ConnectProcessComplete() " );
	g_ioApex.NoticeApexProxy_UserLogIn(GetUserIndex(), GetPrivateID(), GetPublicIP());

	SP2Packet kPacket( STPK_PROTECT_CHECK );
	kPacket << APEX_CMD_LOGIN;  //Cmd_Login 
	SendMessage( kPacket );
#endif

#ifdef SRC_OVERSEAS // @32495 튜토리얼 관련 롤백
	if( GetUserState() != US_TUTORIAL_CLEAR )
	{
		//클라이언트에 튜토리얼 맵 생성 요청
		SP2Packet kPacket( STPK_TUTORIAL_STAGE_CREATE );
		SendMessage( kPacket );

		_OnJoinHeadquarters( this, -1, false );
	}
#else
	// 튜토리얼 건너뛰고 AI모드 생성.
	if( IsTutorialUser() )
	{
		SP2Packet kPacket( STPK_TUTORIAL_STAGE_CREATE );
		SendMessage( kPacket );
		bTutorial	= FALSE;
	}
#endif
	g_DBClient.OnSelectTournamentReward( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetUserIndex() );		// 정규리그 대회 보상
	g_DBClient.OnSelectTournamentCustomReward( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetUserIndex() ); // 유저리그 대회 보상
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::ConnectProcessComplete : %s - Select Char Array : %d", GetPublicID().c_str(), m_select_char );

	g_CompensationMgr.SendCompensation(this);	//점검 보상?

	// 상대계급 보상.
	if( m_user_relative_grade_data.m_enable_reward )
	{
		m_user_relative_grade_data.m_enable_reward = false;
		g_RelativeGradeMgr.SendGeneralRewardPresent( this, m_user_data.m_grade_level );
		g_DBClient.OnUpdateRelativeGradeReward( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), false );
	}

	//빙고 이벤트 타입 전송
	m_Bingo.SendBingoType( this );

	//kyg빌링
	//로그인 패킷 전송 
	SendSessionLogin(); 
	AfterLoginProcess();
	
	//HR LOG_DATA_PCROOM 남김	
	InsertLoginRecord();

	g_EventMgr.NotifySpecificEventInfoWhenLogin(this);
	//OnConnectPopupProcess();

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]User login complete : [%lu] [%s] [%s]", GetUserIndex(), GetPublicID().c_str(), GetPrivateID().c_str() );
}

void User::FillMoveData( SP2Packet &rkPacket )
{
	int i = 0;
	BYTE chUserIPType = GetUserIPType();

	PACKET_GUARD_VOID( rkPacket.Write( m_dwDBAgentID ) );
	PACKET_GUARD_VOID( rkPacket.Write( chUserIPType ) );

	// 유저 정보
	rkPacket << m_user_data.m_user_idx << m_user_data.m_private_id << m_user_data.m_public_id
			 << m_user_data.m_cash << m_user_data.m_purchased_cash << m_user_data.m_money << m_user_data.m_connect_count 
			 << m_user_data.m_user_state << m_user_data.m_grade_level << m_user_data.m_grade_exp
			 << m_user_data.m_fishing_level << m_user_data.m_fishing_exp << m_user_data.m_refill_data
			 << m_user_data.m_user_rank
			 << (short)m_user_data.m_connect_time.GetYear() << (short)m_user_data.m_connect_time.GetMonth() 
			 << (short)m_user_data.m_connect_time.GetDay() << (short)m_user_data.m_connect_time.GetHour() << (short)m_user_data.m_connect_time.GetMinute()
	         << m_user_data.m_user_event_type << (int) m_user_data.m_eEntryType << m_user_data.m_camp_position << m_user_data.m_ladder_point
			 << m_user_data.m_accumulation_ladder_point << m_user_data.m_camp_rank 
			 << (int) m_user_data.m_eChannelingType << m_user_data.m_szChannelingUserID <<  m_user_data.m_szChannelingUserNo << m_user_data.m_iChannelingCash
			 << (int) m_user_data.m_eBlockType << m_user_data.m_kBlockTime.GetTime()
			 << m_user_data.m_iExcavationLevel << m_user_data.m_iExcavationExp << m_user_data.m_iAccrueHeroExpert << m_user_data.m_iHeroExpert
			 << (short)m_user_data.m_login_time.GetYear() << (short)m_user_data.m_login_time.GetMonth() << (short)m_user_data.m_login_time.GetDay()
			 << (short)m_user_data.m_login_time.GetHour() << (short)m_user_data.m_login_time.GetMinute();

	// 영웅전 정보
	{	// 영웅전 정보
		rkPacket << m_UserHeroData.m_iHeroTodayRank << m_UserHeroData.m_iHeroTitle;
		for(i = 0;i < HERO_SEASON_RANK_MAX;i++)
			rkPacket << m_UserHeroData.m_iHeroSeasonRank[i];
	}	

#ifdef _DEBUG
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Fill Move Block Info : %d %d-%d-%d %d:%d", m_user_data.m_eBlockType, m_user_data.m_kBlockTime.GetYear(), m_user_data.m_kBlockTime.GetMonth(), m_user_data.m_kBlockTime.GetDay(), m_user_data.m_kBlockTime.GetHour(), m_user_data.m_kBlockTime.GetMinute() );
#endif 

	rkPacket << m_iCreateCharCount;

	//m_UserEtcItem.FillMoveData( rkPacket );
	m_UserFishingItem.FillMoveData( rkPacket );
	m_UserExpandMedalSlot.FillMoveData( rkPacket );
	//m_UserMedalItem.FillMoveData( rkPacket );

	// 대여 용병
	m_CharRentalData.FillMoveData( rkPacket );

	// 용병 정보
	/*rkPacket << GetCharCount();
	for(i = 0;i < GetCharCount();i++)
	{
		m_CharList[i]->CheckRentalLimitTime();
		DWORD dwCharIndex = m_CharList[i]->GetCharIndex();
		const CHARACTER &kChar = m_CharList[i]->GetCharInfo();
		rkPacket << dwCharIndex << (CHARACTER)kChar << m_CharList[i]->IsChange() << m_CharList[i]->IsActive();
	}*/
	rkPacket << m_select_char;

	// 본부 정보
	m_UserHeadquartersData.FillData( rkPacket );

	// 용병 경험치 정보
	m_ClassExpert.FillMoveData( rkPacket );
	// 수상식 정보
	m_Award.FillMoveData( rkPacket );
	// 유저 레코드
	m_UserRecord.FillMoveData( rkPacket );
	
	// 성장 정보
	m_UserGrowthLevel.FillMoveData( rkPacket );

	// 선물함 정보
	m_UserPresent.FillMoveData( rkPacket );

	// 청약상품 정보
	m_UserSubscription.FillMoveData( rkPacket );

	// 길드
	m_UserGuild.FillMoveData( rkPacket );

	// event
	m_EventUserMgr.FillMoveData( rkPacket );

	// 절친 정보
	m_Friend.FillMoveDataToBestFriend( rkPacket );

	// 토너먼트
	m_UserTournament.FillMoveData( rkPacket );

	// 유저코인정보
	m_UserCoin.FillMoveData( rkPacket );

	// 접속해있는 채널 정보
	rkPacket << GetJoinChannelSize();
	for(i = 0;i < GetJoinChannelSize();i++)
		rkPacket << m_vChannelNode[i];
	// 전투룸 인덱스
	rkPacket << m_dwMyBattleRoom;
	// 길드팀 인덱스
	rkPacket << m_dwMyLadderTeam;
	// 셔플룸 인덱스
	rkPacket << m_dwMyShuffleRoom;

	// 마지막 이탈 룸 인덱스
	CheckLeaveRoomIndex();
	rkPacket << m_iLeaveRoomIndex;
	if( m_iLeaveRoomIndex != -1 )
		rkPacket << max( 0, (int)m_dwMemoryLeaveRoomTime - ( TIMEGETTIME() - m_dwLeaveRoomTime ) );
	else
		rkPacket << 0;
	// 마지막 이탈 전투룸 인덱스
	CheckLeaveBattleRoomIndex();
	rkPacket << m_iLeaveBattleRoomIndex;
	if( m_iLeaveBattleRoomIndex != -1 )
		rkPacket << max( 0, (int)m_dwMemoryLeaveBattleRoomTime - ( TIMEGETTIME() - m_dwLeaveBattleRoomTime ) );
	else
		rkPacket << 0;

	rkPacket << m_iMyVictories;
	rkPacket << m_bMovieCapturing;
	rkPacket << m_bSendCheckPCRoom;
	rkPacket << m_dwPCRoomNumber;

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]FillMoveData PCRoom Index : [%d] [%d]", GetUserIndex(), m_dwPCRoomNumber );

	rkPacket << g_ServerNodeManager.GetServerIndex(); //kyg 이걸로 빌링을 옮겼는지 안옮겼는지 판단 할 수 있음 
	rkPacket << m_szBillingGUID;
	rkPacket << m_szBillingUserKey;
	rkPacket << m_dwTryExcavatedTime;
	rkPacket << m_iModeConsecutivelyCnt;
	rkPacket << m_dwMyHeadquartersIndex;
	rkPacket << m_bShutDownUser;
	rkPacket << m_cLoginTime.GetTime(); 

	// 친구 추천 이벤트
	rkPacket << m_FriendRecommendData.m_dwTableIndex << m_FriendRecommendData.m_dwRecommendIndex;

	rkPacket << m_UserSelectShutDown.IsShutDownUser();
	rkPacket << m_UserSelectShutDown.GetShutDownTime().GetTime();

	if( m_kControlKeys.IsRight() )
	{
		rkPacket << true;
		rkPacket << m_kControlKeys.m_szControlKeys;
	}
	else
	{
		rkPacket << false;
	}

	// 맨 마지막에 클로버 정보 붙임. 가지고있는 클로버 갯수, 마지막 충전시간.
	m_Clover.FillMoveData( rkPacket );
	m_Bingo.FillMoveData( rkPacket );

	m_user_relative_grade_data.FillData( rkPacket );
	m_UserPcRoom.FillMoveData( rkPacket );
	m_UserAttendance.FillMoveData( rkPacket );
	//hr 추가 - 서버 이동시
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_US )
	{
		rkPacket << m_user_data.m_dwUSMemberIndex << m_user_data.m_USMemberID << m_user_data.m_USMemberType;
	}
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN )
	{
		/*
		ioHashString   m_Country;
		ioHashString   m_Gender;
		ioHashString   m_Cafe;
		ioHashString   m_Age;
		ioHashString   m_LatinPrivateIP;
		ioHashString   m_NexonEUID;
		ioHashString   m_LatinConnTime;

		int			   m_iFirstWinCount;
		int			   m_iFistLoseCount;	
		__int64		   m_iFirstPeso;		//라틴 : 로그아웃 시 페소 - 첫 로긴시 페소
		int			   m_iGiveUp;			//게임포기 횟수
		int			   m_iFirstExp;			//로긴시 경험치
		int			   m_iClientLogoutType;	//유저 접속 끊을 때 상태
		*/
		rkPacket << m_user_data.m_Country << m_user_data.m_LatinConnTime << m_user_data.m_iFirstWinCount;
		rkPacket << m_user_data.m_iFistLoseCount << m_user_data.m_iFirstPeso << m_user_data.m_iGiveUp << m_user_data.m_iFirstExp << m_user_data.m_iClientLogoutType << m_user_data.m_Gender;
		rkPacket << m_user_data.m_iWinCount <<  m_user_data.m_iLoseCount;
	}

	//hr 유저 채널 이동시 국가 ccu 감소
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_EU )
	{
		rkPacket << m_user_data.m_Country << GetEUCountryType();	//국가 타입
		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

		if( pLocal )
		{
			pLocal->DecreaseCountryCCU( GetCountry() );	//삭제
		}
	}

	//출석체크
	m_UserAttendance.FillMoveData( rkPacket );

	//해적룰렛
	m_PirateRoulette.FillMoveData( rkPacket );

	//서버 이동시 유저 게임 정보 저장
	SaveUserData();
	SaveUserLadderData();
	SaveUserHeroExpert();
	SaveFriendClover();
	SaveBingo();
	SavePirateRoulette();

	if( rkPacket.GetBufferSize() >= MAX_BUFFER - 1 )       
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]Move data packet Size : [%d] [%d]", GetUserIndex(), rkPacket.GetBufferSize() );	
	else
		m_bSessionDestroySave = false;             // 서버 이동 신호를 보냈으므로 저장을하지 않는다.
}

void User::FillInventoryMoveData( SP2Packet &rkPacket )
{
	SaveInventory();

    m_Inventory.FillMoveData( rkPacket );
}

void User::FillInventoryMoveData( SP2Packet &rkPacket, int iStartIndex )
{
	SaveInventory();

    m_Inventory.DecoFillMoveData( rkPacket, iStartIndex );
}

void User::FillPersonalHQData( SP2Packet &rkPacket )
{
	m_PersonalHQInven.FillMoveData(rkPacket);
}

void User::FillExtraItemMoveData( SP2Packet &rkPacket )
{
	SaveExtraItem();

	m_UserExtraItem.FillMoveData( rkPacket );
}

void User::FillExtraItemMoveData( SP2Packet &rkPacket, int iStartRow )
{
	SaveExtraItem();

	m_UserExtraItem.FillMoveDataWithStartRow( rkPacket, iStartRow );
}

void User::FillQuestMoveData( SP2Packet &rkPacket )
{
	SaveQuest();

	m_Quest.FillMoveData( rkPacket );
}

void User::FillAlchemicInvenMoveData( SP2Packet &rkPacket )
{
	SaveAlchemicInventory();

	m_AlchemicInventory.FillMoveData( rkPacket );
}

void User::FillPetMoveData( SP2Packet &rkPacket )
{
	SavePet();

	m_UserPetItem.FillMoveData( rkPacket );
}

void User::FillAwakeMoveData( SP2Packet &rkPacket )
{
	int iSize = m_CharAwakeDataMap.size();
	std::map < int, int >::iterator iter = m_CharAwakeDataMap.begin();

	PACKET_GUARD_VOID( rkPacket.Write( iSize ) );
	for(	; iter!=m_CharAwakeDataMap.end(); iter++ )
	{
		//캐릭터 인덱스, 각성 종료 시간
		PACKET_GUARD_VOID( rkPacket.Write( iter->first ) );
		PACKET_GUARD_VOID( rkPacket.Write( iter->second ) );
	}
}

void User::FillSoldierMoveData( SP2Packet &rkPacket )
{
	PACKET_GUARD_VOID( rkPacket.Write(GetCharCount()) );

	for( int i=0; i<GetCharCount(); i++ )
	{
		ioCharacter* pChar = m_CharList[i];
		if( !pChar )
			continue;

		pChar->CheckRentalLimitTime();
		DWORD dwCharIndex = pChar->GetCharIndex();
		const CHARACTER &kChar = pChar->GetCharInfo();

		PACKET_GUARD_VOID( rkPacket.Write(dwCharIndex) );
		PACKET_GUARD_VOID( rkPacket.Write((CHARACTER)kChar) );
		PACKET_GUARD_VOID( rkPacket.Write(pChar->IsChange()) );
		PACKET_GUARD_VOID( rkPacket.Write(pChar->IsActive()) );
	}
}

void User::FillEtcItemMoveData( SP2Packet &rkPacket )
{
	m_UserEtcItem.FillMoveData( rkPacket );
}

void User::FillMedalItemMoveData( SP2Packet &rkPacket )
{
	m_UserMedalItem.FillMoveData( rkPacket );
}

void User::FillCostumeMoveData( SP2Packet &rkPacket )
{
	m_UserCostume.FillMoveData(rkPacket);
}

void User::FillMissionMoveData( SP2Packet &rkPacket )
{
	m_UserMission.FillMoveData(rkPacket);
}

void User::FillRollBookMoveData( SP2Packet &rkPacket )
{
	m_UserRollBook.FillMoveData(rkPacket);
}

void User::FillTitleMoveData( SP2Packet &rkPacket )
{
	m_TitleInven.FillMoveData(rkPacket);
}

void User::FillAccessoryMoveData( SP2Packet &rkPacket )
{
	m_UserAccessory.FillMoveData(rkPacket);
}

void User::ApplyMoveData( SP2Packet &rkPacket, bool bDummyNode )
{
	m_user_data.m_bSavePossible = true;
	BYTE chIPType = IP_DEFAULT;
	int i = 0;

	PACKET_GUARD_VOID( rkPacket.Read(m_dwDBAgentID) );
	PACKET_GUARD_VOID( rkPacket.Read(chIPType) );

	m_iUserIPType = chIPType;

	// 유저 정보
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_user_idx) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_private_id) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_public_id) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_cash) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_purchased_cash) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_money) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_connect_count) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_user_state) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_grade_level) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_grade_exp) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_fishing_level) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_fishing_exp) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_refill_data) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_user_rank) );

	short iYear = 0, iMonth = 0, iDay = 0, iHour = 0, iMinute = 0;
	int iEntryType = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iYear) );
	PACKET_GUARD_VOID( rkPacket.Read(iMonth) );
	PACKET_GUARD_VOID( rkPacket.Read(iDay) );
	PACKET_GUARD_VOID( rkPacket.Read(iHour) );
	PACKET_GUARD_VOID( rkPacket.Read(iMinute) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_user_event_type) );
	PACKET_GUARD_VOID( rkPacket.Read(iEntryType) );
	CTime connectTIme( Help::GetSafeValueForCTimeConstructor( iYear, iMonth, iDay, iHour, iMinute, 0 ) );
	m_user_data.m_connect_time = connectTIme;
	m_user_data.m_eEntryType   = (EntryType) iEntryType;
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_camp_position) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_ladder_point) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_accumulation_ladder_point) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_camp_rank) );

	int iChannelingType = CNT_NONE;
	PACKET_GUARD_VOID( rkPacket.Read(iChannelingType) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_szChannelingUserID) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_szChannelingUserNo) );
	PACKET_GUARD_VOID( rkPacket.Read(m_user_data.m_iChannelingCash) );
	m_user_data.m_eChannelingType = (ChannelingType) iChannelingType;

	int iBlockType = BKT_NONE;
	__int64 ilBlockTime = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iBlockType) );
	PACKET_GUARD_VOID( rkPacket.Read(ilBlockTime) );
	m_user_data.m_eBlockType = (BlockType) iBlockType;
	m_user_data.m_kBlockTime = ilBlockTime;
	PACKET_GUARD_VOID(rkPacket.Read(m_user_data.m_iExcavationLevel) );
	PACKET_GUARD_VOID(rkPacket.Read(m_user_data.m_iExcavationExp) );
	PACKET_GUARD_VOID(rkPacket.Read(m_user_data.m_iAccrueHeroExpert) );
	PACKET_GUARD_VOID(rkPacket.Read(m_user_data.m_iHeroExpert) );
	PACKET_GUARD_VOID(rkPacket.Read(iYear) );
	PACKET_GUARD_VOID(rkPacket.Read(iMonth) );
	PACKET_GUARD_VOID(rkPacket.Read(iDay) );
	PACKET_GUARD_VOID(rkPacket.Read(iHour) );
	PACKET_GUARD_VOID(rkPacket.Read(iMinute) );
	CTime cLoginTime( Help::GetSafeValueForCTimeConstructor( iYear, iMonth, iDay, iHour, iMinute, 0 ) );
	m_user_data.m_login_time = cLoginTime;

	{	//영웅전 정보
		rkPacket >> m_UserHeroData.m_iHeroTodayRank >> m_UserHeroData.m_iHeroTitle;
		for(i = 0;i < HERO_SEASON_RANK_MAX;i++)
		{
			PACKET_GUARD_VOID(rkPacket.Read(m_UserHeroData.m_iHeroSeasonRank[i]) );
		}
	}

	g_UserNodeManager.ChangeUserNode(this);

#ifdef _DEBUG
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Apply Move Block Info : %d %d-%d-%d %d:%d", m_user_data.m_eBlockType, m_user_data.m_kBlockTime.GetYear(), m_user_data.m_kBlockTime.GetMonth(), m_user_data.m_kBlockTime.GetDay(), m_user_data.m_kBlockTime.GetHour(), m_user_data.m_kBlockTime.GetMinute() );
#endif 

	PACKET_GUARD_VOID( rkPacket.Read(m_iCreateCharCount) );
	if( m_iCreateCharCount > 0 && !bDummyNode )
		g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_SERVER_MOVE_SELECT, m_iCreateCharCount );

	//m_UserEtcItem.ApplyMoveData( rkPacket, bDummyNode );
	m_UserFishingItem.ApplyMoveData( rkPacket, bDummyNode );
	m_UserExpandMedalSlot.ApplyMoveData( rkPacket, bDummyNode );
	//m_UserMedalItem.ApplyMoveData( rkPacket, bDummyNode );

	// 대여 용병
	m_CharRentalData.ApplyMoveData( rkPacket );

	//CheckCurMaxCharSlot();

	/*int iSize;
	// 용병 정보
	rkPacket >> iSize;
	for(i = 0;i < iSize;i++)
	{
		DWORD dwCharIndex;
		CHARACTER kChar;
		bool bChangeInfo, bActive;
		rkPacket >> dwCharIndex >> kChar >> bChangeInfo >> bActive;

		// new exercise index
		if( g_ExerciseCharIndexMgr.IsRight( dwCharIndex ) )
		{
			if( !g_ExerciseCharIndexMgr.IsHave() ) 
				continue;
			dwCharIndex = g_ExerciseCharIndexMgr.Pop();
		}
		
		ioCharacter *pCharacter = AddCharDataToPointer();
		pCharacter->SetCharInfo( dwCharIndex, kChar, this );
		
		// 서버 이동전에 용병 정보가 변경되었으면 백업하지 말아야 용병 정보를 저장한다.
		if( !bChangeInfo )
			pCharacter->BackUp();
		
		CheckCharSlot( pCharacter );
		pCharacter->SetActive( bActive );				
	}*/
	PACKET_GUARD_VOID( rkPacket.Read(m_select_char) );

	// 본부 정보
	m_UserHeadquartersData.ApplyData( rkPacket );

	// 용병 경험치 정보
	m_ClassExpert.ApplyMoveData( rkPacket, bDummyNode );

	// 수상식 정보
	m_Award.ApplyMoveData( rkPacket, bDummyNode );

	// 유저 레코드
	m_UserRecord.ApplyMoveData( rkPacket, bDummyNode );
	
	// 성장 정보
	m_UserGrowthLevel.ApplyMoveData( rkPacket, bDummyNode );

	// 선물함 정보
	m_UserPresent.ApplyMoveData( rkPacket, bDummyNode );

	// 청약상품 정보
	m_UserSubscription.ApplyMoveData( rkPacket, bDummyNode );

	// 길드
	m_UserGuild.ApplyMoveData( rkPacket, bDummyNode );

	// event
	m_EventUserMgr.ApplyMoveData( rkPacket );

	// 절친 정보
	m_Friend.ApplyMoveDataToBestFriend( rkPacket, bDummyNode );

	// 토너먼트
	m_UserTournament.ApplyMoveData( rkPacket, bDummyNode );

	// 유저코인정보
	m_UserCoin.ApplyMoveData( rkPacket );

	// 접속해있는 채널 정보
	int iSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iSize) );
	MAX_GUARD(iSize, 100);

	for(i = 0;i < iSize;i++)
	{
		DWORD dwChannelIndex = 0;
		PACKET_GUARD_VOID( rkPacket.Read(dwChannelIndex) );
		m_vChannelNode.push_back( dwChannelIndex );
	}
	// 전투룸 인덱스
	PACKET_GUARD_VOID( rkPacket.Read(m_dwMyBattleRoom) );
	// 길드팀 인덱스
	PACKET_GUARD_VOID( rkPacket.Read(m_dwMyLadderTeam) );
	// 셔플룸 인덱스
	PACKET_GUARD_VOID( rkPacket.Read(m_dwMyShuffleRoom) );

	// 마지막 이탈 룸 인덱스
	PACKET_GUARD_VOID( rkPacket.Read(m_iLeaveRoomIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(m_dwMemoryLeaveRoomTime) );
	if( m_iLeaveRoomIndex != -1 )
		m_dwLeaveRoomTime = TIMEGETTIME();
	// 마지막 이탈 전투룸 인덱스
	PACKET_GUARD_VOID( rkPacket.Read(m_iLeaveBattleRoomIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(m_dwMemoryLeaveBattleRoomTime) );
	if( m_iLeaveBattleRoomIndex != -1 )
		m_dwLeaveBattleRoomTime = TIMEGETTIME();

	PACKET_GUARD_VOID( rkPacket.Read(m_iMyVictories) );
	PACKET_GUARD_VOID( rkPacket.Read(m_bMovieCapturing) );
	PACKET_GUARD_VOID( rkPacket.Read(m_bSendCheckPCRoom) );
	PACKET_GUARD_VOID( rkPacket.Read(m_dwPCRoomNumber) );
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]ApplyMoveData PCRoom Index : [%d] [%d]", GetUserIndex(), m_dwPCRoomNumber );
	PACKET_GUARD_VOID( rkPacket.Read(m_dwOldServerIndex) ); //kyg 이걸로 빌링서버를 옮겼는지 안옮겼는지 판단 가능 
	PACKET_GUARD_VOID( rkPacket.Read(m_szBillingGUID) );
	PACKET_GUARD_VOID( rkPacket.Read(m_szBillingUserKey) );
	PACKET_GUARD_VOID( rkPacket.Read(m_dwTryExcavatedTime) );
	PACKET_GUARD_VOID( rkPacket.Read(m_iModeConsecutivelyCnt) );
	PACKET_GUARD_VOID( rkPacket.Read(m_dwMyHeadquartersIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(m_bShutDownUser) );
	__int64 iLoginTime = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iLoginTime) );
	m_cLoginTime = iLoginTime;

	// 친구 추천 이벤트
	PACKET_GUARD_VOID( rkPacket.Read(m_FriendRecommendData.m_dwTableIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(m_FriendRecommendData.m_dwRecommendIndex) );

	bool bSelectShutDownUser    = false;
	__int64 iSelectShutDownTime = 0;
	PACKET_GUARD_VOID( rkPacket.Read(bSelectShutDownUser) );
	PACKET_GUARD_VOID( rkPacket.Read(iSelectShutDownTime) );
	m_UserSelectShutDown.SetShutDownUser( bSelectShutDownUser );
	m_UserSelectShutDown.SetShutDownTime( iSelectShutDownTime );

	bool bChangeControlKey = false;
	PACKET_GUARD_VOID( rkPacket.Read(bChangeControlKey) );
	if( bChangeControlKey )
	{
		PACKET_GUARD_VOID( rkPacket.Read(MAX_CONTROL_KEYS_PLUS_ONE, m_kControlKeys.m_szControlKeys) );
	}
	
	m_Clover.ApplyMoveData( rkPacket, bDummyNode );
	m_Bingo.ApplyMoveData( rkPacket, bDummyNode );
	m_user_relative_grade_data.ApplyData( rkPacket );
	m_UserPcRoom.ApplyMoveData( rkPacket, this );
	
	//hr 서버 이동시 필요데이터 받음
	//hr 추가 - 서버 이동시
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_US )
	{
		rkPacket >> m_user_data.m_dwUSMemberIndex >> m_user_data.m_USMemberID >> m_user_data.m_USMemberType;
	}
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN )
	{
		rkPacket >> m_user_data.m_Country >> m_user_data.m_LatinConnTime >> m_user_data.m_iFirstWinCount;
		rkPacket >> m_user_data.m_iFistLoseCount >> m_user_data.m_iFirstPeso >> m_user_data.m_iGiveUp >> m_user_data.m_iFirstExp >> m_user_data.m_iClientLogoutType >> m_user_data.m_Gender;
		rkPacket >> m_user_data.m_iWinCount >>  m_user_data.m_iLoseCount;
	}
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_EU )
	{
		rkPacket >> m_user_data.m_Country >> m_user_data.m_dwEUContryType;
		
		//hr 유저 채널이동 하였으니 국가ccu 증가
		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		pLocal->IncreaseCountryCCU( m_user_data.m_Country.c_str() );
	}
	m_dwConnectTime = TIMEGETTIME();	
	m_bDeveloper = g_UserNodeManager.IsDeveloper( GetPublicID().c_str() );
	m_PirateRoulette.ApplyMoveData( rkPacket, bDummyNode );
}

void User::ApplyInventoryMoveData( SP2Packet &rkPacket )
{
	m_Inventory.DecoApplyMoveData( rkPacket );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s : ApplyInventoryMoveData", GetPublicID().c_str() );
}

void User::ApplyExtraItemMoveData( SP2Packet &rkPacket )
{
	//m_UserExtraItem.ApplyMoveData( rkPacket );
	m_UserExtraItem.ApplyMoveDataWithRow( rkPacket );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s : ApplyExtraItemMoveData", GetPublicID().c_str() );
}

void User::ApplyQuestMoveData( SP2Packet &rkPacket )
{
	m_Quest.ApplyMoveData( rkPacket );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s : ApplyQuestMoveData", GetPublicID().c_str() );
}

void User::ApplyAlchemicInvenData( SP2Packet &rkPacket )
{
	m_AlchemicInventory.ApplyMoveData( rkPacket );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s : ApplyAlchemicInvenData", GetPublicID().c_str() );
}

void User::ApplyPetData( SP2Packet &rkPacket )
{
	m_UserPetItem.ApplyMoveData( rkPacket );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s : ApplyPetData", GetPublicID().c_str() );
}

void User::ApplyAwakeMoveData( SP2Packet &rkPacket )
{
	m_CharAwakeDataMap.clear();

	int iCount = 0;
	int iCharIndex = 0;
	int iEndTime = 0;

	PACKET_GUARD_VOID( rkPacket.Read( iCount ) );

	for( int i=0; i<iCount; i++ )
	{
		PACKET_GUARD_VOID( rkPacket.Read( iCharIndex ) );
		PACKET_GUARD_VOID( rkPacket.Read( iEndTime ) );

		m_CharAwakeDataMap.insert( std::make_pair( iCharIndex, iEndTime ) );
	}
}

void User::ApplySoldierMoveData( SP2Packet &rkPacket )
{
	CheckCurMaxCharSlot();

	int iSize = 0;

	PACKET_GUARD_VOID( rkPacket.Read(iSize) );

	for( int i=0; i<iSize; i++ )
	{
		DWORD dwCharIndex = 0;
		CHARACTER kChar;
		bool bChangeInfo = false;
		bool bActive = false;

		PACKET_GUARD_VOID( rkPacket.Read(dwCharIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(kChar) );
		PACKET_GUARD_VOID( rkPacket.Read(bChangeInfo) );
		PACKET_GUARD_VOID( rkPacket.Read(bActive) );

		// new exercise index
		if( g_ExerciseCharIndexMgr.IsRight( dwCharIndex ) )
		{
			if( !g_ExerciseCharIndexMgr.IsHave() ) 
				continue;
			dwCharIndex = g_ExerciseCharIndexMgr.Pop();
		}

		ioCharacter *pCharacter = AddCharDataToPointer();
		if( !pCharacter )
			continue;

		pCharacter->SetCharInfo( dwCharIndex, kChar, this, false );
		
		// 서버 이동전에 용병 정보가 변경되었으면 백업하지 말아야 용병 정보를 저장한다.
		if( !bChangeInfo )
			pCharacter->BackUp();
		
		CheckCharSlot( pCharacter );
		pCharacter->SetActive( bActive );				
	}
}

void User::ApplyEtcItemMoveData( SP2Packet &rkPacket )
{
	m_UserEtcItem.ApplyMoveData( rkPacket );
}

void User::ApplyMedalItemMoveData( SP2Packet &rkPacket )
{
	m_UserMedalItem.ApplyMoveData( rkPacket ) ;
}

void User::ApplyCostumeMoveData( SP2Packet &rkPacket )
{
	m_UserCostume.ApplyMoveData(rkPacket);
}

void User::ApplyMissionMoveData( SP2Packet &rkPacket )
{
	m_UserMission.ApplyMoveData(rkPacket);
}

void User::ApplyRollBookMoveData( SP2Packet &rkPacket )
{
	m_UserRollBook.ApplyMoveData(rkPacket);
}

void User::ApplyPersonalHQMoveData(SP2Packet &rkPacket)
{
	m_PersonalHQInven.ApplyMoveData(rkPacket);
}

void User::ApplyTitleMoveData(SP2Packet &rkPacket)
{
	m_TitleInven.ApplyMoveData(rkPacket);
}

void User::ApplyAccessoryMoveData( SP2Packet &rkPacket )
{
	m_UserAccessory.ApplyMoveData(rkPacket);
}

void User::SetUserData( const USERDATA &user_data, bool first_login_user )
{
	// DB에서 받는 값
	m_user_data.m_user_idx			= user_data.m_user_idx;				//유저 고유키
	m_user_data.m_private_id		= user_data.m_private_id;			//유저 아이디
	m_user_data.m_public_id			= user_data.m_public_id;            //닉네임
	m_user_data.m_cash				= user_data.m_cash;					//유저 캐쉬
	m_user_data.m_money				= user_data.m_money;				//유저 머니  EX.서프의 코드 정도.
	m_user_data.m_connect_count		= user_data.m_connect_count;        //접속 횟수.
	m_user_data.m_connect_time		= user_data.m_connect_time;         //최근 접속 시간 - 접속중인 상태에서 변경하지 말것!!!!!!!!
	m_user_data.m_user_state		= user_data.m_user_state;           //훈련 정보
	m_user_data.m_grade_level		= user_data.m_grade_level;          //계급
	m_user_data.m_grade_exp         = user_data.m_grade_exp;            //계급 구간 경험치
	m_user_data.m_user_event_type	= user_data.m_user_event_type;      //유저 이벤트 타입
	m_user_data.m_user_rank         = user_data.m_user_rank;            //유저 랭킹
	m_user_data.m_eEntryType        = user_data.m_eEntryType;           //가입타입, 임시가입,임시가입만료,실명인증
	m_user_data.m_camp_position     = user_data.m_camp_position;		//소속 진영
	m_user_data.m_ladder_point      = user_data.m_ladder_point;         //래더 포인트
	m_user_data.m_accumulation_ladder_point = user_data.m_accumulation_ladder_point;         //누적 래더 포인트
	m_user_data.m_camp_rank         = user_data.m_camp_rank;            //진영 랭킹
	m_user_data.m_eChannelingType   = user_data.m_eChannelingType;      //채널링타입
	m_user_data.m_szChannelingUserID= user_data.m_szChannelingUserID;   //채널링사 아이디
	m_user_data.m_szChannelingUserNo= user_data.m_szChannelingUserNo;   //채널링사 유저식별NO : naver 이용
	m_user_data.m_eBlockType        = user_data.m_eBlockType;           //차단타입
	m_user_data.m_kBlockTime        = user_data.m_kBlockTime;           //차단날짜
	m_user_data.m_fishing_level		= user_data.m_fishing_level;        //계급
	m_user_data.m_fishing_exp       = user_data.m_fishing_exp;          //계급 구간 경험치
	m_user_data.m_refill_data       = user_data.m_refill_data;          //리필받기까지 남은 초
	m_user_data.m_iExcavationLevel  = user_data.m_iExcavationLevel;     //발굴레벨
	m_user_data.m_iExcavationExp    = user_data.m_iExcavationExp;       //발굴 구간 경험치
	m_user_data.m_iAccrueHeroExpert	= user_data.m_iAccrueHeroExpert;    //영웅전 누적 경험치
	m_user_data.m_iHeroExpert       = user_data.m_iHeroExpert;          //영웅전 경험치
	m_user_data.m_login_time		= CTime::GetCurrentTime();			//로그인 시간.
	//hr 남미 접속로그용
	
	int iKill =0, iDeath = 0;
	m_user_data.m_iFirstPeso		= user_data.m_money;
	m_user_data.m_iFirstExp			= user_data.m_grade_exp;
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetUserHeroData : Peso:%d, Exp :%d", m_user_data.m_iFirstPeso, m_user_data.m_iFirstExp );

	//m_UserRecord.GetRecordInfo( RECORD_BATTLE, m_user_data.m_iFirstWinCount, m_user_data.m_iFistLoseCount, iKill, iDeath );
	//
	// 첫 접속 유저
	m_first_login_user = first_login_user;       

	// 서버에서 세팅하는 값
	m_dwConnectTime = TIMEGETTIME();

	m_bDeveloper = g_UserNodeManager.IsDeveloper( GetPublicID().c_str() );

	// 처음 적용되는 유저는 리필 시간 세팅
	if( m_user_data.m_refill_data == 0 )
		m_user_data.m_refill_data = Help::GetRefillCoinSec();
	
	ioHashString publicIP;
	publicIP.Clear();
	publicIP = GetPublicIP();
		
	if( publicIP.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetUserData() publicIP is Empty : %s", GetPublicID().c_str() );
	}


	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_EU )
	{
		//hr ccu TEST 
		//publicIP = "116.121.22.229";
		g_DBClient.OnGetCountryCode( GetUserDBAgentID(), GetAgentThreadID(), m_user_data.m_user_idx, GetGUID(), publicIP );   
	}
}

void User::SetUserHeroData( const UserHeroData &rkData )
{
	int i = 0;
	m_UserHeroData.m_iHeroTitle = rkData.m_iHeroTitle;
	m_UserHeroData.m_iHeroTodayRank = rkData.m_iHeroTodayRank;
	for(i = 0;i < HERO_SEASON_RANK_MAX;i++)
		m_UserHeroData.m_iHeroSeasonRank[i] = rkData.m_iHeroSeasonRank[i];
	
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::SetUserHeroData : %s - %d:%d:%d:%d:%d:%d:%d:%d", GetPublicID().c_str(),
							m_UserHeroData.m_iHeroTitle, m_UserHeroData.m_iHeroTodayRank,
							m_UserHeroData.m_iHeroSeasonRank[HERO_SEASON_RANK_1], m_UserHeroData.m_iHeroSeasonRank[HERO_SEASON_RANK_2], m_UserHeroData.m_iHeroSeasonRank[HERO_SEASON_RANK_3],
							m_UserHeroData.m_iHeroSeasonRank[HERO_SEASON_RANK_4], m_UserHeroData.m_iHeroSeasonRank[HERO_SEASON_RANK_5], m_UserHeroData.m_iHeroSeasonRank[HERO_SEASON_RANK_6] );

	SP2Packet kPacket( STPK_USER_HERO_DATA );

	PACKET_GUARD_VOID( kPacket.Write( m_UserHeroData.m_iHeroTitle) );
	PACKET_GUARD_VOID( kPacket.Write( m_UserHeroData.m_iHeroTodayRank) );
		
	for(i = 0;i < HERO_SEASON_RANK_MAX;i++)
		PACKET_GUARD_VOID( kPacket.Write( m_UserHeroData.m_iHeroSeasonRank[i]) );
		
	SendMessage( kPacket );
}

void User::SetUserRelativeGradeData( int iInitTime, bool bReward, int iBackupExp )
{
	m_user_relative_grade_data.m_init_code = iInitTime;
	m_user_relative_grade_data.m_enable_reward = bReward;
	m_user_relative_grade_data.m_iBackupExp = iBackupExp;
}

void User::SetUserHeadquartersData( const UserHeadquartersOption &rkData )
{
	m_UserHeadquartersData.m_sLock = rkData.m_sLock;

	for(int i = 0;i < MAX_DISPLAY_CNT;i++)
	{
		m_UserHeadquartersData.m_dwCharacterIndex[i] = rkData.m_dwCharacterIndex[i];
		m_UserHeadquartersData.m_iCharacterXPos[i]   = rkData.m_iCharacterXPos[i];
		m_UserHeadquartersData.m_iCharacterZPos[i]   = rkData.m_iCharacterZPos[i];
	}

	SP2Packet kPacket( STPK_HEADQUARTERS_OPTION );
	PACKET_GUARD_VOID( kPacket.Write(m_UserHeadquartersData.m_sLock) );
	for(int i = 0;i < MAX_DISPLAY_CNT;i++)
	{
		PACKET_GUARD_VOID( kPacket.Write(m_UserHeadquartersData.m_dwCharacterIndex[i]) );
		PACKET_GUARD_VOID( kPacket.Write(m_UserHeadquartersData.m_iCharacterXPos[i]) );
		PACKET_GUARD_VOID( kPacket.Write(m_UserHeadquartersData.m_iCharacterZPos[i]) );
	}
	SendMessage( kPacket );
}

void User::SetFriendRecommendData( DWORD dwTableIndex, DWORD dwRecommendIndex )
{
	m_FriendRecommendData.m_dwTableIndex = dwTableIndex;
	m_FriendRecommendData.m_dwRecommendIndex = dwRecommendIndex;
	if( m_FriendRecommendData.m_dwTableIndex != 0 )
	{
		// 유저에게 전송
		SP2Packet kPacket( STPK_FRIEND_RECOMMEND_DATA );
		PACKET_GUARD_VOID( kPacket.Write(m_FriendRecommendData.m_dwTableIndex) );
		PACKET_GUARD_VOID( kPacket.Write(m_FriendRecommendData.m_dwRecommendIndex) );
		SendMessage( kPacket );
	}
}

ioCharacter* User::AddCharDataToPointer()
{
	ioCharacter *pNewChar = new ioCharacter;
	m_CharList.push_back( pNewChar );

	g_CriticalError.CheckSoldierCount( GetPublicID(), (int)m_CharList.size() );
	
	return pNewChar;
}

void User::OnCreate()
{
	
	CConnectNode::OnCreate();
	if( m_bUseSecurity )
	{		
		ioServerSecurity *pSS = (ioServerSecurity *)m_pNS;
		if( pSS ) 
		{
			pSS->InitDoSAttack( m_iSecurityOneSecRecv );
			pSS->InitState( m_socket );		
		}
	}
	m_save_time = TIMEGETTIME();
	m_dwSaveCheckTime = 2700000 + ( (rand()%900) * 1000 );

	m_eSessionState = SS_CONNECT;
	m_EventUserMgr.Init();
	
#ifdef XTRAP
	m_dwXtrapCheckTime = TIMEGETTIME();
	g_ioXtrap.Init( m_XtrapSessionBuf, GetPublicID().c_str(), GetPublicIP(), GetGradeLevel() );
#endif

#ifdef NPROTECT

#ifdef NPROTECT_CSAUTH3
	m_NProtectAuth.Init( TRUE );
#else
	if( m_pNProtectAuth )
		m_pNProtectAuth->Init();
#endif
	m_dwNProtectCheckTime   = TIMEGETTIME();
	m_iSentNProtectCheckCnt = 0;
#endif // NPROTECT

#ifdef XIGNCODE
	g_ioXignCode.OnAccept( this );
#endif 

#ifdef HACKSHIELD

	if( m_hHackShield == ANTICPX_INVALID_HANDLE_VALUE )
	m_hHackShield = g_ioHackShield.CreateClient();

	m_dwHackShieldCheckTime = TIMEGETTIME();
	
#endif
}

void User::OnDestroy()
{
	if( m_eSessionState != ServerNode::SS_DISCONNECT)
		LOG.PrintTimeAndLog( 0, "User::OnDestroy() -> PrivateID : %s, AccountID : %d, SessionDestroySave : %d, ConnectState : %d",
			GetPrivateID().c_str(), GetUserIndex(), IsSessionDestroySave(), m_eSessionState );

	SendBilligLogOut(); // IP 전송해야 하므로 OnDestroy 이전에 호출	

	SavePlayTimeLog(); 
	CConnectNode::OnDestroy();	
	m_eSessionState = SS_DISCONNECT;
}

void User::OnSessionDestroy()
{
	DeleteGuildMarkChangeKeyValue();

	DeleteExerciseChar( EXERCISE_GENERAL );
	DeleteExerciseChar( EXERCISE_PCROOM );
	DeleteExerciseChar( EXERCISE_EVENT );

	if( IsSessionDestroySave() )
	{
		BeforeLogoutProcess();
		SendSessionLogout();

		if( !g_App.IsWantExit() )
		{
			NetworkCloseLeaveRooom();
			NetworkCloseLogout();
		}

		LeaveBattleRoom();
		LeaveLadderTeam();
		LeaveShuffleRoom();
		LeaveChannel();		
		UpdateCharLimitDate();
		UpdateEtcItemTime( __FUNCTION__ );
		LeaveRoomEtcItemTime();
		DeleteEtcItemPassedDate();
		DeleteExtraItemPassedDate(false);
		DeleteMedalItemPassedDate(false);
		//DeleteExMedalSlotPassedDate();
		DeleteExerciseChar( EXERCISE_RENTAL );
		DeleteCharAwakePassedDate();
		DeleteCostumePassedDate();
		DeleteAccessoryPassedDate();
		DeleteExpiredBonusCash();

		// 메모리에있는 선물을 전부 Insert
		LogoutMemoryPresentInsert();
		SyncUserLogout();
		g_LogDBClient.OnInsertTime( this, LogDBClient::TT_EXIT_PROGRAM );
		g_ShuffleRoomReserveMgr.DeleteShuffleQueue( this );
		SaveData();
		OnNameChageSync();
		
		if( m_eSessionState != ServerNode::SS_DISCONNECT )
			LOG.PrintTimeAndLog( 0, "[info][LOGOUT]User::OnSessionDestroy() -> PrivateID : %s, AccountID : %d, SessionDestroySave : %d, ConnectState : %d",
				GetPrivateID().c_str(), GetUserIndex(), IsSessionDestroySave(), m_eSessionState );

		//HR 유럽만 중복로그인 방지 유저 아이디-> 유저 인덱스로 변경함 
		g_DBClient.OnUpdateUserLogout( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPrivateID() );          // DB 로그 아웃은 제일 나중에 처리해야한다.

	}

	if( GetUserIndex() != 0 )
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]User logout : [%lu] [%s] [%s]", GetUserIndex(), GetPublicID().c_str(), GetPrivateID().c_str() );
	InitData();	
	
#ifdef NPROTECT

#ifdef NPROTECT_CSAUTH3
	m_NProtectAuth.Close();
#else
	if( m_pNProtectAuth )
		m_pNProtectAuth->Close();
#endif

#endif // NPRPTECT

#ifdef XIGNCODE
	g_ioXignCode.OnDisconnect( this );
#endif 

#ifdef HACKSHIELD
	g_ioHackShield.CloseClient( m_hHackShield );
#endif

}

void User::OnNameChageSync()
{
	// public id 변경 ( save 제일 마지막에 실행 )
	if( IsNewPublicID() )
	{
		DWORD dwIndex   = 0;
		int   iFieldCnt = 0;
		if( m_UserEtcItem.GetEtcItemIndex( ioEtcItem::EIT_ETC_CHANGE_ID, dwIndex, iFieldCnt ) )
		{
			g_DBClient.OnUpdatePublicIDAndEtcItem( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), m_szNewPublicID, dwIndex, iFieldCnt, m_szPublicIPForNewPublicID );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Change Public ID : %d / %s->%s", GetUserIndex(), GetPublicID().c_str(), m_szNewPublicID.c_str() );
			g_NewPublicIDRefresher.AddInfo( GetUserIndex(), GetPublicID(), m_szNewPublicID, &m_Friend );
			
			if( IsGuild() )
			{
				// 길드원들도 로그인한 유저가 있으면 동기화시켜버린다.
				SP2Packet kPacket( STPK_CHANGE_USER_NAME );

				PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
				PACKET_GUARD_VOID( kPacket.Write(m_szNewPublicID) );

				m_UserGuild.SendRelayPacketTcp( kPacket );
			}				
			g_DBClient.OnSelectChangedPublicID( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_szNewPublicID );
		}
	}
}

bool User::CheckNS( CPacket &rkPacket )
{
	if( m_pNS == NULL ) return true;

	ioServerSecurity *pSS = (ioServerSecurity*)m_pNS;
	if( !pSS->IsCheckSum( rkPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][chekNS]Check sum fail [%d] [0x%x]",
								GetUserIndex(), rkPacket.GetPacketID() );
		ExceptionClose( 0 );
		return false;
	}
	
	if( !pSS->CheckState( rkPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][chekNS]State different client : [%d] [%d] [%d] [0x%x]", 
			rkPacket.GetState(), pSS->GetRcvState(), GetUserIndex(), rkPacket.GetPacketID() );
		ExceptionClose( 0 );
		return false;
	}
	
	if( !pSS->UpdateReceiveCount() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][chekNS]Many packet is received : [%d] [%d] [0x%x]", 
			pSS->GetRcvCount(), GetUserIndex(), rkPacket.GetPacketID() );

		ExceptionClose( 0 );
		return false;
	}
	
	return true;
}

void User::SessionClose(BOOL safely)
{
	if(IsActive())
	{
		if(!safely)
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]Exception close : [%lu] [%d]", GetUserIndex(), GetLastError() );
			SetLogoutType( 1 );

		}
		CPacket packet(CTPK_CLOSE_SESSION);
		ReceivePacket( packet );
	}
}

bool User::SendMessage( CPacket &rkPacket )
{
	g_ProcessChecker.UserSendMessage( rkPacket.GetPacketID(), rkPacket.GetBufferSize() );

	// Check : Ref
	if( EnableSend( m_RefCount ) == FALSE )
	{
		// log.
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]Disconnect... RefCount : [%d]", GetSendCount() );
		SetSendBlock( true );
		//ExceptionClose( 0 );
		CloseConnection();
		return false;
	}

	bool bSend = CConnectNode::SendMessage( rkPacket );

	return bSend;
}

bool User::RelayPacket( SP2Packet &rkPacket )
{
	return CConnectNode::SendMessage( rkPacket );
}

int User::GetConnectType()
{
	return CONNECT_TYPE_USER;
}

void User::InsertFriend( int iIndex, DWORD dwUserIndex, const ioHashString &szName, int iGradeLevel, int iCampPos, DWORD dwRegTime
						, int iSendCount, DWORD dwSendDate, int iReceiveCount, DWORD dwReceiveDate, int iBeforeReceiveCount, bool bSave )
{
	// Check : Time
	if( dwReceiveDate != 0 || iBeforeReceiveCount != 0 )
	{
		SYSTEMTIME st;
		GetLocalTime( &st );

		CTime CurrentTime( Help::GetSafeValueForCTimeConstructor( st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, 0 ) );

		int year	= dwReceiveDate / tagBestFriend::DATE_YEAR_VALUE;
		int month	= ( dwReceiveDate % tagBestFriend::DATE_YEAR_VALUE ) / tagBestFriend::DATE_MONTH_VALUE;
		int day		= ( dwReceiveDate % tagBestFriend::DATE_MONTH_VALUE ) / tagBestFriend::DATE_DAY_VALUE;
		int hour	= ( dwReceiveDate % tagBestFriend::DATE_DAY_VALUE ) / tagBestFriend::DATE_HOUR_VALUE;
		int min		= dwReceiveDate % tagBestFriend::DATE_HOUR_VALUE;

		CTime LastTime( Help::GetSafeValueForCTimeConstructor( year + tagBestFriend::DEFAULT_YEAR, month, day, hour, min, 0 ) );
		CTimeSpan Span = CurrentTime - LastTime;

		// 받은 클로버 만료시간 체크.
		if( Span.GetTotalMinutes() >= Help::GetCloverReceiveTimeMinute() )
		{
			dwReceiveDate = 0;
			iBeforeReceiveCount = 0;
			bSave = true;

			ioClover* pClover = GetClover();
			if( pClover != NULL )
			{
				// LOGDB : Clover Send
				g_LogDBClient.OnInsertCloverInfo( GetUserIndex(), static_cast< int >( dwUserIndex ),
					ioClover::CLOVER_TYPE_REMOVE, pClover->GetCloverCount() );
			}
		}
		else
		{
			iBeforeReceiveCount = Help::GetCloverReceiveCount();
			bSave = true;
		}
	}

	// friend insert
	m_Friend.InsertFriend( iIndex, dwUserIndex, szName, iGradeLevel, iCampPos, dwRegTime
						, iSendCount, dwSendDate, iReceiveCount, dwReceiveDate, iBeforeReceiveCount, bSave );
}

bool User::DeleteFriend( const ioHashString &szName )
{
	return m_Friend.DeleteFriend( szName );	
}

bool User::IsFriend( const ioHashString &szName )
{
	return m_Friend.IsFriend( szName );
}

bool User::IsFriendRegHourCheck( const ioHashString &szName, DWORD dw24HourBefore )
{
	return m_Friend.IsFriendRegHourCheck( szName, dw24HourBefore );
}

int User::GetFriendOnlineUserCount( DWORD dw24HourBefore )
{
	return m_Friend.GetFriendOnlineUserCount( dw24HourBefore );
}

int User::GetFriendLastIndex()
{
	return m_Friend.GetLastFriendIndex();
}

void User::InsertBestFriend( DWORD dwTableIndex, DWORD dwFriendUserIndex, DWORD dwState, DWORD dwMagicDate )
{
	m_Friend.InsertBestFriend( this, dwTableIndex, dwFriendUserIndex, dwState, dwMagicDate );
}

void User::UpdateBestFriend( DWORD dwUserIndex, DWORD dwState, DWORD dwMagicDate )
{
	m_Friend.UpdateBestFriend( this, dwUserIndex, dwState, dwMagicDate );
}

void User::SendFriendAndGuildUserLogOut()
{
	// 로그아웃 알림.
	SP2Packet kPacket( STPK_USER_LOGIN );

	PACKET_GUARD_VOID( kPacket.Write(1) );
	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
	PACKET_GUARD_VOID( kPacket.Write(false) );

	// 모든 친구에게 로그 아웃 알림
	vFRIEND_iter iter, iEnd;
	iEnd = m_Friend.FriendEnd();
	for(iter = m_Friend.FriendIter( 0 );iter != iEnd;iter++)
	{
		FRIEND &kFriend = *iter;		
		UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kFriend.m_dwUserIndex );
		if( pUserParent )
			pUserParent->RelayPacket( kPacket );		
	}

	// 모든 길드원에게 로그 아웃 알림
	m_UserGuild.SendRelayPacketTcp( kPacket );
}

void User::SendFriendPacket( int iLastIndex, bool bSendLogin )
{
	int iSize = m_Friend.FriendLastIterSize( iLastIndex );
	if( iSize == 0 )
	{
		SP2Packet kPacket( STPK_FRIEND_LIST_MSG );
		kPacket << 0;
		SendMessage( kPacket );
		return;
	}
	else
	{
		SP2Packet kPacket( STPK_FRIEND_LIST_MSG );
		kPacket << iSize;

		vFRIEND_iter iter, iEnd;
		iEnd = m_Friend.FriendEnd();
		for(iter = m_Friend.FriendIter( iLastIndex );iter != iEnd;iter++)
		{
			FRIEND &kFriend = *iter;
			kPacket << kFriend.m_iIndex << kFriend.m_dwUserIndex << kFriend.m_szName;
			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kFriend.m_dwUserIndex );
			if( pUserParent )
			{
				kFriend.m_iGradeLevel   = pUserParent->GetGradeLevel();
				kFriend.m_iCampPosition = pUserParent->GetUserCampPos();

				kPacket << true << pUserParent->GetUserPos() << kFriend.m_iGradeLevel << kFriend.m_iCampPosition 
						<< pUserParent->GetGuildIndex() << pUserParent->GetGuildMark() << pUserParent->IsBestFriend( GetUserIndex() )
						// clover
						<< kFriend.m_dwRegTime
						<< kFriend.m_iCloverSendCount
						<< kFriend.m_iCloverSendDate
						<< kFriend.m_iCloverReceiveCount
						<< kFriend.m_iCloverBeforeReceiveDate
						<< kFriend.m_iCloverBeforeReceiveCount;
				
				if( bSendLogin )
				{
					//친구에게 로그인 알림
					SP2Packet kLoginPacket( STPK_USER_LOGIN );
					kLoginPacket << 1 << GetPublicID() << true << pUserParent->GetGradeLevel() << GetGuildIndex() 
								 << GetGuildMark() << IsBestFriend( pUserParent->GetUserIndex() );
					pUserParent->RelayPacket( kLoginPacket );
				}
			}
			else
			{
				// 친구가 접속 안했을때, 어떻게 보낼지 상의 해야한다. 클로버 데이터를 줄건지..
				kPacket << false << UP_LOBBY << kFriend.m_iGradeLevel << kFriend.m_iCampPosition << 0 << 0 << false
						<< kFriend.m_dwRegTime
						<< kFriend.m_iCloverSendCount
						<< kFriend.m_iCloverSendDate
						<< kFriend.m_iCloverReceiveCount
						<< kFriend.m_iCloverBeforeReceiveDate
						<< kFriend.m_iCloverBeforeReceiveCount;
			}
		}
		SendMessage( kPacket );	
	}
}

void User::SendBestFriendPacket( int iLastIndex )
{
	int iSize = m_Friend.BestFriendLastIterSize( iLastIndex );
	if( iSize == 0 )
	{
		SP2Packet kPacket( STPK_BEST_FRIEND_LIST_MSG );
		kPacket << 0;
		SendMessage( kPacket );
		return;
	}
	else
	{
		SP2Packet kPacket( STPK_BEST_FRIEND_LIST_MSG );
		kPacket << iSize;

		vBestFriend_iter iter, iEnd;
		iEnd = m_Friend.BestFriendEnd();
		for(iter = m_Friend.BestFriendIter( iLastIndex );iter != iEnd;iter++)
		{
			BestFriend &kBestFriend = *iter;
			kPacket << kBestFriend.m_dwIndex << kBestFriend.m_dwUserIndex << kBestFriend.m_dwState << kBestFriend.m_dwMagicDate;
		}
		SendMessage( kPacket );	
	}
}

bool User::SendFriendServerMove( int iLastIndex, int iSendCount, SP2Packet &rkPacket )
{
	int iSize = min( m_Friend.FriendLastIterSize( iLastIndex ), iSendCount );
	rkPacket << GetUserIndex() << iSize << m_iServerMovingValue;

	if( iSize == 0 )
		return false;

	int iCurSize = iSize;
	vFRIEND_iter iter, iEnd;
	iEnd = m_Friend.FriendEnd();
	for(iter = m_Friend.FriendIter( iLastIndex );iter != iEnd;iter++)
	{
		FRIEND &kFriend = *iter;

		rkPacket << kFriend.m_iIndex << kFriend.m_dwUserIndex << kFriend.m_szName << kFriend.m_iGradeLevel << kFriend.m_iCampPosition << kFriend.m_dwRegTime
			<< kFriend.m_iCloverSendCount
			<< kFriend.m_iCloverSendDate
			<< kFriend.m_iCloverReceiveCount
			<< kFriend.m_iCloverBeforeReceiveDate
			<< kFriend.m_iCloverBeforeReceiveCount
			<< kFriend.m_bCloverChangeState;

		if( --iCurSize == 0 )
			break;
	}
	if( iSize != iSendCount )
		return false;
	return true;
}

#ifdef XTRAP
bool User::SendXtrapStep1()
{
	if( !g_ioXtrap.IsUse() )
		return true;

	XtrapPacket kXtrapPacket;
	bool bRet = g_ioXtrap.Step1( m_XtrapSessionBuf, kXtrapPacket.m_XTrapPacket, GetPublicID().c_str(), GetPublicIP(), GetGradeLevel() );

	SP2Packet kPacket( STPK_PROTECT_CHECK );
	kPacket << kXtrapPacket;
	SendMessage( kPacket );
	m_dwXtrapCheckTime = TIMEGETTIME();

	return bRet;
}
#endif

#ifdef NPROTECT
bool User::SendNProtectCheck()
{
	if( !g_ioNProtect.IsUse() )
		return true;

#ifdef NPROTECT_CSAUTH3
	UINT32 uReturnedPacketSize = 0;
	UINT32 uReturn = m_NProtectAuth.Get( &uReturnedPacketSize );
	if( uReturn >= 3000 )
	{
		LOG.PrintTimeAndLog(0, "%s:Error:%d:%s:%d", __FUNCTION__, uReturn , GetPublicID().c_str(), GetUserIndex() );
		return false;
	}

	if( uReturnedPacketSize > NProtectPacket::MAX_PACKET_BUF )
	{
		LOG.PrintTimeAndLog(0, "%s:ErrorSize:%d:%s:%d", __FUNCTION__, uReturnedPacketSize , GetPublicID().c_str(), GetUserIndex() );
		return false;
	}

	if( uReturnedPacketSize <= 0 ) // 서버이동시 클라이언트에서 인증 패킷을 먼저 보내는 경우가 있음, 해당 사항에 대해서 에러를 리턴하지 않도록 처리하는 구문
	{
//		LOG.PrintTimeAndLog(0, "%s:ErrorSize:%d:%s:%d", __FUNCTION__, uReturnedPacketSize , GetPublicID().c_str(), GetUserIndex() );
		return true;
	}

	NProtectPacket kNProtectPacket;
	memcpy( kNProtectPacket.m_byNProtectPacket, m_NProtectAuth.packet, uReturnedPacketSize );
	kNProtectPacket.m_dwStructSize = uReturnedPacketSize + sizeof(DWORD); // sizeof(DWORD)는 size 공간

	SP2Packet kPacket( STPK_PROTECT_CHECK );
	kPacket << kNProtectPacket;
	SendMessage( kPacket );
//	LOG.PrintTimeAndLog(0, "%s:SEND:%d:%s:%d", __FUNCTION__, uReturnedPacketSize, GetPublicID().c_str(), GetUserIndex() );
#else
	if( !m_pNProtectAuth )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : NULL : %s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return false;
	}

	// try문을 걸수 없어 생략
	DWORD dwRet = m_pNProtectAuth->GetAuthQuery();

	if( dwRet != ERROR_SUCCESS )
	{
		SP2Packet kPacket( SUPK_PROTECT );
		kPacket << PROTECT_FAIL_NPROTECT_CHECK;
		g_UDPNode.SendMessage( GetPublicIP(), GetUDP_port(), kPacket );
		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : Error : %d : %08x : %08x : %08x : %08x : %s:%d", __FUNCTION__, dwRet, m_pNProtectAuth->m_AuthQuery.dwIndex, m_pNProtectAuth->m_AuthQuery.dwValue1, m_pNProtectAuth->m_AuthQuery.dwValue2, m_pNProtectAuth->m_AuthQuery.dwValue3, GetPublicID().c_str(), GetUserIndex() );
		return false;
	}

	SP2Packet kPacket( STPK_PROTECT_CHECK );
	kPacket << m_pNProtectAuth->m_AuthQuery;
	SendMessage( kPacket );
#endif

	m_dwNProtectCheckTime = TIMEGETTIME();
	m_iSentNProtectCheckCnt++;

	return true;
}
#endif // NPROTECT

#ifdef HACKSHIELD
bool User::SendHackShieldCheck()
{
	if( !g_ioHackShield.IsUse() )
		return true;

	AHNHS_TRANS_BUFFER kBuf;
	if( !g_ioHackShield.MakeRequest( m_hHackShield, kBuf ) )
		return false;

	SP2Packet kPacket( STPK_PROTECT_CHECK );
	kPacket << kBuf;
	SendMessage( kPacket );

	m_dwHackShieldCheckTime = TIMEGETTIME();

	return true;
}
#endif

void User::EnterRoom( Room *pRoom )
{
	if( !pRoom ) 
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][user]Room is not exist" );
		return;
	}

	bool bTraining = false;
	if( CheckPreRoomNum( pRoom->GetModeType() ) )
	{
		bTraining = true;
	}

	if( !IsLadderTeam() )
	{
		// LadderTeam이 아니면 초기화
		m_iMyVictories = 0;
	}

	//이미 룸에 있으면 나온다.
	if( m_pMyRoom )
	{
		if( m_pMyRoom->GetModeType() == MT_TRAINING || m_pMyRoom->GetModeType() == MT_HEADQUARTERS || m_pMyRoom->GetModeType() == MT_HOUSE )
			m_pMyRoom->LeaveUser( this );                // 트레이닝이면 유저들에게 나가기를 알린다.
		else
			m_pMyRoom->PrivatelyLeaveUser( this );		 // 유저들에게 나가는걸 숨긴다.( 이유 : 룸이 없어짐 )
		m_pMyRoom = NULL;
	}

	if( pRoom )
	{
		InitCharDie();

		enum { MAX_EXERCISE_TYPE = 3, };
		byte chExerciseTypeList[ MAX_EXERCISE_TYPE ]={ EXERCISE_GENERAL, EXERCISE_PCROOM, EXERCISE_EVENT };
		for (int i = 0; i < MAX_EXERCISE_TYPE ; i++)
		{
			if( IsDeleteExerciseChar( pRoom, chExerciseTypeList[i] ) )
			{	
				DeleteExerciseChar( chExerciseTypeList[i] );
				FixSelectChar();
			}	
		}
		CheckExerciseRentalCharDeleteTime();

		ChildrenDayEventEndProcess();

		if( pRoom->IsExceptionRoom() )
		{
			// 모드가 NULL인 룸에 입장하려했다 본부로 보내고 인트라넷에 로그 전송.			
			if( IsBattleRoom() )
			{
				BattleRoomParent *pBattleRoom = g_BattleRoomManager.GetGlobalBattleRoomNode( m_dwMyBattleRoom );
				if( pBattleRoom )
				{
					pBattleRoom->LeaveUser( GetUserIndex(), GetPublicID() );		
				}		
				m_dwMyBattleRoom = 0;
				g_UserNodeManager.UpdateUserSync( this );

				SP2Packet kPacket( STPK_BATTLEROOM_LEAVE );

				PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

				SendMessage( kPacket );
			}

			if( IsShuffleRoom() )
			{
				ShuffleRoomParent *pShuffleRoom = g_ShuffleRoomManager.GetGlobalShuffleRoomNode( m_dwMyShuffleRoom );
				if( pShuffleRoom )
				{
					pShuffleRoom->LeaveUser( GetUserIndex(), GetPublicID() );		
				}		
				m_dwMyShuffleRoom = 0;
				g_UserNodeManager.UpdateUserSync( this );

				SP2Packet kPacket( STPK_SHUFFLEROOM_LEAVE );

				PACKET_GUARD_VOID( kPacket.Write( GetPublicID() ) );

				SendMessage( kPacket );
			}

			SP2Packet kPacket1( STPK_EXIT_ROOM );
			kPacket1 << EXIT_ROOM_LOBBY;
			kPacket1 << -1;
			kPacket1 << false;
			SendMessage( kPacket1 );

			//인트라넷에 로그 전송
			char szLog[2048] = "";
			sprintf_s( szLog, "입장하려는 룸의 모드가 NULL : %s - %d - %d - %d", GetPublicID().c_str(), pRoom->GetRoomIndex(), (int)pRoom->GetRoomStyle(), pRoom->GetJoinUserCnt() );
			SP2Packet kPacket2( LUPK_LOG );
			kPacket2 << "ServerError";
			kPacket2 << szLog;
			g_UDPNode.SendLog( kPacket2 );
		}
		else
		{
			DeleteGuildMarkChangeKeyValue();
			EnterRoomSelectChar();
			InitBonusTable();
			m_pMyRoom        = pRoom;//여기부터 
			m_pMyRoom->EnterUser( this );
			m_dwExitRoomTime	= 0;
			m_dwCurExitRoomTime = 0;			

			g_LogDBClient.OnInsertTime( this, LogDBClient::TT_ENTER_ROOM );
			SetStartTimeLog( 0 ); // 초기화
			g_UserNodeManager.UpdateUserSync( this );
			UpdateEtcItemTime( __FUNCTION__ );

			//if( m_pMyRoom->GetPlazaModeType() == PT_GUILD )
			//{
			//	//입장 시간 update
			//	g_GuildRoomBlockMgr.UpdateGuildRoomEnterTime(GetGuildIndex());
			//}
				
			// Nagle Algorithm Off
			if( m_pMyRoom->GetRoomStyle() != RSTYLE_PLAZA && m_pMyRoom->GetRoomStyle() != RSTYLE_HEADQUARTERS )
			{
				if( Help::IsNagleAlgorithm() )
					SetNagleAlgorithm( false );
			}
			else
			{
				if( Help::IsPlazaNagleAlgorithm() )
					SetNagleAlgorithm( false );
			}
		}
	}
}

void User::LeaveRoom( BYTE eType /* = RLT_NORMAL */ )
{//kyg 여기 부터 
	if( m_pMyRoom != NULL )
	{
		// Nagle Algorithm On
		if( m_pMyRoom->GetRoomStyle() != RSTYLE_PLAZA && m_pMyRoom->GetRoomStyle() != RSTYLE_HEADQUARTERS )
		{
			if( Help::IsNagleAlgorithm() ) //kyg 중간에 알고리즘을 바꾸는 이유 
				SetNagleAlgorithm( true );
		}
		else
		{
			if( Help::IsPlazaNagleAlgorithm() )
				SetNagleAlgorithm( true );
		}

		if( IsFishingState() ) 
		{
			g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
			SetStartTimeLog(0); 
		}

		m_pMyRoom->LeaveUser( this, eType );
		m_pMyRoom = NULL;

		CheckExerciseRentalCharDeleteTime();
		SetStartTimeLog( TIMEGETTIME() );
		g_UserNodeManager.UpdateUserSync( this );
		StartEtcItemTime( __FUNCTION__ );
	}
	m_bStealth = false;
}

void User::NetworkCloseLeaveRooom()
{
	if( m_pMyRoom )
	{
		m_pMyRoom->NetworkCloseLeaveCall( this );
		
		LeaveRoom();
	}
}

void User::NetworkCloseLogout()
{
	RoomParent *pRoomParent = g_RoomNodeManager.GetHeadquartersGlobalNode( m_dwMyHeadquartersIndex );
	if( pRoomParent )
	{
		if( pRoomParent->IsRoomOriginal() )
		{
			Room *pRoom = static_cast< Room * >( pRoomParent );
			pRoom->OnModeLogoutAlarm( GetPublicID() );
		}
		else
		{
			RoomCopyNode *pCopyNode = static_cast< RoomCopyNode * >( pRoomParent );
			SP2Packet kPacket( SSTPK_LOGOUT_ROOM_ALARM );
			kPacket << pCopyNode->GetRoomIndex() << GetPublicID();
			pCopyNode->SendMessage( kPacket );
		}
	}
}

void User::InitBonusTable()
{
	m_BonusTable.Init();
	m_BonusTableBackup.Init();

	// 한번 획득하면 룸을 이동해도 계속 획득한 상태.
	m_BonusTable.m_bPCRoomBonus = IsPCRoomAuthority();
}

void User::SetBonusTable( UserBonusTable &kBonusTable )
{
	m_BonusTable = kBonusTable;

	// 한번 획득하면 룸을 이동해도 계속 획득한 상태.
	m_BonusTable.m_bPCRoomBonus = IsPCRoomAuthority();
}

bool User::ChangeBonusTable()
{
	if( m_BonusTable.m_bPCRoomBonus != m_BonusTableBackup.m_bPCRoomBonus )
		return true;
	else if( m_BonusTable.m_bGuildBonus != m_BonusTableBackup.m_bGuildBonus )
		return true;
	else if( m_BonusTable.m_bFriendBonus != m_BonusTableBackup.m_bFriendBonus )
		return true;
	return false;
}

void User::BackupBonusTable()
{
	m_BonusTableBackup = m_BonusTable;
}

void User::CheckRoomBonusTable()
{
	if( !m_pMyRoom ) return;

	m_pMyRoom->CheckUserBonusTable( NULL );
}

void User::SetLeaveRoomTime( int iIndex )
{
	m_iLeaveRoomIndex = iIndex;
	m_dwLeaveRoomTime = TIMEGETTIME();
	m_dwMemoryLeaveRoomTime = 30000;            //30초 뒤부터 입장 가능하다.
}

void User::CheckLeaveRoomIndex()
{
	if( m_iLeaveRoomIndex == -1 ) return;

	if( TIMEGETTIME() - m_dwLeaveRoomTime > m_dwMemoryLeaveRoomTime )
		m_iLeaveRoomIndex = -1;
}

void User::SetLeaveBattleRoomTime( int iIndex )
{
	m_iLeaveBattleRoomIndex = iIndex;
	m_dwLeaveBattleRoomTime = TIMEGETTIME();
	m_dwMemoryLeaveBattleRoomTime = 30000;            //30초 뒤부터 입장 가능하다.
}

void User::CheckLeaveBattleRoomIndex()
{
	if( m_iLeaveBattleRoomIndex == -1 ) return;

	if( TIMEGETTIME() - m_dwLeaveBattleRoomTime > m_dwMemoryLeaveBattleRoomTime )
		m_iLeaveBattleRoomIndex = -1;
}

void User::LeaveAllRoom()
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		// 전투참여 중이라면 룸에서 이탈시킨다.
		if( IsBattleRoom() )
		{
			LeaveRoom();
			LeaveBattleRoom();
			LeaveLadderTeam();
			LeaveShuffleRoom();
		}
		else
		{
			LeaveRoom();
			LeaveBattleRoom();
			LeaveLadderTeam();
			LeaveShuffleRoom();
		}
	}
	else if( IsBattleRoom() )
	{
		// 전투 대기중이면 전투방 이탈
		LeaveBattleRoom();
	}
	else if( IsShuffleRoom() )
	{
		LeaveShuffleRoom();
	}
	else if( IsLadderTeam() )
	{
		LeaveLadderTeam();
	}
}

void User::ExitRoomToBattleRoomJoin( BattleRoomParent *pBattleRoomNode, bool bObserver, bool bMovePesoPenalty, int iPenaltyPeso )
{
	if( !pBattleRoomNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][user]Battle room is not exist" );
		return;
	}
		
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		// 전투참여 중이라면 룸에서 이탈시킨다.
		if( IsBattleRoom() )
		{
			LeaveRoom();
			LeaveBattleRoom();
			LeaveLadderTeam();
			LeaveShuffleRoom();

			if( !pBattleRoomNode->IsBattleModePlaying() )
			{
				ExitRoomToTraining( EXIT_BATTLEROOM_MOVE, bMovePesoPenalty );
			}
		}
		else
		{
			LeaveRoom();
			LeaveBattleRoom();
			LeaveLadderTeam();
			LeaveShuffleRoom();

			if( !pBattleRoomNode->IsBattleModePlaying() )
			{
				ExitRoomToTraining( EXIT_ROOM_OK, bMovePesoPenalty );
			}
		}
	}
	else if( IsBattleRoom() )
	{
		// 전투 대기중이면 전투방 이탈
		LeaveBattleRoom();
	}
	else if( IsShuffleRoom() )
	{
		LeaveShuffleRoom();
	}

	if( bMovePesoPenalty )
	{
		// 페소 페널티
		if( iPenaltyPeso < 0 )
		{
			HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][user]Penalty peso Hack : [%d] [%d]", GetUserIndex(), iPenaltyPeso );
			iPenaltyPeso = 10000; // 임의의 큰 수
		}
		//hr 라틴에서 사용함
		IncreaseGiveupCount();

		int iDownPeso = DecreasePenaltyPeso( iPenaltyPeso );
		SP2Packet kPenaltyPacket( STPK_EXIT_ROOM_PENALTY );
		kPenaltyPacket << GetMoney() << GetLadderPoint() << iPenaltyPeso << false;			
		SendMessage( kPenaltyPacket );

		// log			
		g_LogDBClient.OnInsertPeso( this, -iDownPeso, LogDBClient::PT_EXIT_ROOM );
	}

	//파티 참여
	EnterBattleRoom( pBattleRoomNode, bObserver );	
}

void User::EnterChannel( ChannelParent *pNode )
{
	if( pNode == NULL ) return;

	if( !FindChannel( pNode->GetIndex() ) )
	{
		m_vChannelNode.push_back( pNode->GetIndex() );
		pNode->EnterChannel( GetUserIndex(), GetPublicID() );
	}
}

void User::LeaveChannel( ChannelParent *pNode )
{
	if( m_vChannelNode.empty() ) return ;

	int iSize = m_vChannelNode.size();

	if( pNode )
	{
		for(int i = 0;i < iSize;i++)
		{
			if( m_vChannelNode[i] == pNode->GetIndex() )
			{
				pNode->LeaveChannel( GetUserIndex(), GetPublicID() );
				m_vChannelNode.erase( m_vChannelNode.begin() + i );
				return;
			}
		}
	}
	else
	{
		for(int i = 0;i < iSize;i++)
		{
			ChannelParent *pChannelNode = g_ChannelNodeManager.GetGlobalChannelNode( m_vChannelNode[i] );
			if( pChannelNode )
				pChannelNode->LeaveChannel( GetUserIndex(), GetPublicID() );
		}		
		m_vChannelNode.clear();
	}
}

void User::LeaveChannelException( DWORD dwNodeIndex )
{
	if( m_vChannelNode.empty() ) return ;

	int iSize = m_vChannelNode.size();
	for(int i = 0;i < iSize;i++)
	{
		if( m_vChannelNode[i] == dwNodeIndex )
		{
			m_vChannelNode.erase( m_vChannelNode.begin() + i );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning[user]Leave channel exception : [%d] [%d]", GetUserIndex(), dwNodeIndex );
			return;
		}
	}
}

ChannelParent *User::FindChannel( DWORD dwIndex )
{
	int iSize = m_vChannelNode.size();
	for(int i = 0;i < iSize;i++)
	{
		if( m_vChannelNode[i] == dwIndex )
		{
			ChannelParent *pChannelParent = g_ChannelNodeManager.GetGlobalChannelNode( m_vChannelNode[i] );
			return pChannelParent;
		}
	}
	return NULL;
}

bool User::IsPartyPossible()
{
	if( !m_pMyRoom )
		return true;
	return true;
}

void User::ExitRoomToTraining( int iResult, bool bPenalty )
{
	SetExitPosition( true );     // 무조건 로비로 이동 시킨다.

	int iNewResult = iResult;
	if( iResult == EXIT_ROOM_WANT    ||
	    iResult == EXIT_ROOM_PENALTY ||
	    iResult == EXIT_ROOM_QUICK_OUT )
	{
		iNewResult = EXIT_ROOM_OK;
	}
	else if( iResult == EXIT_ROOM_SAFETY_KICK         || 
		     iResult == EXIT_ROOM_LOBBY               || 
			 iResult == EXIT_BATTLEROOM_MOVE		  ||
			 iResult == EXIT_ROOM_NOT_CHAR            || 
			 iResult == EXIT_ROOM_ENTRY_NOT_FORMALITY    )
	{
		iNewResult = iResult;
	}

	// 로비 나가기
	if( m_bExitLobby == true              ||
		iResult == EXIT_ROOM_LOBBY               ||
		iResult == EXIT_BATTLEROOM_MOVE			 ||
		iResult == EXIT_ROOM_NOT_CHAR            || 
		iResult == EXIT_ROOM_ENTRY_NOT_FORMALITY ||
		iResult == EXIT_ROOM_BAD_NETWORK		 ||
		iResult == EXIT_ROOM_CONTINUE_END )
	{
		LeaveRoom();

		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << iNewResult;
		kPacket << -1;
		kPacket << bPenalty;
		SendMessage( kPacket );

		return;
	}
	else if( iResult == EXIT_ROOM_CHAR_LIMIT || iResult == EXIT_ROOM_MONSTER_COIN_LACK )
	{
		LeaveRoom();         //본부로 보낸다.

		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << iResult;
		kPacket << -1;
		kPacket << bPenalty;
		SendMessage( kPacket );

		return;
	}
	else if( iResult == EXIT_ROOM_RESERVED || iResult == EXIT_ROOM_CANCELED )
	{
		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << iResult;
		kPacket << -1;
		kPacket << false;
		SendMessage( kPacket );

		return;
	}

	Room *pRoom = g_RoomNodeManager.GetExitRoomJoinPlazaNode( GetKillDeathLevel() );
	if( GetCharCount() == 0 || pRoom == NULL )       //본부 이동
	{
		LeaveRoom();

		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << EXIT_ROOM_LOBBY;
		kPacket << -1;
		kPacket << bPenalty;
		SendMessage( kPacket );

		return;
	}
	else
	{
		LeaveRoom();

		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << iNewResult;
		kPacket << pRoom->GetModeSubNum();
		kPacket << bPenalty;
		kPacket << pRoom->GetRoomNumber();
		kPacket << pRoom->GetModeMapNum();
		kPacket << (int)pRoom->GetPlazaModeType();
		SendMessage( kPacket );

		EnterRoom( pRoom );
	}	
}

void User::PrivatelyLeaveRoomToTraining()
{	
	if( m_pMyRoom != NULL )
	{
		if( m_pMyRoom->GetModeType() == MT_TRAINING || m_pMyRoom->GetModeType() == MT_HEADQUARTERS || m_pMyRoom->GetModeType() == MT_HOUSE )
			m_pMyRoom->LeaveUser( this );                // 트레이닝이면 유저들에게 나가기를 알린다.
		else
			m_pMyRoom->PrivatelyLeaveUser( this );		 // 유저들에게 나가는걸 숨긴다.( 이유 : 룸이 없어짐 )
		m_pMyRoom = NULL;
	}

	Room *pRoom = g_RoomNodeManager.GetExitRoomJoinPlazaNode( GetKillDeathLevel() );
	if( pRoom )
	{
		SP2Packet kPacket( STPK_MOVING_ROOM );
		kPacket << pRoom->GetModeType() << pRoom->GetModeSubNum() << pRoom->GetModeMapNum() << (int)pRoom->GetPlazaModeType();
		SendMessage( kPacket );
		EnterRoom( pRoom );
	}		
	else
	{
		ExitRoomToTraining( EXIT_ROOM_LOBBY, false );
	}	
}

void User::LeaveServer( const int iServerIndex )
{
	SP2Packet kPacket( STPK_LOGIN_MOVESERVER );   
	kPacket << iServerIndex;
	SendMessage( kPacket );		

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Server Block(Move order) : %s %d", GetPublicID().c_str(), iServerIndex );
}

void User::EnterBattleRoom( BattleRoomParent *pBattleRoom, bool bObserver )
{
	if( !pBattleRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"[warning][user]Battle room doesn't exist");
		return;
	}

	if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"[warning][user]User is playing ladder game : [%d]", GetUserIndex() );
		return;
	}

	if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"[warning][user]User is playing game : [%d] [%d] [%d]", GetUserIndex(), m_dwMyBattleRoom,pBattleRoom->GetIndex() );
		// 이미 파티에 있는 유저인데 또 파티에 접속하는건 버그! 여기서 흘려 버리는 2차 3차 버그의 원인이 되므로 차단.
		return;
	}

	if( pBattleRoom )
	{
		InitCharDie();
		m_dwMyBattleRoom = pBattleRoom->GetIndex();
		pBattleRoom->EnterUser( GetUserIndex(), GetPublicID(), GetGradeLevel(), GetKillDeathLevel(), IsSafetyLevel(), bObserver,
								GetPublicIP(), GetPrivateIP(), g_App.GetClientMoveIP(), GetUDP_port(), g_App.GetCSPort() );
		g_UserNodeManager.UpdateUserSync( this );
	}
}

bool User::EnterBattleRoom( DWORD dwBattleRoom, ServerNode *pBattleRoomServer )
{
	if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"길드 유저가 전투에 참여하려했음 : %s", GetPublicID().c_str() );
		return false;
	}
	else if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"이미 전투롬에 참가하고 있음 Type 2 [%s] Pre(%d) - New(%d)",
							  GetPublicID().c_str(), m_dwMyBattleRoom, dwBattleRoom );
		// 이미 파티에 있는 유저인데 또 파티에 접속하는건 버그! 여기서 흘려 버리는 2차 3차 버그의 원인이 되므로 차단.
		return false;
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"EnterBattleRoom : 이미 룸에있는 유저가 파티생성 :%s",GetPublicID().c_str());
		return false;
	}
	else if( GetBuyCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"EnterBattleRoom : 구입 용병이 없는 유저가 파티생성 :%s",GetPublicID().c_str());
		return false;
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"EnterBattleRoom : 임시가입 만료 유저가 파티생성 :%s / %d", GetPublicID().c_str(), GetEntryType() );
		return false;
	}

	if( pBattleRoomServer )
	{
		InitCharDie();
		m_dwMyBattleRoom = dwBattleRoom;
		// 해당 서버에 전송		
		SP2Packet kPacket( SSTPK_BATTLEROOM_TRANSFER );
		kPacket << BattleRoomParent::ENTER_USER << dwBattleRoom;
		kPacket << GetUserIndex() << GetPublicID() << GetGradeLevel() << GetKillDeathLevel() << IsSafetyLevel() << false
				<< GetPublicIP() << GetPrivateIP() << g_App.GetClientMoveIP() << GetUDP_port() << g_App.GetCSPort();
		pBattleRoomServer->SendMessage( kPacket );
		g_UserNodeManager.UpdateUserSync( this );
		return true;
	}
	return false;
}

void User::LeaveBattleRoom( bool bJoinFailed )
{
	if( IsBattleRoom() )
	{
		BattleRoomParent *pBattleRoom = g_BattleRoomManager.GetGlobalBattleRoomNode( m_dwMyBattleRoom );
		if( pBattleRoom )
		{
			bool bObserver = false;
			if( pBattleRoom->IsOriginal() )
			{
				BattleRoomNode *pNode = (BattleRoomNode*)pBattleRoom;
				if( pNode )
					bObserver = pNode->IsObserver( GetPublicID() );
			}

			pBattleRoom->LeaveUser( GetUserIndex(), GetPublicID() );	
			
			if( !bJoinFailed && !bObserver )
			{
				// 입장 실패가 아닐 때만 이탈룸으로 판단함.
				SetLeaveBattleRoomTime( pBattleRoom->GetIndex() );
			}
		}		
		else
		{
			// 예외오류 : 이탈하려는 룸이 없다. 전체 서버에 해당 전투방의 이탈을 알린다.
			SP2Packet kPacket( SSTPK_EXCEPTION_BATTLEROOM_LEAVE );
			kPacket << m_dwMyBattleRoom << GetUserIndex() << GetPublicID();
			g_ServerNodeManager.SendMessageAllNode( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ERROR!! : User::LeaveBattleRoom(%d) : %s", m_dwMyBattleRoom, GetPublicID().c_str() );
		}

		m_dwMyBattleRoom = 0;
		SetModeConsecutively( MT_NONE );
		g_UserNodeManager.UpdateUserSync( this );
	}
}

void User::LeaveBattleRoomException( DWORD dwNodeIndex )
{
	if( dwNodeIndex == 0 ) return;
	if( m_dwMyBattleRoom == 0 ) return;
	if( m_dwMyBattleRoom != dwNodeIndex ) return;

	// 플레이중이라면 룸에서도 이탈
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LeaveRoom();
		LeaveBattleRoom();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::LeaveBattleRoomException (%d) - %s - Room And BattleRoom Exit", dwNodeIndex, GetPublicID().c_str() );
	}
	else
	{
		LeaveBattleRoom();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::LeaveBattleRoomException (%d) - %s - BattleRoom Exit", dwNodeIndex, GetPublicID().c_str() );
	}	

	SP2Packet kPacket( STPK_BATTLEROOM_LEAVE );

	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

	SendMessage( kPacket );
}

bool User::IsBattleRoom()
{
	if( m_dwMyBattleRoom != 0 )
		return true;
	return false;
}

void User::EnterShuffleRoom( ShuffleRoomParent *pShuffleRoomNode, bool bReJoinCheck /* = true */ )
{
	if( !pShuffleRoomNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"참가하려는 셔플룸 없음" );
		return;
	}

	if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"길드 유저가 전투에 참여하려했음 : %s", GetPublicID().c_str() );
		return;
	}

	if( bReJoinCheck && IsShuffleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "이미 셔플룸에 참가하고 있음 Type 1 [%s] Pre(%u) - New(%u)", GetPublicID().c_str(), m_dwMyShuffleRoom, pShuffleRoomNode->GetIndex() );
		return;
	}

	InitCharDie();

	SetShuffleGlboalSearch( false );
	SyncUserShuffle();

	m_dwMyShuffleRoom = pShuffleRoomNode->GetIndex();

	pShuffleRoomNode->EnterUser( GetUserIndex(), GetPublicID(), GetGradeLevel(), GetKillDeathLevel(), GetPublicIP(), GetPrivateIP(), g_App.GetClientMoveIP(), GetUDP_port(), g_App.GetCSPort() );

	g_UserNodeManager.UpdateUserSync( this );
}

void User::LeaveShuffleRoom( bool bJoinFailed /* = false */ )
{
	if( IsShuffleRoom() )
	{
		ShuffleRoomParent *pShuffleRoom = g_ShuffleRoomManager.GetGlobalShuffleRoomNode( m_dwMyShuffleRoom );
		if( pShuffleRoom )
		{
			pShuffleRoom->LeaveUser( GetUserIndex(), GetPublicID() );	
		}		
		else
		{
			// 예외오류 : 이탈하려는 룸이 없다. 전체 서버에 해당 전투방의 이탈을 알린다.
			SP2Packet kPacket( SSTPK_EXCEPTION_SHUFFLEROOM_LEAVE );
			PACKET_GUARD_VOID( kPacket.Write( m_dwMyShuffleRoom ) );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( GetPublicID() ) );
			g_ServerNodeManager.SendMessageAllNode( kPacket );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ERROR!! : User::LeaveShuffleRoom(%d) : %s", m_dwMyShuffleRoom, GetPublicID().c_str() );
		}

		m_dwMyShuffleRoom = 0;
		SetModeConsecutively( MT_NONE );
		g_UserNodeManager.UpdateUserSync( this );
	}
}

void User::LeaveShuffleRoomException( DWORD dwNodeIndex )
{
	if( dwNodeIndex == 0 ) return;
	if( m_dwMyShuffleRoom == 0 ) return;
	if( m_dwMyShuffleRoom != dwNodeIndex ) return;

	// 플레이중이라면 룸에서도 이탈
	if( m_pMyRoom )
	{
		LeaveRoom();
		LeaveShuffleRoom();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::LeaveShuffleRoomException (%d) - %s - Room And BattleRoom Exit", dwNodeIndex, GetPublicID().c_str() );
	}
	else
	{
		LeaveShuffleRoom();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::LeaveShuffleRoomException (%d) - %s - BattleRoom Exit", dwNodeIndex, GetPublicID().c_str() );
	}	

	SP2Packet kPacket( STPK_BATTLEROOM_LEAVE );
	PACKET_GUARD_VOID( kPacket.Write( GetPublicID() ) );

	SendMessage( kPacket );
}

bool User::IsShuffleRoom()
{
	if( m_dwMyShuffleRoom != 0 )
		return true;

	return false;
}

void User::EnterLadderTeam( LadderTeamParent *pLadderTeam )
{
	if( !pLadderTeam )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"참가하려는 길드팀 없음");
		return;
	}

	if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "이미 전투에 있는 유저가 길드팀 참여!! Type 1(%s)", GetPublicID().c_str() );		
		return;
	}

	if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "이미 길드팀에 참가하고 있음 Type 1 [%s] Pre(%d) - New(%d)",
							    GetPublicID().c_str(), m_dwMyLadderTeam, pLadderTeam->GetIndex() );		
		return;
	}

	if( pLadderTeam )
	{
		InitCharDie();
		m_iMyVictories = 0;
		m_dwMyLadderTeam = pLadderTeam->GetIndex();
		pLadderTeam->EnterUser( GetUserIndex(), GetPublicID(), GetGradeLevel(), GetKillDeathLevel(), GetHeroMatchPoint(), GetLadderPoint(), GetGuildIndex(), GetGuildMark(),
 							    GetPublicIP(), GetPrivateIP(), g_App.GetClientMoveIP(), GetUDP_port(), g_App.GetCSPort() );
		g_UserNodeManager.UpdateUserSync( this );
	}
}

bool User::EnterLadderTeam( DWORD dwLadderTeam, ServerNode *pLadderTeamServer )
{
	if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "이미 전투에 있는 유저가 길드팀 참여!! Type 2(%s)", GetPublicID().c_str() );		
		return false;
	}
	else if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "이미 길드팀에 참가하고 있음 Type 2 [%s] Pre(%d) - New(%d)",
								GetPublicID().c_str(), m_dwMyLadderTeam, dwLadderTeam );
		return false;
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"EnterLadderTeam : 이미 룸에있는 유저가 길드팀생성 :%s",GetPublicID().c_str());
		return false;
	}
	else if( GetBuyCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"EnterLadderTeam : 구입 용병이 없는 유저가 길드팀생성 :%s",GetPublicID().c_str());
		return false;
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"EnterLadderTeam : 임시가입만료 유저가 길드팀생성 :%s / %d", GetPublicID().c_str(), GetEntryType() );
		return false;
	}

	if( pLadderTeamServer )
	{
		InitCharDie();
		m_iMyVictories = 0;
		m_dwMyLadderTeam = dwLadderTeam;
		// 해당 서버에 전송		
		SP2Packet kPacket( SSTPK_LADDERTEAM_TRANSFER );
		kPacket << LadderTeamParent::ENTER_USER << dwLadderTeam;
		kPacket << GetUserIndex() << GetPublicID() << GetGradeLevel() << GetKillDeathLevel() << GetHeroMatchPoint() << GetLadderPoint() << GetGuildIndex() << GetGuildMark()
				<< GetPublicIP() << GetPrivateIP() << g_App.GetClientMoveIP() << GetUDP_port() << g_App.GetCSPort();
		pLadderTeamServer->SendMessage( kPacket );
		g_UserNodeManager.UpdateUserSync( this );
		return true;
	}
	return false;
}

void User::LeaveLadderTeam()
{
	if( IsLadderTeam() )
	{
		LadderTeamParent *pLadderTeam = g_LadderTeamManager.GetGlobalLadderTeamNode( m_dwMyLadderTeam );
		if( pLadderTeam )
		{
			pLadderTeam->LeaveUser( GetUserIndex(), GetPublicID() );		
		}		
		else
		{
			// 예외오류 : 이탈하려는 팀이 없다. 전체 서버에 해당 길드팀의 이탈을 알린다.
			SP2Packet kPacket( SSTPK_EXCEPTION_LADDERTEAM_LEAVE );
			
			PACKET_GUARD_VOID( kPacket.Write(m_dwMyLadderTeam) );
			PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
			PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

			g_ServerNodeManager.SendMessageAllNode( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ERROR!! : User::LeaveLadderTeam(%d) : %s", m_dwMyLadderTeam, GetPublicID().c_str() );
		}
		m_iMyVictories = 0;
		m_dwMyLadderTeam = 0;
		SetModeConsecutively( MT_NONE );
		g_UserNodeManager.UpdateUserSync( this );
	}
}

void User::LeaveLadderTeamException( DWORD dwNodeIndex )
{
	if( dwNodeIndex == 0 ) return;
	if( m_dwMyLadderTeam == 0 ) return;
	if( m_dwMyLadderTeam != dwNodeIndex ) return;

	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LeaveRoom();
		LeaveLadderTeam();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::LeaveBattleRoomException (%d) - %s - Room And LadderTeam Exit", dwNodeIndex, GetPublicID().c_str() );
	}
	else
	{
		LeaveLadderTeam();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::LeaveBattleRoomException (%d) - %s - LadderTeam Exit", dwNodeIndex, GetPublicID().c_str() );
	}	

	SP2Packet kPacket( STPK_LADDERTEAM_LEAVE );

	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

	SendMessage( kPacket );
}

bool User::IsLadderTeam()
{
	if( m_dwMyLadderTeam != 0 )
		return true;
	return false;
}

void User::ExitRoomToLadderTeamJoin( LadderTeamParent *pLadderTeam )
{
	if( !pLadderTeam )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ExitRoomToLadderTeamJoin LadderTeam Pointer NULL !" );
		return;
	}

	// 전투참여 중이라면 룸에서 이탈시킨다.
	if( m_pMyRoom && 
		!m_pMyRoom->IsNoBattleModeType() )
	{
		LeaveRoom();
		LeaveBattleRoom();
		LeaveLadderTeam();

		ExitRoomToTraining( EXIT_ROOM_OK, false );
	}

	//파티 참여
	EnterLadderTeam( pLadderTeam );	
}

void User::LeaveGuildToLeaveGuildPlaza(DWORD dwGuildIndex)
{
	if( !m_pMyRoom ) return;
	if( m_pMyRoom->GetRoomStyle() != RSTYLE_PLAZA ) return;
	if( m_pMyRoom->GetPlazaModeType() != PT_GUILD ) return;

	GuildRoomInfos* pInfo	= g_GuildRoomBlockMgr.GetGuildRoomInfos(dwGuildIndex);
	if( pInfo )
	{
		if( m_pMyRoom->GetRoomIndex() == pInfo->GetGuildRoomIndex() )
		{
			if( pInfo->GetConstructingUserIndex() == GetUserIndex() )
				pInfo->SetConstructingState(FALSE);
		}
	}

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "길드광장에있는데 길드 탈퇴되었음 : %s", GetPublicID().c_str() );
	ExitRoomToTraining( EXIT_ROOM_LOBBY, false );
}

void User::LeaveGuildToQuestClear()
{
	m_Quest.ClearGuildQuestProgressAll();
}

void User::SyncUserLogin()
{
	if( GetUserIndex() == 0 ) return;

	SP2Packet kPacket( SSTPK_USER_SYNC );

	PACKET_GUARD_VOID( kPacket.Write(USER_SYNC_LOGIN) );
	FillUserLogin( kPacket );
	g_ServerNodeManager.SendMessageAllNode( kPacket );

	m_SyncTable.m_iGradeLevel = GetGradeLevel();
	m_SyncTable.m_iKillDeathLevel  = GetKillDeathLevel();
	m_SyncTable.m_iLadderPoint = GetLadderPoint();
	m_SyncTable.m_iUserPos = GetUserPos();
	m_SyncTable.m_bSafetyLevel = IsSafetyLevel();

	//
	g_HeroRankManager.CheckLogIn( GetUserIndex(), GetPublicID() );
}

void User::FillUserLogin( SP2Packet &rkPacket )
{
	PACKET_GUARD_VOID( rkPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetUserDBAgentID()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetPrivateID()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetPublicID()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetUserCampPos()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetUserRanking()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetGradeLevel()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetUserPos()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetKillDeathLevel()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetLadderPoint()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(IsSafetyLevel()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetGuildIndex()) ); 
	PACKET_GUARD_VOID( rkPacket.Write(GetGuildMark()) );
	
	//hr 서버 이동
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN )
	{
		PACKET_GUARD_VOID( rkPacket.Write( GetCountry()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetLatinConnTime()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetFistWinCount()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetFirstLoseCount()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetFirstMoney()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetGiveupCount()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetFirstExp()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetLogoutType()) );
		PACKET_GUARD_VOID( rkPacket.Write( GetGender()) );

		PACKET_GUARD_VOID( rkPacket.Write( GetWinCount() ) );
		PACKET_GUARD_VOID( rkPacket.Write( GetLoseCount() ) );
	}
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_EU )
	{
		PACKET_GUARD_VOID( rkPacket.Write( GetEUCountryType() ) );
	}

	FillUserBestFriend( rkPacket );
}

void User::SyncUserLogout()
{
	if( GetUserIndex() == 0 ) return;

	SP2Packet kPacket( SSTPK_USER_SYNC );

	PACKET_GUARD_VOID( kPacket.Write(USER_SYNC_LOGOUT) );
	PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );

	g_ServerNodeManager.SendMessageAllNode( kPacket );

	//
	g_HeroRankManager.CheckLogOut( GetUserIndex() );
}

void User::SyncUserUpdate()
{
	if( GetUserIndex() == 0 ) return;

	bool bUpdate = false;
	if( m_SyncTable.m_iGradeLevel != GetGradeLevel() )
		bUpdate = true;
	else if( m_SyncTable.m_iKillDeathLevel != GetKillDeathLevel() )
		bUpdate = true;
	else if( m_SyncTable.m_bSafetyLevel != IsSafetyLevel() )
		bUpdate = true;
	else if( m_SyncTable.m_iLadderPoint != GetLadderPoint() )
		bUpdate = true;

	if( bUpdate )
	{
		SP2Packet kPacket( SSTPK_USER_SYNC );
		kPacket << USER_SYNC_UPDATE << GetUserIndex() << GetGradeLevel() << GetUserPos() << GetPingStep() << GetKillDeathLevel() << GetLadderPoint() << IsSafetyLevel();
		if( m_pMyRoom )
			kPacket << m_pMyRoom->GetModeType();
		else
			kPacket << MT_NONE;
		g_ServerNodeManager.SendMessageAllNode( kPacket );

		// 유저 정보가 변경되었으므로 전투룸/길드팀에 보고
		BattleRoomMyInfo();
		LadderTeamMyInfo();
		ShuffleRoomMyInfo();
	}
	else
	{
		SyncUserPos();
	}	

	m_SyncTable.m_iGradeLevel = GetGradeLevel();
	m_SyncTable.m_iKillDeathLevel  = GetKillDeathLevel();
	m_SyncTable.m_iLadderPoint = GetLadderPoint();
	m_SyncTable.m_iUserPos = GetUserPos();
	m_SyncTable.m_bSafetyLevel = IsSafetyLevel();
}

void User::SyncUserPos()
{
	SP2Packet kPacket( SSTPK_USER_SYNC );
	kPacket << USER_SYNC_POS << GetUserIndex() << GetUserPos() << GetPingStep();
	if( m_pMyRoom )
		kPacket << m_pMyRoom->GetModeType();
	else
		kPacket << MT_NONE;
	g_ServerNodeManager.SendMessageAllNode( kPacket );
}

void User::SyncUserGuild()
{
	SP2Packet kPacket( SSTPK_USER_SYNC );
	PACKET_GUARD_VOID ( kPacket.Write(USER_SYNC_GUILD) );
	PACKET_GUARD_VOID ( kPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID ( kPacket.Write(GetGuildIndex()) );
	PACKET_GUARD_VOID ( kPacket.Write(GetGuildMark()) );
	g_ServerNodeManager.SendMessageAllNode( kPacket );
}

void User::SyncUserCamp()
{
	SP2Packet kPacket( SSTPK_USER_SYNC );
	kPacket << USER_SYNC_CAMP << GetUserIndex() << GetUserCampPos();
	g_ServerNodeManager.SendMessageAllNode( kPacket );

	//
	g_HeroRankManager.CheckCamp( GetUserIndex(), GetUserCampPos() );
}

void User::SyncUserPublicID()
{
	SP2Packet kPacket( SSTPK_USER_SYNC );
	kPacket << USER_SYNC_PUBLICID << GetUserIndex() << GetPublicID();
	g_ServerNodeManager.SendMessageAllNode( kPacket );
}

void User::SyncUserBestFriend()
{
	SP2Packet kPacket( SSTPK_USER_SYNC );
	kPacket << USER_SYNC_BESTFRIEND << GetUserIndex();
	FillUserBestFriend( kPacket );
	g_ServerNodeManager.SendMessageAllNode( kPacket );
}

void User::SyncUserShuffle()
{
	SP2Packet kPacket( SSTPK_USER_SYNC );
	PACKET_GUARD_VOID( kPacket.Write( USER_SYNC_SHUFFLE ) );
	PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
	PACKET_GUARD_VOID( kPacket.Write( m_bShuffleGlobalSearch ) );
	g_ServerNodeManager.SendMessageAllNode( kPacket );
}

void User::FillUserBestFriend( SP2Packet &rkPacket )
{
	DWORDVec vBestFriend;
	GetBestFriend( vBestFriend );
	PACKET_GUARD_VOID( rkPacket.Write((int)vBestFriend.size()) );
	for(int i = 0;i < (int)vBestFriend.size();i++)
		PACKET_GUARD_VOID( rkPacket.Write(vBestFriend[i]) );
}

void User::EquipDBItemToChar( int iCharArray )
{
	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
		return;
	
	ioCharacter *rkChar = m_CharList[iCharArray];
	if(rkChar == NULL)
		return;

	rkChar->ClearEquipSlot();

	// 맨몸 옵션 체크
	bool bEquipSkip = false;
	BattleRoomNode* pBattleRoom = (BattleRoomNode*)g_BattleRoomManager.GetBattleRoomNode( m_dwMyBattleRoom );
	if( pBattleRoom )
	{
		if( pBattleRoom->IsUseExtraOption() )
		{
			if( GetTeam() == TEAM_RED && pBattleRoom->GetRedEquipType() == 1 )
				bEquipSkip = true;
			else if( GetTeam() == TEAM_BLUE && pBattleRoom->GetBlueEquipType() == 1 )
				bEquipSkip = true;
		}
	}

	// 아이템을 장착하지 않는다.
	if( bEquipSkip ) return;

	int iClassType = rkChar->GetCharInfo().m_class_type;

	for( int i=0 ; i<MAX_CHAR_DBITEM_SLOT ; i++ )
	{
		ioItem *pPreItem = NULL;
		const ITEM_DATA *pItemData = rkChar->GetDBItemData( i );

		if( pItemData && pItemData->m_item_code > 0 )
		{
			if( m_pMyRoom == NULL )
				return;

			// 노장비 체크
			if( pBattleRoom && pBattleRoom->IsUseExtraOption() && pBattleRoom->GetExtraItemUseType() == 1 )
			{
				if( !m_pMyRoom->IsNoBattleModeType() )
				{
					ITEM_DATA kDefault;
					kDefault.m_item_code = (100000 * i) + iClassType;
					kDefault.m_item_reinforce = 0;
					kDefault.m_item_male_custom = 0;
					kDefault.m_item_female_custom = 0;

					ioItem *pNewItem = m_pMyRoom->CreateItem( kDefault, GetPublicID() );
					pPreItem = rkChar->EquipItem( i, pNewItem );
				}
				else
				{
					ioItem *pNewItem = m_pMyRoom->CreateItem( *pItemData, GetPublicID() );
					pPreItem = rkChar->EquipItem( i, pNewItem );
				}
			}
			else
			{
				ioItem *pNewItem = m_pMyRoom->CreateItem( *pItemData, GetPublicID() );
				pPreItem = rkChar->EquipItem( i, pNewItem );
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][equipItem] character DB ItemData is invalid : id:%s class:%d slot:%d", GetPublicID().c_str(), iClassType, i );
			pPreItem = rkChar->ReleaseItem( i );
		}

		SAFEDELETE( pPreItem );
	}
}

void User::EquipDBItemToAllChar()
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		EquipDBItemToChar( i );
	}
}

void User::EquipGangsiItemToAllChar()
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "EquipGangsiItemToAllChar (%s) Null Room", GetPublicID().c_str() );
		return;
	}

	for( int iCharArray=0 ; iCharArray<GetCharCount() ; iCharArray++ )
	{
		if( !COMPARE( iCharArray, 0, GetCharCount() ) )
			return;

		ioCharacter *rkChar = m_CharList[iCharArray];
		if( rkChar == NULL )
			return;

		rkChar->ClearEquipSlot();
		for( int i=0 ; i<MAX_CHAR_DBITEM_SLOT ; i++ )
		{
			//강시 모드에서 강시는 특별 아이템 착용
			ITEM_DATA kDefault;
			kDefault.m_item_code      = m_pMyRoom->GetGangsiItem( i );
			kDefault.m_item_reinforce = 0;
			kDefault.m_item_male_custom = 0;
			kDefault.m_item_female_custom = 0;
			
			ioItem *pNewItem = m_pMyRoom->CreateItem( kDefault, GetPublicID() );
			ioItem *pPreItem = rkChar->EquipItem( i, pNewItem );
			SAFEDELETE( pPreItem );
		}
	}
}

void User::EquipDBItemToLiveChar()
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		if( rkChar->IsCharDie() )
			rkChar->ClearEquipSlot();
		else
			EquipDBItemToChar( i );
	}
}

void User::AllCharReEquipDBItem( int iSlotIndex )
{
	for( int iCharArray=0 ; iCharArray<GetCharCount() ; iCharArray++ )
	{
		if( !COMPARE( iCharArray, 0, GetCharCount() ) )
			return;

		ioCharacter *rkChar = m_CharList[iCharArray];
		if( rkChar == NULL )
			return;

		rkChar->ChangeDBExtraItem( this, iSlotIndex );
	}
}

void User::ReleaseEquipAllChar()
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		m_CharList[i]->ClearEquipSlot();
	}
}

void User::ReleaseAllItemSelectChar()
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
		return;

	ioCharacter *rkChar = m_CharList[m_select_char];
	if(rkChar == NULL)
		return;

	rkChar->ClearEquipSlot();
}

void User::ClearRealEquipItemOwner( const ioHashString &rkOutUser )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		m_CharList[i]->ClearOwnerNameInEquipSlot( rkOutUser );
	}
}

ioCharacter* User::GetCharacter( int iArray )
{
	if( COMPARE( iArray, 0, GetCharCount() ) )
		return m_CharList[iArray];

	//LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][user]Get character - overflow [%lu] [%d]", GetUserIndex(), iArray );

	return NULL;
}

ioCharacter* User::GetLeaderCharacter()
{
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetLeaderType() == CLT_LEADER )
		{
			return m_CharList[i];
		}
	}

	// 설정된 대표가 없으면 가장 높은 레벨
	int iLeaderLevel = -1;
	ioCharacter *pLeaderChar = NULL;
	for(i = 0;i < GetCharCount();i++)
	{
		int iClassLevel = GetClassLevelByType( m_CharList[i]->GetCharInfo().m_class_type, true );
		if( iLeaderLevel < iClassLevel )
		{
			iLeaderLevel = iClassLevel;
			pLeaderChar  = m_CharList[i];
		}
	}
	return pLeaderChar;
}

void User::CreateSelectCharData( ioCharacter *pChar )
{
	if( !pChar ) return;

	const CHARACTER &rkChar = pChar->GetCharInfo();
	if( rkChar.m_ePeriodType == CPT_MORTMAIN )
	{
		PesoBonusEventUserNode *pEventNode = static_cast<PesoBonusEventUserNode*>( m_EventUserMgr.GetEventUserNode( EVT_PESOBONUS ) );
		if( pEventNode )
			pEventNode->SetPesoBonus( this );
	}	
}

void User::StartCharLimitDate( DWORD dwCheckSecond, const ioHashString &szCallFunName, int iLine )
{
	if( !m_pMyRoom ) return;
	if( !m_pMyRoom->IsCharLimitCheck( this ) ) return;

	int iStartCount = 0;
	for(int i = 0;i < GetCharCount();i++)
	{
		ioCharacter *rkChar = m_CharList[i];
		if( !rkChar->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		if( !rkChar->IsActive() ) continue;      //이미 기간이 만료된 용병
		if( rkChar->IsMortmain() ) continue;
		if( rkChar->IsDate() ) continue;
		
		if( rkChar->StartLimitTimer( dwCheckSecond ) )
			iStartCount++;
	}
	//LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "CallFun : %s Line %d", szCallFunName.c_str(), iLine );
	
	// 용병 기간 체크 시작
	SP2Packet kPacket( STPK_START_CHAR_LIMITDATE );
	kPacket << GetCharCount();
	for(int i = 0;i < GetCharCount();i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		kPacket << rkChar->GetCharIndex() << rkChar->IsActive() << rkChar->GetCharLimitDate() << rkChar->GetLimitCheckSecond();
	}
	SendMessage( kPacket );
}

void User::StartCharLimitDate( ioCharacter *pChar )
{
	if( !pChar ) return;
	if( !m_pMyRoom ) return;
	if( !m_pMyRoom->IsCharLimitCheck( this ) ) return;
	if( pChar->IsMortmain() ) return;
	if( pChar->IsDate() ) return;

	pChar->StartLimitTimer( m_pMyRoom->GetCharLimitCheckTime() );

	// 용병 기간 체크 시작
	SP2Packet kPacket( STPK_START_CHAR_LIMITDATE );

	PACKET_GUARD_VOID( kPacket.Write(1) );
	PACKET_GUARD_VOID( kPacket.Write(pChar->GetCharIndex()) );
	PACKET_GUARD_VOID( kPacket.Write(pChar->IsActive()) ); 
	PACKET_GUARD_VOID( kPacket.Write(pChar->GetCharLimitDate()) ); 
	PACKET_GUARD_VOID( kPacket.Write(pChar->GetLimitCheckSecond()) );

	SendMessage( kPacket );
}

bool User::UpdateCharLimitDate()
{
	int i = 0;
	int iUpdateCount = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		ioCharacter *rkChar = m_CharList[i];
		if( rkChar->HasExerciseStyle( EXERCISE_PCROOM ) )
		{
			if( !g_ItemPriceMgr.IsActivePcRoomHero(rkChar->GetClassType()) )
			{
				DeleteExpiredPcRoomChar(rkChar->GetClassType());
			}

			continue;
		}

		if( !rkChar->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		if( !rkChar->IsActive() ) continue;      //이미 기간이 만료된 용병
		if( rkChar->IsMortmain() ) continue;
		
		if( rkChar->IsDate() )
		{
			if(rkChar->CheckPassedDate())
				iUpdateCount++;
		}
		else
		{
		if( rkChar->UpdateLimitTimer() )
			iUpdateCount++;
	}
	}
	if( iUpdateCount == 0 )
		return false;

	// 업데이트된 용병 기간 정보 전송
	SP2Packet kPacket( STPK_UPDATE_CHAR_LIMITDATE );

	PACKET_GUARD_bool( kPacket.Write(GetCharCount()) );

	for(i = 0;i < GetCharCount();i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		PACKET_GUARD_bool( kPacket.Write(rkChar->GetCharIndex()) );
		PACKET_GUARD_bool( kPacket.Write(rkChar->IsActive()) );
		PACKET_GUARD_bool( kPacket.Write(rkChar->GetCharLimitDate()) );
	}
	SendMessage( kPacket ); //kyg return SendMessage로 바꾸는 방안 
	return true;
}

bool User::IsCharIndex( DWORD dwCharIndex )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
			return true;
	}
	return false;
}

bool User::IsClassType( int iClassType )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
			return true;
	}
	return false;
}

bool User::IsClassTypeExceptExercise( int iClassType )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		if( !rkChar->HasExerciseStyle( EXERCISE_NONE ) )
			continue;
		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
			return true;
	}
	return false;
}

bool User::IsClassTypeExerciseStyle( int iClassType, int chExercise )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
		{
			return rkChar->HasExerciseStyle( chExercise );
		}
	}
	return false;
}

bool User::IsBuyActiveChar( int iClassType )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		if( !rkChar->HasExerciseStyle( EXERCISE_NONE ) ) continue; 

		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
			return rkChar->IsActive();
	}
	return false;
}

bool User::IsActiveChar( int iClassType )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		if( rkChar->HasExerciseStyle( EXERCISE_GENERAL ) ) continue; 
		
		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
		{
			// PC방 용병은 Active
			if( rkChar->HasExerciseStyle( EXERCISE_PCROOM ) ) 
				return true;   
			else if( rkChar->HasExerciseStyle( EXERCISE_EVENT ) ) //이벤트 용병은 Active
				return true;
			else if( rkChar->HasExerciseStyle( EXERCISE_RENTAL ) )
				return true;
			return rkChar->IsActive();
		}
	}
	return false;
}

int User::GetCharArrayByClass( int iClassType )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
			return i;
	}
	return -1;
}

int User::GetExerciseCharArrayByClass( int iClassType )
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		if( rkChar->HasExerciseStyle( EXERCISE_NONE ) )
			continue;
		const CHARACTER &rkInfo = rkChar->GetCharInfo();
		if( rkInfo.m_class_type == iClassType )
			return i;
	}
	return -1;
}

int User::GetActiveCharCount()
{
	int iActiveCharCount = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( !m_CharList[i]->IsActive() ) continue;

		iActiveCharCount++;
	}
	return iActiveCharCount;
}

int User::GetBuyCharCount()
{
	int iBuyCharCount = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) )
			continue;
		iBuyCharCount++;
	}
	return iBuyCharCount;
}

int User::GetActiveBuyCharCount()
{
	int iActiveBuyCharCount = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		if( !m_CharList[i]->IsActive() ) continue;

		iActiveBuyCharCount++;
	}
	return iActiveBuyCharCount;
}

int User::GetExerciseCharCount()
{
	int iExerciseCharCount = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) )
			continue;
		iExerciseCharCount++;
	}
	return iExerciseCharCount;
}

int User::GetExerciseCharCount( int chExercise )
{
	int iExerciseCharCount = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( m_CharList[i]->HasExerciseStyle( chExercise ) )
			iExerciseCharCount++;
	}
	return iExerciseCharCount;
}

int User::GetActiveRentalCount()
{
	int iRentalCount = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( m_CharList[i]->HasExerciseStyle( EXERCISE_RENTAL ) == false ) continue;
		if( m_CharList[i]->GetRentalLimitTime() == 0 ) continue;

		iRentalCount++;
	}
	return iRentalCount;
}

void User::FillExerciseIndex( SP2Packet &rkPacket )
{
	rkPacket << GetExerciseCharCount();

	for( int i=0; i < GetCharCount(); i++ )
	{
		if( m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) )
			continue;

		rkPacket << m_CharList[i]->GetCharIndex();
	}
}

ioInventory* User::GetInventory()
{
	return &m_Inventory;
}

ioUserEtcItem* User::GetUserEtcItem()
{
	return &m_UserEtcItem;
}

ioClassExpert* User::GetClassExpert()
{
	return &m_ClassExpert;
}

ioAward* User::GetAward()
{
	return &m_Award;
}

ioQuest* User::GetQuest()
{
	return &m_Quest;
}

ioUserRecord* User::GetUserRecord()
{
	return &m_UserRecord;
}

ioUserGrowthLevel* User::GetUserGrowthLevel()
{
	return &m_UserGrowthLevel;
}

ioUserFishingItem* User::GetUserFishingItem()
{
	return &m_UserFishingItem;
}

ioUserExtraItem* User::GetUserExtraItem()
{
	return &m_UserExtraItem;
}

ioUserMedalItem* User::GetUserMedalItem()
{
	return &m_UserMedalItem;
}

ioUserExpandMedalSlot* User::GetUserExpandMedalSlot()
{
	return &m_UserExpandMedalSlot;
}

ioAlchemicInventory* User::GetAlchemicInventory()
{
	return &m_AlchemicInventory;
}

ioCharRentalData* User::GetCharRentalData()
{
	return &m_CharRentalData;
}

ioUserTournament* User::GetUserTournament()
{
	return &m_UserTournament;
}

ioUserGuild* User::GetUserGuild()
{
	return &m_UserGuild;
}

ioUserPresent* User::GetUserPresent()
{
	return &m_UserPresent;
}

ioUserSubscription* User::GetUserSubscription()
{
	return &m_UserSubscription;
}

ioFriend* User::GetFriend()
{
	return &m_Friend;
}

ioClover* User::GetClover()
{
	return &m_Clover;
}

ioBingo* User::GetBingo()
{
	return &m_Bingo;
}

ioPirateRoulette* User::GetPirateRoulette()
{
	return &m_PirateRoulette;
}

ioUserAttendance* User::GetUserAttendance()
{
	return &m_UserAttendance;
}

ioUserPet* User::GetUserPetItem()
{
	return &m_UserPetItem;
}

void User::AddAward( int iCategory, int iPoint )
{
	m_Award.AddAward( iCategory, iPoint );
	m_Award.AddAwardExp( iPoint );
}

bool User::IsPCRoomAuthority()
{

	// jal : 프리데이 이벤트 시 피씨방과 동일한 혜택을 줌..
	if( m_dwPCRoomNumber == FREEDAY_EVENT_CODE )
		return true;
	
	if( /*m_dwPCRoomNumber == FREEDAY_EVENT_CODE ||*/ m_dwPCRoomNumber == 0)
		return false;

	return true;
}

DWORD User::GetPCRoomNumber() const
{
	return m_dwPCRoomNumber;
}


ModeType User::GetModeType()
{
	if( m_pMyRoom == NULL ) return MT_NONE;

	return m_pMyRoom->GetModeType();
}

bool User::IsGuild()
{
	if( m_UserGuild.GetGuildIndex() == 0 )
		return false;
	return true;
}

DWORD User::GetGuildIndex()
{
	if( IsGuild() )
		return m_UserGuild.GetGuildIndex();
	return 0;
}

DWORD User::GetGuildMark()
{
	if( IsGuild() )
		return m_UserGuild.GetGuildMark();
	return 0;
}

bool User::IsBestFriend( DWORD dwUserIndex )
{
	vBestFriend_iter iter, iEnd;
	iEnd = m_Friend.BestFriendEnd();
	for(iter = m_Friend.BestFriendIter( 0 );iter != iEnd;iter++)
	{
		BestFriend &kBestFriend = *iter;
		if( kBestFriend.m_dwState == BFT_SET )
		{
			if( kBestFriend.m_dwUserIndex == dwUserIndex )
				return true;
		}
	}
	return false;
}

void User::GetBestFriend( DWORDVec &rkUserIndexList )
{
	rkUserIndexList.clear();

	vBestFriend_iter iter, iEnd;
	iEnd = m_Friend.BestFriendEnd();
	for(iter = m_Friend.BestFriendIter( 0 );iter != iEnd;iter++)
	{
		BestFriend &kBestFriend = *iter;
		if( kBestFriend.m_dwState == BFT_SET )
		{
			rkUserIndexList.push_back( kBestFriend.m_dwUserIndex );
		}
	}
}

BattleRoomParent *User::GetMyBattleRoom()
{
	if( m_dwMyBattleRoom == 0 ) return NULL;

	return g_BattleRoomManager.GetGlobalBattleRoomNode( m_dwMyBattleRoom );
}

LadderTeamParent *User::GetMyLadderTeam()
{
	if( m_dwMyLadderTeam == 0 ) return NULL;

	return g_LadderTeamManager.GetGlobalLadderTeamNode( m_dwMyLadderTeam );
}

ShuffleRoomParent *User::GetMyShuffleRoom()
{
	if( m_dwMyShuffleRoom == 0 ) return NULL;

	return g_ShuffleRoomManager.GetGlobalShuffleRoomNode( m_dwMyShuffleRoom );
}

bool User::IsGeneralGrade()
{
	if( COMPARE( GetGradeLevel(), 50, 55 ) )
		return true;

	return false;
}

int User::GetGradeLevel()
{
	return m_user_data.m_grade_level;
}

int User::GetGradeExpert()
{
	return m_user_data.m_grade_exp;
}

int User::GetGradeExpRate()
{
	if( IsGeneralGrade() ) 
		return m_user_data.m_grade_exp;  // 장성급 유저는 경험치를 그대로 return 한다.

	int iNeedExp = g_LevelMgr.GetNextGradeupExp( GetGradeLevel() );
	if( iNeedExp > 0 )
	{
		float fRate = (float)GetGradeExpert() / (float)iNeedExp;
		return min( 99, (int)( fRate * 100.0f ) );
	}
	return 0;
}

int User::GetBackupGradeExp()
{
	return m_user_relative_grade_data.m_iBackupExp;
}

int User::GetClassLevel( int iSelectChar, bool bOriginal  )
{
	if( !COMPARE( iSelectChar, 0, GetCharCount() ) )
		return 0;

	const CHARACTER &charInfo = m_CharList[iSelectChar]->GetCharInfo();
	if( !bOriginal )
	{
		if( charInfo.m_chExerciseStyle == EXERCISE_RENTAL && m_CharList[iSelectChar]->GetRentalLimitTime() != 0 )
		{
			return m_CharRentalData.GetClassLevel( m_CharList[iSelectChar]->GetCharIndex() );
		}
	}
	return m_ClassExpert.GetClassLevel( charInfo.m_class_type );
}

int User::GetClassLevelByType( int iClassType, bool bOriginal )
{
	if( !bOriginal )
	{
		for(int i = 0;i < GetCharCount();i++)
		{
			ioCharacter *pCharacter = m_CharList[i];
			if( pCharacter == NULL ) continue;
			if( pCharacter->GetCharInfo().m_class_type != iClassType ) continue;
            if( pCharacter->HasExerciseStyle( EXERCISE_RENTAL ) == false ) continue;
			if( pCharacter->GetRentalLimitTime() == 0 ) continue;

			return m_CharRentalData.GetClassLevel( pCharacter->GetCharIndex() );
		}
	}
	return m_ClassExpert.GetClassLevel( iClassType );
}

int User::GetKillDeathLevel()
{
	int iCalculationLevel = GetGradeLevel() + g_LevelMatchMgr.GetAddGradeLevel();

	int iTotalKill = m_UserRecord.GetTotalKill();
	if( iTotalKill > g_LevelMatchMgr.GetLeaveSafetyRoomKo() )          //10킬을 못한유저는 킬뎃레벨 적용 안함.
	{
		int iMatchLevel = (float)iCalculationLevel * m_UserRecord.GetKillDeathPer();
		if( iCalculationLevel >= g_LevelMatchMgr.GetRoomEnterSafetyLevel() )
		{
			iMatchLevel = max( g_LevelMatchMgr.GetRoomEnterSafetyLevel(), iMatchLevel );
		}
		iCalculationLevel = iMatchLevel;
	}

	int iMinKillDeathLevel	= max( 0, GetGradeLevel() + g_LevelMatchMgr.GetAddGradeLevel() - g_LevelMatchMgr.GetKillDeathMinLevelGap() );
	return max( min( iCalculationLevel, g_LevelMatchMgr.GetRoomEnterLevelMax() ), iMinKillDeathLevel );
}

bool User::IsLeaveSafeRoom()
{
	if( IsDeveloper() || IsObserver() || IsStealth() )
		return false;

	if( GetGradeLevel() + g_LevelMatchMgr.GetAddGradeLevel() >= g_LevelMatchMgr.GetLeaveSafetyRoomLevel() )
		return true;

	int iTotalKill = m_UserRecord.GetTotalKill();
	if( iTotalKill > g_LevelMatchMgr.GetLeaveSafetyRoomKo() && GetKillDeathLevel() >= g_LevelMatchMgr.GetLeaveSafetyRoomLevel() )
	{
		return true;
	}

	return false;
}

bool User::IsSafetyLevel()
{
	if( IsDeveloper() )
		return true;

	if( GetGradeLevel() + g_LevelMatchMgr.GetAddGradeLevel() >= g_LevelMatchMgr.GetLeaveSafetyRoomLevel() )
		return false;

	int iTotalKill = m_UserRecord.GetTotalKill();
	if( iTotalKill > g_LevelMatchMgr.GetLeaveSafetyRoomKo() && GetKillDeathLevel() >= g_LevelMatchMgr.GetLeaveSafetyRoomLevel() )
	{
		return false;
	}

	return true;
}

bool User::IsObserver()
{
	if( m_dwMyBattleRoom == 0 ) return false;
	if( !m_pMyRoom ) return false;
	if( m_pMyRoom->GetRoomStyle() != RSTYLE_BATTLEROOM ) return false;

	// 아래 함수는 현재 서버에 있는 오리지날 전투방 리스트만 검색한다.
	BattleRoomNode* pBattleRoom = (BattleRoomNode*)g_BattleRoomManager.GetBattleRoomNode( m_dwMyBattleRoom );
	if( !pBattleRoom ) return false;

	return pBattleRoom->IsObserver( GetPublicID() );
}

void User::SetMoney( __int64 i64Money )
{
	__int64 iPrev = m_user_data.m_money;

	m_user_data.m_money = i64Money;
	g_CriticalError.CheckPesoPossessionCount( GetPublicID(), m_user_data.m_money );

	if((i64Money < 0) || (i64Money > 100000000) ) //1억 (3위)(38,507,288 페소)
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][user]SetMoney cheat - userName:%s Prev:%I64d, After:%I64d, Set:%I64d", GetPublicID().c_str(), iPrev, m_user_data.m_money, i64Money);

		m_user_data.m_money = 0;
		CloseConnection();
	}
}

void User::AddMoney( __int64 i64Money )
{
	__int64 iPrev = m_user_data.m_money;

	m_user_data.m_money += i64Money;
	g_CriticalError.CheckPesoAcquiredCount( GetPublicID(), (int)i64Money );
	g_CriticalError.CheckPesoPossessionCount( GetPublicID(), m_user_data.m_money );

	if( i64Money > 0 )
	{
		static DWORDVec vValue;
		vValue.clear();
		vValue.push_back(2);
		vValue.push_back(i64Money);
		g_MissionMgr.DoTrigger(MISSION_CLASS_PESO_COLLECT, this, vValue);
		m_TitleInven.CheckTitleValue(TITLE_HAVE_PESO, m_user_data.m_money);
	}
	
	if((i64Money < 0) || (i64Money > 10000000) ) // 1천만 (3위)(38,507,288 페소)
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][user]AddMoney cheat - userName:%s, Prev:%I64d, After:%I64d, Add:%I64d", GetPublicID().c_str(), iPrev, m_user_data.m_money, i64Money);
		m_user_data.m_money = 0;
		CloseConnection();
	}
}

void User::RemoveMoney( __int64 i64Money )
{
	if( i64Money < 0 )
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][user]RemoveMoney cheat - userName:%s, Prev:%I64d, Remove:%I64d", GetPublicID().c_str(), m_user_data.m_money, i64Money);

		m_user_data.m_money = 0;
		CloseConnection();
		return;
	}

	static DWORDVec vValues;
	vValues.clear();
	vValues.push_back(1);
	__int64 iTemp	= 0;

	if(m_user_data.m_money > i64Money)
	{
		m_user_data.m_money = m_user_data.m_money - i64Money;
		vValues.push_back(i64Money);
		iTemp	= i64Money;
	}
	else
	{
		vValues.push_back(m_user_data.m_money);
		m_user_data.m_money = 0;
		iTemp	= 0;
	}

	g_MissionMgr.DoTrigger(MISSION_CLASS_PESO_COLLECT, this, vValues);
	m_TitleInven.CheckTitleValue(TITLE_CONSUME_ACCUMULATE_PESO, iTemp);
}

__int64 User::DecreasePenaltyPeso( __int64 i64Money )
{
	if( i64Money < 0 )
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][user]Penalty cheat - userName:%s, Prev:%I64d, Penalty:%I64d", GetPublicID().c_str(), m_user_data.m_money, i64Money);
		CloseConnection();
		return 0;
	}

	if(m_user_data.m_money > i64Money)
	{
		m_user_data.m_money = m_user_data.m_money - i64Money;
	}
	else
	{
		m_user_data.m_money = 0;
	}
	return i64Money;
}

void User::SetCash( int iCash )
{
	m_user_data.m_cash = iCash;
}

void User::AddCash( int iCash )
{
	m_user_data.m_cash += iCash;
}

void User::SetPurchasedCash( int iPurchasedCash )
{
	m_user_data.m_purchased_cash = iPurchasedCash;
}

void User::AddPurchasedCash( int iPurchasedCash )
{
	m_user_data.m_purchased_cash += iPurchasedCash;
}

bool User::AddGradeExp( int iExp )
{
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal ) 
	{
		int iLimitLevel = pLocal->GetLimitGradeLevel();
		if( iLimitLevel != -1 && iLimitLevel <= GetGradeLevel() )
		{
			return false;
		}
	}

	int iNextExp = g_LevelMgr.GetNextGradeupExp( GetGradeLevel() );
	m_user_data.m_grade_exp += iExp;	
	if( iNextExp <= m_user_data.m_grade_exp )
	{
		if( GetGradeLevel() < g_LevelMgr.GetMaxGradeUp() )
		{
			m_user_data.m_grade_level++;

			/* 용병단 레벨업 보상 제거.
			LevelUPData kLevelUP;
			kLevelUP.m_iType  = 0;
			kLevelUP.m_iLevel = m_user_data.m_grade_level;
			m_vLevelUpClass.insert( m_vLevelUpClass.begin(), kLevelUP );         //0은 용병단 레벨업.
			*/
			int iRemainExp = m_user_data.m_grade_exp - iNextExp;
			m_user_data.m_grade_exp = 0;
			if( iRemainExp > 0 )
				AddGradeExp( iRemainExp );

			if( IsGeneralGrade() )
			{
				SaveUserData();

				g_DBClient.OnInsertRelativeGradeTable( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex() );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Insert general user table %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
			}

			return true;
		}
	}
	return false;
}

void User::AddClassExp( int iClassType, int iExp )
{	
	int iRemainExp = 0;
	if( m_ClassExpert.AddClassExp( iClassType, iExp, iRemainExp ) )
	{
		LevelUPData kLevelUP;
		kLevelUP.m_iType  = iClassType;
		kLevelUP.m_iLevel = m_ClassExpert.GetClassLevel( iClassType );
		m_vLevelUpClass.push_back( kLevelUP );      //레벨업 용병

		m_UserExpandMedalSlot.DeleteExMedalSlotGradeUp( kLevelUP.m_iType, kLevelUP.m_iLevel );
	}

	if( iRemainExp > 0 )     // 경험치가 남아있으면 계속 Add한다.
		AddClassExp( iClassType, iRemainExp );
}

void User::GetEquipMedalClassTypeArray( int iClassType, IntVec &kMedal )
{
	for(int i = 0;i < GetCharCount();i++)
	{
		ioCharacter *pCharacter = m_CharList[i];
		if( pCharacter == NULL ) continue;
		if( pCharacter->GetCharInfo().m_class_type != iClassType ) continue;

		if( pCharacter->HasExerciseStyle( EXERCISE_RENTAL ) )
		{
			m_CharRentalData.GetEquipMedal( pCharacter->GetCharIndex(), kMedal );	
			return;
		}
	}

	m_UserMedalItem.GetMedalItemTypeVec( kMedal, iClassType );
}

bool User::GetDisplayCharacter( DWORD dwCharIndex, float &rkXPos, float &rkZPos )
{
	for(int i = 0;i < MAX_DISPLAY_CNT;i++)
	{
		if( m_UserHeadquartersData.m_dwCharacterIndex[i] == dwCharIndex )
		{
			rkXPos = (float)m_UserHeadquartersData.m_iCharacterXPos[i];
			rkZPos = (float)m_UserHeadquartersData.m_iCharacterZPos[i];
			return true;
		}
	}
	return false;
}

DWORD User::GetDisplayCharMotion( DWORD dwCharIndex )
{
	for(int i = 0;i < GetCharCount();i++)
	{
		ioCharacter *pCharacter = m_CharList[i];
		if( pCharacter == NULL ) continue;
		if( pCharacter->GetCharIndex() != dwCharIndex ) continue;

		int iEtcMotionType  = ioEtcItemMotion::MOTION_OPTION_100 + pCharacter->GetCharInfo().m_class_type;
		int iCurrentEtcSlot = m_UserEtcItem.GetEtcItemCurrentSlot();
		for(int i = 0;i < iCurrentEtcSlot;i++)
		{
			ioUserEtcItem::ETCITEMSLOT kSlot;
			if( m_UserEtcItem.GetEtcItemByArray( i, kSlot ) )
			{
				if( COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION1, ioEtcItem::EIT_ETC_MOTION100 + 1 ) ||
					COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION101, ioEtcItem::EIT_ETC_MOTION400 + 1 ) )
				{
					if( kSlot.m_iValue1 == iEtcMotionType )
					{
						return kSlot.m_iType;
					}
				}
			}
		}
	}
	return 0;
}

bool User::IsHeadquartersLock()
{
	if( m_UserHeadquartersData.m_sLock == 0 )
		return false;
	return true;
}

int User::FillGradeNClassLevelUPBonus( SP2Packet &rkPacket, int iUpClassType, int iUpLevel )
{
	// 특정용병단 레벨업시 특별아이템 지급
	if( iUpClassType == 0 ) // GradeUp
	{
		ioEtcItemBuyMortmainChar *pEtcItem = static_cast<ioEtcItemBuyMortmainChar*> ( g_EtcItemMgr.FindEtcItem( ioEtcItem::EIT_ETC_BUY_MORTMAIN_CHAR ) );
		if( pEtcItem )
		{
			if( pEtcItem->AddEtcItem( this, GetUserEtcItem() ) )
			{
				rkPacket << GRADE_UP_BONUS_ETCITEM;	
				return 0; //////////
			}
		}
		else
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pEtcItem == NULL. %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
	}

	// 이벤트
	if( iUpClassType == 0 ) // GradeUp
	{
		GradeUpEventUserNode *pEventNode = static_cast< GradeUpEventUserNode* > ( m_EventUserMgr.GetEventUserNode( EVT_GRADEUP ) );
		if( pEventNode )
			pEventNode->SetGift( this, iUpLevel );

		GradePresentEventUserNode *pGradePresentEventUserNode = static_cast< GradePresentEventUserNode* > ( m_EventUserMgr.GetEventUserNode( EVT_GRADEUP_PRESENT ) );
		if( pGradePresentEventUserNode )
			pGradePresentEventUserNode->SetGift( this, iUpLevel );
	}
	
	// 용병 슬롯이 없거나 용병 레벨업일 경우 페소로 보상 지급
	if( ( m_vLevelUpAndPresentCreateClass.size() + GetCharCount() ) == m_iCurMaxCharSlot || iUpClassType != 0 )
	{
		//페소 지급
		int iAddPeso = 0;
		__int64 iPrevMoney = GetMoney();
		if( iUpClassType == 0 )
		{
			iAddPeso = Help::GetGradeUPBonus();
			AddMoney( iAddPeso );
			g_LogDBClient.OnInsertPeso( this, iAddPeso, LogDBClient::PT_LEVELUP );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_LEVELUP, PRESENT_GRADE_EXP, iUpClassType, iAddPeso, NULL);

			//레벨업 보너스 패킷 전송
			rkPacket << GRADE_UP_BONUS_PESO << GetGradeLevel() << iAddPeso;		
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillGradeNClassLevelUPBonus( %s, %d ) Peso Bonus %d - MyPeso %I64d - > %I64d", GetPublicID().c_str(), iUpClassType, iAddPeso, iPrevMoney, GetMoney() );
		}		
		else
		{
			iAddPeso = Help::GetLevelUPBonus() * iUpLevel;
			AddMoney( iAddPeso );
			g_LogDBClient.OnInsertPeso( this, iAddPeso, LogDBClient::PT_LEVELUP );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_LEVELUP, PRESENT_GRADE_EXP, iUpClassType, iAddPeso, NULL);

			rkPacket << CLASS_UP_BONUS_PESO << iUpClassType << iAddPeso;
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillGradeNClassLevelUPBonus( %s, %d:%d ) Peso Bonus %d - MyPeso %I64d - > %I64d", GetPublicID().c_str(), iUpClassType, iUpLevel, iAddPeso, iPrevMoney, GetMoney() );
		}
		return iAddPeso; ///////////////////////
	}

	int i = 0;
	DWORDVec vClassList;
	for(i = 0;i < g_ItemPriceMgr.GetMaxClassInfo();i++)
	{
		if( !g_ItemPriceMgr.GetArrayClassActive( i ) ) continue;
		vClassList.push_back( g_ItemPriceMgr.GetArrayClassCode( i ) );
	}

	// 보유하지 않은 용병 지급
	LOOP_GUARD();
	vCharList::iterator iter = m_CharList.begin();
	while( iter != m_CharList.end() )
	{
		ioCharacter *pChar = *iter++;
		if( !pChar ) continue;

		for(i = 0;i < (int)vClassList.size();i++)
		{
			if( pChar->GetCharInfo().m_class_type == vClassList[i] )
			{
				vClassList.erase( vClassList.begin() + i );
				break;
			}
		}
	}
	LOOP_GUARD_CLEAR();

	// 레벨업 보상으로 받은 용병도 제외한다
	for(i = 0;i < (int)m_vLevelUpAndPresentCreateClass.size();i++)
	{
		for(int j = 0;j < (int)vClassList.size();j++)
		{
			if( m_vLevelUpAndPresentCreateClass[i] == vClassList[j] )
			{
				vClassList.erase( vClassList.begin() + j );
				break;
			}
		}
	}

	// 레벨업한 Grade로 새롭게 구매가능한 용병을 추출한다.
	LOOP_GUARD();
	DWORDVec vNewCharList;
	DWORDVec::iterator iter2 = vClassList.begin();
	while( iter2 != vClassList.end() )
	{
		DWORD &rdwClassType = *iter2;
		DWORD dwSetItemCode = rdwClassType + SET_ITEM_CODE;
		const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
		if( IsCanBuyItemBySameGradeLevel( pSetInfo ) )
		{	
			vNewCharList.push_back(*iter2);
		}
		++iter2;
	}
	LOOP_GUARD_CLEAR();

	// 새로운 캐릭터가 없으면 기존리스트에서 구매할 조건이 안되는 용병도 제외한다.
	if( vNewCharList.empty() )
	{
		LOOP_GUARD();
		iter2 = vClassList.begin();
		while( iter2 != vClassList.end() )
		{
			DWORD &rdwClassType = *iter2;
			DWORD dwSetItemCode = rdwClassType + SET_ITEM_CODE;
			const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
			if( IsCanBuyItem(pSetInfo) )
			{		
				++iter2;
			}
			else
			{
				iter2 = vClassList.erase( iter2 );	
			}
		}
		LOOP_GUARD_CLEAR();
	}
	else // 기존 리스트 교체
	{
		vClassList.clear();
		vClassList.insert( vClassList.begin(), vNewCharList.begin(), vNewCharList.end() );
		vNewCharList.clear();
	}

	// 구매할 용병이 없다면 페소 지급
	if( vClassList.empty() )
	{
		int iAddMoney = Help::GetGradeUPBonus();
		__int64 iPrevMoney = GetMoney();
		AddMoney( iAddMoney );
		g_LogDBClient.OnInsertPeso( this, iAddMoney, LogDBClient::PT_LEVELUP );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_LEVELUP, PRESENT_GRADE_EXP, iUpClassType, iAddMoney, NULL);

		//레벨업 보너스 패킷 전송
		rkPacket << GRADE_UP_BONUS_PESO << GetGradeLevel() << iAddMoney;		
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillGradeNClassLevelUPBonus(NoChar)( %s, %d ) Peso Bonus %d - MyPeso %I64d - > %I64d"
			                  , GetPublicID().c_str(), iUpClassType, iAddMoney, iPrevMoney, GetMoney() );
		return iAddMoney;//////////////////////////
	}

	CHARACTER kCharInfo;
	int r = rand()%vClassList.size();
	kCharInfo.m_class_type	= vClassList[r];
	kCharInfo.m_iLimitSecond= g_ItemPriceMgr.GetDefaultLimit();
	m_Inventory.GetEquipItemCode( kCharInfo );         // 치장이 있다면 입힌다.
	
	// 착용한 아이템이 없다면 Default 지급
	if( kCharInfo.m_face == -1)
		kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
	if( kCharInfo.m_hair == -1 )
		kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
	if( kCharInfo.m_skin_color == -1 )
		kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
	if( kCharInfo.m_hair_color == -1 )
		kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
	if( kCharInfo.m_underwear == -1 )
		kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	

	m_iCreateCharCount++;
	//캐릭터 생성.
	g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
	g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK_GRADE_UP_BONUS, 1, LogDBClient::CT_LEVELUP );
	m_vLevelUpAndPresentCreateClass.push_back( kCharInfo.m_class_type );

	if( iUpClassType == 0 )
	{
		//레벨업 보너스 패킷 전송
		rkPacket << GRADE_UP_BONUS_CLASS << GetGradeLevel() << kCharInfo.m_class_type << kCharInfo.m_iLimitSecond;
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillGradeNClassLevelUPBonus( %s, %d ) 용병 지급 : %d", GetPublicID().c_str(), iUpClassType, kCharInfo.m_class_type );
	}		
	else
	{
		//레벨업 보너스 패킷 전송
		rkPacket << CLASS_UP_BONUS_CLASS << iUpClassType << kCharInfo.m_class_type << kCharInfo.m_iLimitSecond;
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillGradeNClassLevelUPBonus( %s, %d ) 용병 지급 : %d", GetPublicID().c_str(), iUpClassType, kCharInfo.m_class_type );
	}
	vClassList.clear();
	return 0;
}

int User::GradeNClassUPBonus()
{
	if( m_vLevelUpClass.empty() ) return 0;

	int  iLevelUPResultPeso = 0;
	bool bGradeUPSaveUserData = false;
	bool bClassUPSaveUserData = false;
	int iLevelCount = m_vLevelUpClass.size();
	SP2Packet kPacket( STPK_GRADE_CLASS_UP_BONUS );
	kPacket << iLevelCount;
	for(int i = 0;i < iLevelCount;i++)
	{
		LevelUPData &kLevelData = m_vLevelUpClass[i];
		iLevelUPResultPeso += FillGradeNClassLevelUPBonus( kPacket, kLevelData.m_iType, kLevelData.m_iLevel );

		if( kLevelData.m_iType == 0 )
		{
			bGradeUPSaveUserData = true;
		}
		else
		{
			bClassUPSaveUserData = true;
		}
	}
	kPacket << GetMoney();
	SendMessage( kPacket );

	// 레벨업시 성장포인트 지급
	bool bUpPoint = false;
	SP2Packet kPacket2( STPK_GROWTH_POINT_BONUS );
	kPacket2 << iLevelCount;
	for( int j=0; j < iLevelCount; j++ )
	{
		LevelUPData &kLevelData = m_vLevelUpClass[j];

		if( kLevelData.m_iType != 0 )
		{
			int iGetPoint = g_GrowthMgr.GetLevelUpGrowthPoint();
			int iCurPoint = m_UserGrowthLevel.GetCharGrowthPoint( kLevelData.m_iType );

			iCurPoint += iGetPoint;
			m_UserGrowthLevel.SetCharGrowthPoint( kLevelData.m_iType, iCurPoint );

			kPacket2 << kLevelData.m_iType;
			kPacket2 << iCurPoint;

			bUpPoint = true;
		}
		else
		{
			kPacket2 << 0;
			kPacket2 << 0;
		}
	}
	SendMessage( kPacket2 );
	//

	m_vLevelUpClass.clear();

	if( bGradeUPSaveUserData )
		SaveUserData();
	if( bClassUPSaveUserData )
	{
		SaveClassExpert();
		SaveExpandMedalSlot();
	}

	// event
	if( bGradeUPSaveUserData )
	{
		CoinEventUserNode *pNode = static_cast< CoinEventUserNode* > ( m_EventUserMgr.GetEventUserNode( EVT_COIN ) );
		if( pNode )
			pNode->SetGradeUpCoin( this );
	}

	return iLevelUPResultPeso;
}

void User::FillToolTipInfo( SP2Packet &rkPacket )
{
	int iSelectClassType = GetSelectClassType();

	PACKET_GUARD_VOID( rkPacket.Write(GetPublicID()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetCountRSoldier()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetCountOfSpecialSoldier(SST_GFRIEND)) );
	PACKET_GUARD_VOID( rkPacket.Write(GetGradeLevel()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetGradeExpRate()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetPartyExp()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetLadderExp()) );
	PACKET_GUARD_VOID( rkPacket.Write(m_Award.GetAwardLevel()) );
	PACKET_GUARD_VOID( rkPacket.Write(m_Award.GetAwardExp()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetKillDeathLevel()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetFishingLevel()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetFishingExpert()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetExcavationLevel()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetExcavationExp()) );
	PACKET_GUARD_VOID( rkPacket.Write(( m_UserRecord.GetRecordWin( RECORD_HEROMATCH ) / 30 )) );
	PACKET_GUARD_VOID( rkPacket.Write(( m_UserRecord.GetRecordLose( RECORD_HEROMATCH ) / 10 )) );
	PACKET_GUARD_VOID( rkPacket.Write(GetHeroTitle()) );
	PACKET_GUARD_VOID( rkPacket.Write(m_UserHeroData.m_iHeroTodayRank) );
	PACKET_GUARD_VOID( rkPacket.Write((int) GetBlockType()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetUserRanking()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetUserCampPos()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetLadderPoint()) );
	PACKET_GUARD_VOID( rkPacket.Write(GetClassLevel( m_select_char, false )) );
	PACKET_GUARD_VOID( rkPacket.Write(iSelectClassType) );

	ioUserPet::PETSLOT rkNewSlot;
	m_UserPetItem.GetEquipPetInfo( rkNewSlot );
	PACKET_GUARD_VOID( rkPacket.Write( rkNewSlot.m_iPetCode ) );
	PACKET_GUARD_VOID( rkPacket.Write( rkNewSlot.m_iCurLevel ) );

	//장착 중인 칭호 정보 GET
	UserTitleInfo* pInfo = m_TitleInven.GetEquipTitle();
	if( pInfo )
	{
		PACKET_GUARD_VOID( rkPacket.Write(pInfo->GetCode()) );
		PACKET_GUARD_VOID( rkPacket.Write((BYTE)pInfo->IsPremium()) );
		PACKET_GUARD_VOID( rkPacket.Write(pInfo->GetTitleLevel()) );
	}
	else
	{
		PACKET_GUARD_VOID( rkPacket.Write(0) );
		PACKET_GUARD_VOID( rkPacket.Write((BYTE)0) );
		PACKET_GUARD_VOID( rkPacket.Write(0) );
	}


	int iArray = GetCharArrayByClass( iSelectClassType );
	if( iArray == -1 )
	{
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillToolTipInfo Get Char Array None ( %s, class Type %d )", GetPublicID().c_str(), iSelectClassType );
		BYTE chAwakeType = AWAKE_NONE;
		PACKET_GUARD_VOID( rkPacket.Write( chAwakeType  ) );
	}
	else
	{
		//캐릭 각성 정보
		BYTE chAwakeType = m_CharList[iArray]->GetAwakeType();
		PACKET_GUARD_VOID( rkPacket.Write( chAwakeType  ) );
	}

	//개인 본부 오픈 여부.
	bool bOpen	= m_UserEtcItem.HaveAThisItem(ioEtcItem::EIT_ETC_CREATE_HOME);
	PACKET_GUARD_VOID( rkPacket.Write(bOpen) );

	FillEquipMedalItemByClassType( iSelectClassType, rkPacket );
	FillTotalGrowthLevelDataByClassType(iSelectClassType, rkPacket);

	if( iArray != -1 )
	{
		ioCharacter* pCharInfo = m_CharList[iArray];
		if( pCharInfo )
		{
			CHARACTER stChar = pCharInfo->GetCharInfo();
			for( int i = 0; i < MAX_CHAR_COSTUME_SLOT; i++ )
			{
				PACKET_GUARD_VOID( rkPacket.Write(stChar.m_costume_item[i].m_iCostumeCode) );
				PACKET_GUARD_VOID( rkPacket.Write(stChar.m_costume_item[i].m_iMaleCustomCode) );	//코스튬 남성 스킨
				PACKET_GUARD_VOID( rkPacket.Write(stChar.m_costume_item[i].m_iFemalCustomCode) );   //코스튬 여성 스킨
			}

			for( int i = 0; i < MAX_CHAR_ACCESSORY_SLOT; i++ )
			{
				PACKET_GUARD_VOID( rkPacket.Write(stChar.m_accessory_item[i].m_iAccessoryCode) );
			}
		}
		else
		{
			for( int i = 0; i < MAX_CHAR_COSTUME_SLOT; i++ )
			{
				PACKET_GUARD_VOID( rkPacket.Write(0) );
				PACKET_GUARD_VOID( rkPacket.Write(0) );
				PACKET_GUARD_VOID( rkPacket.Write(0) );
			}

			for( int i = 0; i < MAX_CHAR_ACCESSORY_SLOT; i++ )
			{
				PACKET_GUARD_VOID( rkPacket.Write(0) );
			}
		}
	}
	else
	{
		for( int i = 0; i < MAX_CHAR_COSTUME_SLOT; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write(0) );
		}

		for( int i = 0; i < MAX_CHAR_ACCESSORY_SLOT; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write(0) );
		}
	}
}

void User::FillSimpleToolTipInfo( SP2Packet &rkPacket )
{
	int iSelectClassType = GetSelectClassType();
	//rkPacket << GetPublicID();
	//rkPacket << iSelectClassType;
	//rkPacket << GetClassLevel( m_select_char, false );
	PACKET_GUARD_VOID( rkPacket.Write( GetPublicID() ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetCountRSoldier() ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetCountOfSpecialSoldier(SST_GFRIEND) ) );
	PACKET_GUARD_VOID( rkPacket.Write( iSelectClassType ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetClassLevel( m_select_char, false ) ) );

	FillEquipMedalItemByClassType( iSelectClassType, rkPacket );

	FillTotalGrowthLevelDataByClassType(iSelectClassType, rkPacket);

	ioUserPet::PETSLOT rkNewSlot;
	m_UserPetItem.GetEquipPetInfo( rkNewSlot );
	PACKET_GUARD_VOID( rkPacket.Write( rkNewSlot.m_iPetCode ) );
	PACKET_GUARD_VOID( rkPacket.Write( rkNewSlot.m_iCurLevel ) );

	ioCharacter *pLeaderChar = GetCharacter( m_select_char );

	//캐릭터 각성 타입, 강화 단계
	if( pLeaderChar )
	{
		BYTE chAwakeType = pLeaderChar->GetAwakeType();
		BYTE byCharReinForce = pLeaderChar->GetCharReinforceGrade();

		PACKET_GUARD_VOID( rkPacket.Write( chAwakeType ) );
		PACKET_GUARD_VOID( rkPacket.Write( byCharReinForce ) );
		PACKET_GUARD_VOID( rkPacket.Write( IsRSoldier(pLeaderChar) ) );
		PACKET_GUARD_VOID( rkPacket.Write( IsSpecialSoldier(pLeaderChar, SST_GFRIEND) ) );
	}

	FillExMedalSlotByClassType( iSelectClassType, rkPacket );

	
	if( pLeaderChar )
	{
		pLeaderChar->FillDBExtraItemInfo( rkPacket, this, false );

		for( int i = 0; i < MAX_CHAR_COSTUME_SLOT; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write( pLeaderChar->GetCostumeCode(i) ) );
		}

		for( int i = 0; i < MAX_CHAR_ACCESSORY_SLOT; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write( pLeaderChar->GetAccessoryCode(i) ) );
			PACKET_GUARD_VOID( rkPacket.Write( pLeaderChar->GetAccessoryValue(i) ) );
		}
	}
}

void User::SetSelectCharDB( int iClassType )
{
	for(int i = 0;i < (int)m_vLevelUpAndPresentCreateClass.size();i++)
	{
		if( (int)m_vLevelUpAndPresentCreateClass[i] == iClassType )
		{
			m_vLevelUpAndPresentCreateClass.erase( m_vLevelUpAndPresentCreateClass.begin() + i );
			return;
		}
	}
}

int User::SetPresentChar( int iClassType, int iLimitTime )
{
	int iExtendCharArray = -1;
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		const CHARACTER &rkCharInfo = m_CharList[i]->GetCharInfo();
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		if( rkCharInfo.m_class_type == iClassType )
		{
			if( rkCharInfo.m_ePeriodType == CPT_MORTMAIN )       //영구 용병
				return PRESENT_RECV_ALREADY_CHAR;			
			iExtendCharArray = i;
			break;
		}
	}

	for(i = 0;i < (int)m_vLevelUpAndPresentCreateClass.size();i++)
	{
		if( (int)m_vLevelUpAndPresentCreateClass[i] == iClassType )
			return PRESENT_RECV_CHAR_CREATE_DELAY;
	}

	if( iLimitTime > 0 && iExtendCharArray != -1 )
	{
		ioCharacter *pExtendChar = m_CharList[iExtendCharArray];
		// 시간 증가
		// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->UpdateLimitTimer();
		}	
		// 플레이 연장
		if( pExtendChar->GetCharInfo().m_ePeriodType == CPT_DATE)
			pExtendChar->SetCharLimitExtendDate( iLimitTime );
		else
		pExtendChar->SetCharLimitExtend( iLimitTime );
		// 플레이중이면 연장한 시간부터 세팅한다. 
		pExtendChar->SetActive( true );
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->StartLimitTimer( m_pMyRoom->GetCharLimitCheckTime() );
		}		
		SaveCharacter();  //변경된 정보 저장
			
		SP2Packet kPacket( STPK_CHAR_EXTEND );
		kPacket << CHAR_EXTEND_OK << GetMoney() << GetCash() << GetChannelingCash() << iExtendCharArray << 0;
		kPacket << pExtendChar->IsActive() << pExtendChar->GetCharLimitDate() << pExtendChar->GetLimitCheckSecond();
		SendMessage( kPacket );		

		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", pExtendChar->GetCharIndex() );
		g_LogDBClient.OnInsertChar( this, iClassType, iLimitTime, 0, szItemIndex, LogDBClient::CT_PRESENT );

		return PRESENT_RECV_OK;
	}
	else if( iLimitTime == 0 && iExtendCharArray != -1 )
	{
		// 시간제 용병을 영구 용병으로 교체
		ioCharacter *pExtendChar = m_CharList[iExtendCharArray];

		const CHARACTER &rkCharInfo = pExtendChar->GetCharInfo();	
		// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->UpdateLimitTimer();
		}	
		
		int iResellLimitDate = pExtendChar->GetCharLimitDate();

		bool bResell = true;
		
		if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN)
		{
			CTime cCharTime = Help::ConvertNumberToCTime(iResellLimitDate);
			CTime kCurTime = CTime::GetCurrentTime();

			if(kCurTime < cCharTime)
			{
				CTimeSpan cRemainTime = cCharTime - kCurTime;
				iResellLimitDate = cRemainTime.GetTotalMinutes();
			}
			else
			{
				bResell = false;
				iResellLimitDate = 1;
			}
		}

		int iResellPeso      = g_ItemPriceMgr.GetTimeCharResellPeso( rkCharInfo.m_class_type, iResellLimitDate  );

		if(!bResell)
			iResellPeso = 0;

		if( iResellPeso > 0 )
		{
			AddMoney( iResellPeso );
			g_LogDBClient.OnInsertPeso( this, iResellPeso, LogDBClient::PT_DEL_CHAR );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_DEL_CHAR, PRESENT_SOLDIER, rkCharInfo.m_class_type, iResellPeso, NULL);
		}

		pExtendChar->SetPeriodType( CPT_MORTMAIN );
		pExtendChar->SetCharLimitDate( 0 );
		pExtendChar->SetActive( true );

		SaveCharacter();  //변경된 정보 저장
		SaveUserData();

		//판매 기록		
		SP2Packet kPacket( STPK_CHAR_CHANGE_PERIOD );
		kPacket << CHAR_CHANGE_PERIOD_OK << GetMoney() << GetCash() << GetChannelingCash() << iExtendCharArray << iResellPeso << 0 << true; // bCash
		SendMessage( kPacket );		

		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", pExtendChar->GetCharIndex() );
		g_LogDBClient.OnInsertChar( this, iClassType, iLimitTime, 0, szItemIndex, LogDBClient::CT_PRESENT );

		return PRESENT_RECV_OK;
	}
	else  // 현재 없는 용병이므로 슬롯에 여분이 있는지 확인
	{
		// 선택한 용병이 대여 용병이면 대여 용병을 삭제하고 용병 추가.
		if( IsClassTypeExerciseStyle( iClassType, EXERCISE_RENTAL ) == false ) 
		{
			if( ( (int)m_vLevelUpAndPresentCreateClass.size() + GetCharCount() ) >= m_iCurMaxCharSlot )
				return PRESENT_RECV_CHAR_SLOT_FULL;	
		}
	}
	
	// 상점 블럭.
	if( IsCharCreating() )
	{
		return PRESENT_RECV_CHAR_CREATE_DELAY; // 이미 용병 생성중이다 잠시 후 다시 시도해라
	}

	// 신규 용병 추가.
	CHARACTER kCharInfo;
	kCharInfo.m_class_type   = iClassType;
	kCharInfo.m_iLimitSecond = iLimitTime;
	if( kCharInfo.m_iLimitSecond == 0 )       //영구 용병
		kCharInfo.m_ePeriodType  = CPT_MORTMAIN;

	m_Inventory.GetEquipItemCode( kCharInfo );
	// 착용한 아이템이 없다면 Default 지급
	if( kCharInfo.m_face == -1)
		kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
	if( kCharInfo.m_hair == -1 )
		kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
	if( kCharInfo.m_skin_color == -1 )
		kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
	if( kCharInfo.m_hair_color == -1 )
		kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
	if( kCharInfo.m_underwear == -1 )
		kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	

	if( kCharInfo.m_ePeriodType == CPT_DATE )
		SetCharDateType(kCharInfo);

	m_iCreateCharCount++;
	//캐릭터 생성.
	g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
	g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK_PRESENT, 1, LogDBClient::CT_PRESENT );
	m_vLevelUpAndPresentCreateClass.push_back( iClassType );

	return PRESENT_RECV_OK;
}

int User::SetPresentEtcItem( int iEtcItemType, int iServerValue ) //item 번호, value2
{
	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem( iEtcItemType ); //pEtcItem 은 sp2_etcitem_info.ini 정보 여기의 value1, value2는 그 아이템의 판매 종류?
	if( !pEtcItem )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetPresentEtcItem Fail - NULL - %s : %d",  GetPublicID().c_str(), iEtcItemType );
		return PRESENT_RECV_NONE_ETCITEM;
	}

	if( !g_EtcItemMgr.IsRightClass( iEtcItemType ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetPresentEtcItem Error Class Type %s : %d",  GetPublicID().c_str(), iEtcItemType );
		return PRESENT_RECV_CLASS_ETCITEM;
	}
	
	if( !g_EtcItemMgr.IsBlockEtcItem( iEtcItemType ) && iServerValue <= 0 )	// block 아이템은 값이 0일때 영구
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetPresentEtcItem Value Wrong %s(%d) : %d",  GetPublicID().c_str(), GetUserIndex(), iServerValue );
		return PRESENT_RECV_ETCITEM_VALUE_EXCEPT;
	}

	// 선물함에서 바로 받기위해 예외 처리 마이, 유미라...
	ioEtcItemPreSetPackage *pPreSetPackage = static_cast<ioEtcItemPreSetPackage*>(g_EtcItemMgr.FindEtcItem(iEtcItemType));
	if( pPreSetPackage && COMPARE(iEtcItemType, ioEtcItem::EIT_ETC_PRESET_PACKAGE1, ioEtcItem::EIT_ETC_PRESET_PACKAGE100+1) )
	{
		if( pPreSetPackage->SetPreSetPackage( this ) )
			return PRESENT_RECV_OK;
		else
			return PRESENT_RECV_PRESET_FAIL;
	}
	//

	// max check
	ioUserEtcItem::ETCITEMSLOT kEtcItemSlot; //가지고 있는 etcItem
	bool bExist = m_UserEtcItem.GetEtcItem( iEtcItemType, kEtcItemSlot );

	bool bExistMortmain = false;
	if( bExist &&
		g_EtcItemMgr.IsBlockEtcItem( iEtcItemType ) &&
		kEtcItemSlot.m_iValue1 == 0 &&
		kEtcItemSlot.m_iValue2 == 0 )
	{
		bExistMortmain = true;
	}

	int iMaxCheckResult = _OnEtcItemMaxCheck( pEtcItem, kEtcItemSlot, iServerValue, bExistMortmain ); 
	if( iMaxCheckResult != ETCITEM_BUY_OK )
	{
		if( iMaxCheckResult == ETCITEM_BUY_EXCESS_MAX )
			return PRESENT_RECV_ETCITEM_EXCESS_MAX;
		else if( iMaxCheckResult == ETCITEM_BUY_EXCESS_OVER )
			return PRESENT_RECV_ETCITEM_EXCESS_OVER;
		else
			return PRESENT_RECV_EXCEPTION; 
	}	

	// 아래 구문이 수정되면 _OnBillingOutputCashEtc() 함수도 수정해야 함.

	bool bNewMortmain = false;
	if( g_EtcItemMgr.IsBlockEtcItem( iEtcItemType ) && iServerValue == 0 )
	{
		bNewMortmain = true;
	}
	
	DWORD dwCompensation = _OnEtcItemSetting( pEtcItem, kEtcItemSlot, iServerValue, bNewMortmain );

	// set my item
	DWORD dwEtcIndex     = 0;
	int   iArrayInIndex  = 0;

	if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_1000 + 1 ) )
	{
		if( !IsGuild() )
			return PRESENT_RECV_NO_GUILD;

		if( !m_UserGuild.IsActiveGuildRoom() )
			return PRESENT_RECV_GUILD_ROOM_DISABLE;

		DWORD dwBlockCode	= pEtcItem->GetProperty();
		
		if( !g_BlockPropertyMgr.IsValidItemCode(dwBlockCode) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][block]block item buy fail, Invalid block itemcode : [%d] [%d]", GetUserIndex(), dwBlockCode);	
			return PRESENT_RECV_EXCEPTION;
		}

		for( int i = 0; i < iServerValue; i++ )
			g_DBClient.OnAddGuildBlockItem(GetUserIndex(), GetGuildIndex(),  dwBlockCode, GBA_ITEM_PRESENT);
	}
	else if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_HOUSING_BLOCK_1000 + 1 ) )
	{
		// 개인 본부 오픈 etc 아이템 있는지 확인.
		if( !m_UserEtcItem.HaveAThisItem(ioEtcItem::EIT_ETC_CREATE_HOME) )
			return PRESENT_RECV_PERSONAL_HQ_DISABLE;

		DWORD dwBlockCode	= pEtcItem->GetProperty();
		
		if( !g_BlockPropertyMgr.IsValidItemCode(dwBlockCode) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][block]block item buy fail, Invalid personal block itemcode : [%d] [%d]", GetUserIndex(), dwBlockCode);	
			return PRESENT_RECV_EXCEPTION;
		}

		BOOL bEnd	= FALSE;
		for( int i = 0; i < iServerValue; i++ )
		{
			if( (iServerValue - 1 ) == i )
				bEnd	= TRUE;

			g_DBClient.OnAddPersonalHQBlockItem(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwBlockCode, iServerValue, bEnd);
		}
	}
	else if( !m_UserEtcItem.AddEtcItem( kEtcItemSlot, false, 0, dwEtcIndex, iArrayInIndex ) )	
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetPresentEtcItem Error AddEtcItem - %s(%d) %d:%d", GetPublicID().c_str(), GetUserIndex(), kEtcItemSlot.m_iType, iServerValue );
		return PRESENT_RECV_EXCEPTION;
	}

	if( dwEtcIndex != 0 )
	{
		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwEtcIndex, iArrayInIndex+1 ); // db field는 1부터 이므로 +1
		g_LogDBClient.OnInsertEtc( this, kEtcItemSlot.m_iType, iServerValue, 0, szItemIndex, LogDBClient::ET_PRESENT );
		StartEtcItemTime(  __FUNCTION__ , kEtcItemSlot.m_iType );
	}

	// compensation
	AddMoney( dwCompensation );
	g_LogDBClient.OnInsertPeso( this, dwCompensation, LogDBClient::PT_SELL_ETCITEM );
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_ETCITEM, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, dwCompensation, NULL);

	SP2Packet kPacket( STPK_ETCITEM_BUY );
	PACKET_GUARD_INT( kPacket.Write(ETCITEM_BUY_OK) );
	PACKET_GUARD_INT( kPacket.Write(kEtcItemSlot.m_iType) );
	PACKET_GUARD_INT( kPacket.Write(kEtcItemSlot.m_iValue1) );
	PACKET_GUARD_INT( kPacket.Write(kEtcItemSlot.m_iValue2) );
	PACKET_GUARD_INT( kPacket.Write(GetMoney()) );
	PACKET_GUARD_INT( kPacket.Write(GetCash()) );
	PACKET_GUARD_INT( kPacket.Write(GetChannelingCash()) );
	PACKET_GUARD_INT( kPacket.Write(0) );					// 보너스 페소
	PACKET_GUARD_INT( kPacket.Write(false) );				//구매 알림 팝업
	PACKET_GUARD_INT( kPacket.Write(dwCompensation) );
	PACKET_GUARD_INT( kPacket.Write((BYTE)EBRT_PRESENT) );
	SendMessage( kPacket );

	SaveEtcItem();

	if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_CHAR_SLOT_EXTEND )
	{
		CheckCurMaxCharSlot();
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_FISHING_SLOT_EXTEND )
	{				
		m_UserFishingItem.CheckCurMaxInventory();
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_EXTRAITEM_SLOT_EXTEND )
	{
		m_UserExtraItem.SetMaxPossessionCount();
	}

	return PRESENT_RECV_OK;
}

int User::SetPresentExtraItem( int iExtraItemCode, int iExtraItemReinforce, int iExtraItemLimitDate, int iExtraItemPeriodType, DWORD dwItemMaleCustom, DWORD dwItemFemaleCustom, int iMentType )
{
	enum { EXCEPTION_REAINFORCE = 100, };

	if( m_UserExtraItem.IsSlotFull() )
		return PRESENT_RECV_EXTRAITEM_NONE_SLOT;

	int iItemCode   = iExtraItemCode;
	int iPeriodTime = iExtraItemLimitDate;
	int iReinforce  = min( EXCEPTION_REAINFORCE, iExtraItemReinforce );
	if( iExtraItemReinforce > EXCEPTION_REAINFORCE )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s EXCEPTION ERROR : %s - %d - %d", __FUNCTION__, GetPublicID().c_str(), iItemCode, iExtraItemReinforce );
		// 예외처리
		return PRESENT_RECV_EXTRAITEM_NONE_SLOT;
	}

	ioUserExtraItem::EXTRAITEMSLOT kExtraItem;
	kExtraItem.m_iItemCode  = iItemCode;
	kExtraItem.m_iReinforce = iReinforce;
	kExtraItem.m_dwMaleCustom = dwItemMaleCustom;
	kExtraItem.m_dwFemaleCustom = dwItemFemaleCustom;
	kExtraItem.m_PeriodType = ioUserExtraItem::EPT_TIME;
	kExtraItem.m_iTradeState = ioUserExtraItem::EET_DISABLE;

	if( iPeriodTime >= 0 )
	{
		CTime kLimiteTime = CTime::GetCurrentTime();
		CTimeSpan kAddTime( 0, iPeriodTime, 0, 0 );
		kLimiteTime += kAddTime;

		kExtraItem.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );

		if( iPeriodTime == 0 ) // 무제한
		{
			kExtraItem.m_PeriodType = ioUserExtraItem::EPT_MORTMAIN;

			switch( iMentType )
			{
			case PRESENT_TRADE_CANCEL_MENT:
			case PRESENT_TRADE_TIMEOUT_MENT:
				kExtraItem.m_iTradeState = ioUserExtraItem::EET_ENABLE;
				break;
			}
		}
		else if( iExtraItemPeriodType != 0 )
		{
			// 성장 촉진제 사용 가능 아이템
			kExtraItem.m_PeriodType = ioUserExtraItem::EPT_GROW_TIME;
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s ExtraItem Grow Time Type : %s(%d - %d)",__FUNCTION__, GetPublicID().c_str(), iItemCode, iPeriodTime );
		}
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail ExtraItem1 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return PRESENT_RECV_EXTRAITEM_NONE_DATE;
	}

	DWORD dwIndex = 0;
	int iArrayIndex = 0;
	int iSlotIndex = m_UserExtraItem.AddExtraItem( kExtraItem, false, 0, LogDBClient::ERT_PRESENT, 0, iPeriodTime, dwIndex, iArrayIndex );
	if( iSlotIndex > 0 )
	{
		char szItemIndex[MAX_PATH]="";
		if( dwIndex != 0 )
		{
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayIndex+1 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertExtraItem( this, kExtraItem.m_iItemCode, kExtraItem.m_iReinforce, 0, iPeriodTime, 0, kExtraItem.m_PeriodType, kExtraItem.m_dwMaleCustom, kExtraItem.m_dwFemaleCustom, szItemIndex, LogDBClient::ERT_PRESENT );
		}
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Extraitem2 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		// 예외처리
		return PRESENT_RECV_EXTRAITEM_NONE_SLOT;
	}

	SP2Packet kReturn( STPK_EXTRAITEM_BUY );
	kReturn << EXTRAITEM_PRESENT;
	kReturn << kExtraItem.m_iItemCode;
	kReturn << kExtraItem.m_iReinforce;
	kReturn << iSlotIndex;
	kReturn << kExtraItem.m_iTradeState;
	kReturn << kExtraItem.m_PeriodType;
	kReturn << kExtraItem.m_iValue1;
	kReturn << kExtraItem.m_iValue2;
	kReturn << kExtraItem.m_dwMaleCustom;
	kReturn << kExtraItem.m_dwFemaleCustom;
	kReturn << iPeriodTime;
	kReturn << GetMoney();
	kReturn << GetCash();
	kReturn << GetChannelingCash();
	kReturn << 0;				// MachineCode
	kReturn << false;			// Alarm
	kReturn << 0;				// BonusPeso
	SendMessage( kReturn );

	SaveExtraItem();

	return PRESENT_RECV_OK;
}

int User::SetPresentExtraItemBox( int iExtraItemMachine, int iPesoArray, bool bCash )
{
	if( m_UserExtraItem.IsSlotFull() )
		return PRESENT_RECV_EXTRAITEM_NONE_SLOT;

	bool bPackage = g_ExtraItemInfoMgr.IsPackage( iExtraItemMachine );
	int iTradeTypeList = 0;
	int iItemCode = g_ExtraItemInfoMgr.GetRandomItemCode( iExtraItemMachine, iTradeTypeList );

	int iPeriodTime = -1;
	if( iPesoArray != -1 )
		iPeriodTime = g_ExtraItemInfoMgr.GetPeriod( iExtraItemMachine, iPesoArray );
	if( iPeriodTime == -1 )
		iPeriodTime = g_ExtraItemInfoMgr.GetRandomPeriodTime( iExtraItemMachine );
	
	bool bAlarm     = g_ExtraItemInfoMgr.IsAlarm( iExtraItemMachine, iPeriodTime );
	int iReinforce = g_ExtraItemInfoMgr.GetRandomReinforce( iExtraItemMachine, bCash );

	ioUserExtraItem::EXTRAITEMSLOT kExtraItem;
	kExtraItem.m_iItemCode = iItemCode;
	kExtraItem.m_iReinforce = iReinforce;
	kExtraItem.m_PeriodType = ioUserExtraItem::EPT_TIME;

	int iSlotIndex = 0;

	if( bPackage )
	{
		g_PresentHelper.SendExtraItemPackagePresent( this, iExtraItemMachine );
	}
	else // bPackage == false
	{
		if( iPeriodTime >= 0 )
		{
			CTime kLimiteTime = CTime::GetCurrentTime();
			CTimeSpan kAddTime( 0, iPeriodTime, 0, 0 );
			kLimiteTime += kAddTime;

			kExtraItem.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );

			if( iPeriodTime == 0 ) // 무제한
			{
				kExtraItem.m_PeriodType = ioUserExtraItem::EPT_MORTMAIN;

				int iTradeType = g_ExtraItemInfoMgr.GetRandomTradeType( iExtraItemMachine, iTradeTypeList );
				kExtraItem.m_iTradeState = iTradeType;
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail ExtraItem1 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
			return PRESENT_RECV_EXTRAITEM_NONE_DATE;
		}

		DWORD dwIndex = 0;
		int iArrayIndex = 0;
		iSlotIndex = m_UserExtraItem.AddExtraItem( kExtraItem, false, 0, LogDBClient::ERT_PRESENT, iExtraItemMachine, iPeriodTime, dwIndex, iArrayIndex );
		if( iSlotIndex > 0 )
		{
			char szItemIndex[MAX_PATH]="";
			if( dwIndex != 0 )
			{
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayIndex+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertExtraItem( this, kExtraItem.m_iItemCode, kExtraItem.m_iReinforce, iExtraItemMachine, iPeriodTime, 0, kExtraItem.m_PeriodType, kExtraItem.m_dwMaleCustom, kExtraItem.m_dwFemaleCustom, szItemIndex, LogDBClient::ERT_PRESENT );
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Extraitem2 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
			// 예외처리
			return PRESENT_RECV_EXTRAITEM_NONE_SLOT;
		}
	}// bPackage == false

	if( bPackage )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_PACKAGE_BUY_OK;
		kReturn << GetMoney();
		kReturn << GetCash();
		kReturn << GetChannelingCash();
		kReturn << iExtraItemMachine;				// MachineCode
		SendMessage( kReturn );
	}
	else
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_BOX_PRESENT;
		kReturn << kExtraItem.m_iItemCode;
		kReturn << kExtraItem.m_iReinforce;
		kReturn << iSlotIndex;
		kReturn << kExtraItem.m_iTradeState;
		kReturn << kExtraItem.m_PeriodType;
		kReturn << kExtraItem.m_iValue1;
		kReturn << kExtraItem.m_iValue2;
		kReturn << kExtraItem.m_dwMaleCustom;
		kReturn << kExtraItem.m_dwFemaleCustom;
		kReturn << iPeriodTime;
		kReturn << GetMoney();
		kReturn << GetCash();
		kReturn << GetChannelingCash();
		kReturn << iExtraItemMachine;			// MachineCode
		kReturn << bAlarm;
		kReturn << 0;							// BonusPeso
		SendMessage( kReturn );
	}
	SaveExtraItem();
	return PRESENT_RECV_OK;
}

int User::SetPresentMedalItem( int iMedalItemType, int iMedalItemLimitTime )
{
	ioUserMedalItem::MEDALITEMSLOT kMedalItem;
	kMedalItem.m_iItemType  = iMedalItemType;

	if( iMedalItemLimitTime >= 0 )
	{
		CTime kLimiteTime = CTime::GetCurrentTime();
		CTimeSpan kAddTime( 0, iMedalItemLimitTime, 0, 0 );
		kLimiteTime += kAddTime;
		kMedalItem.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );

		if( iMedalItemLimitTime == 0 )
		{
			kMedalItem.m_iPeriodType = ioUserMedalItem::PT_MORTMAIN;
		}
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Date : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return PRESENT_RECV_MEDALITEM_NONE_DATE;
	}

	DWORD dwIndex   = 0;
	int iArrayIndex = 0;
	if( m_UserMedalItem.AddMedalItem( kMedalItem, LogDBClient::MT_PRESENT, iMedalItemLimitTime, dwIndex, iArrayIndex ) )
	{
		char szItemIndex[MAX_PATH]="";
		if( dwIndex != 0 )
		{
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayIndex+1 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertMedalItem( this, kMedalItem.m_iItemType, kMedalItem.m_iPeriodType, szItemIndex, LogDBClient::MT_PRESENT );
		}
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Exist. : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		// 예외처리
		return PRESENT_RECV_MEDALITEM_EXIST;
	}

	SP2Packet kReturn( STPK_MEDALITEM_BUY );
	kReturn << MEDALITEM_BUY_PRESENT;
	kReturn << kMedalItem.m_iItemType;
	kReturn << kMedalItem.m_iEquipClass;
	kReturn << kMedalItem.m_iPeriodType;
	kReturn << kMedalItem.m_iLimitDate;
	kReturn << kMedalItem.m_iLimitTime;
	kReturn << GetMoney();
	kReturn << GetCash();
	kReturn << GetChannelingCash();
	SendMessage( kReturn );

	SaveMedalItem();

	return PRESENT_RECV_OK;
}

int User::SetPresentAlchemicItem( int iCode, int iCount )
{
	int iCurCount = m_AlchemicInventory.GetAlchemicItemCnt( iCode );
	if( iCurCount > 0 )		// 기존에 존재하던 것, 최대갯수 체크 필요
	{
		int iTotal = iCurCount + iCount;
		if( iTotal > ioAlchemicInventory::MAX_SLOT_CNT )	// 받으면 최대갯수 초과하므로 받기 실패
			return PRESENT_RECV_MAX_COUNT;
	}
	else					// 기존에 없던것, 빈칸 체크 필요
	{
		if( !m_AlchemicInventory.CheckEmptySlot() )			// 빈칸 없으므로 받기 실패
			return PRESENT_RECV_MAX_SLOT;
	}

	m_AlchemicInventory.GainAlchemicItem( iCode, iCount );

	// 변경정보 전달 필요
	SP2Packet kReturn( STPK_ALCHEMIC_SYNC );
	kReturn << ALCHEMIC_SYNC_GAIN;
	kReturn << iCode;
	kReturn << iCount;
	SendMessage( kReturn );
	
	return PRESENT_RECV_OK;
}

int User::SetPresentPetItem( int iPetCode, int iPetLevel, int iPetRank, DWORD dwIndex, DWORD dwSlotIndex  )
{
	ioPetInfoManager::PetInfo* pPetInfo = g_PetInfoMgr.GetPetInfo( iPetCode );

	if( !pPetInfo )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s EXCEPTION ERROR : %s - %d - %d - %d", __FUNCTION__, GetPublicID().c_str(), iPetCode, iPetRank, iPetLevel );
		return PRESENT_RECV_EXCEPTION;
	}

	if(g_PetInfoMgr.GetPetMaxLevel( iPetRank ) < iPetLevel || iPetLevel < 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s EXCEPTION ERROR : %s - %d - %d - %d", __FUNCTION__, GetPublicID().c_str(), iPetCode, iPetRank, iPetLevel );
		return PRESENT_RECV_EXCEPTION;
	}

	if( !m_UserPetItem.CheckPetHavePossible() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s EXCEPTION ERROR : %s - %d - %d - %d", __FUNCTION__, GetPublicID().c_str(), iPetCode, iPetRank, iPetLevel );
		return PRESENT_RECV_MAX_SLOT;
	}

	ioUserPet::PETSLOT rkNewSlot;
	rkNewSlot.m_iPetRank = iPetRank;
	rkNewSlot.m_iPetCode = iPetCode;
	rkNewSlot.m_iCurLevel = iPetLevel;

	//DB insert
	CQueryData query_data;
	DWORD dwPacketID = STPK_PET_ADD;
	DWORD dwPacketType = PET_PRESENT_OK;
	DWORD dwUserIndex = GetUserIndex();

	query_data.SetReturnData( &dwUserIndex, sizeof( DWORD ) );
	//query_data.SetReturnData( GetPublicID().c_str(), ID_NUM_PLUS_ONE );
	query_data.SetReturnData( &dwPacketID, sizeof( DWORD ) );
	query_data.SetReturnData( &dwPacketType, sizeof( DWORD ) );
	query_data.SetReturnData( &dwIndex, sizeof( DWORD ) );
	query_data.SetReturnData( &dwSlotIndex, sizeof( DWORD ) );

	m_UserPetItem.AddData( rkNewSlot, query_data );

	return PRESENT_RECV_OK;
}

void User::AddKillCount( RoomStyle eRoomStyle, ModeType eModeType, int iCount )
{
	bool bUseExtraOption = false;
	BattleRoomNode* pBattleRoom = (BattleRoomNode*)g_BattleRoomManager.GetBattleRoomNode( m_dwMyBattleRoom );
	if( pBattleRoom )
	{
		bUseExtraOption = pBattleRoom->IsUseExtraOption();
	}

	if( !bUseExtraOption )
	{
		switch( eRoomStyle )
		{
		case RSTYLE_BATTLEROOM:
		case RSTYLE_SHUFFLEROOM:
			m_UserRecord.AddRecordKill( RECORD_BATTLE, iCount );
			break;
		case RSTYLE_LADDERBATTLE:
			if( eModeType == MT_HEROMATCH )
			{
				m_UserRecord.AddRecordKill( RECORD_HEROMATCH, iCount );
			}
			else
			{
				m_UserRecord.AddRecordKill( RECORD_LADDER, iCount );
			}
			break;
		}
	}

	if( m_pMyRoom )
		m_pMyRoom->AddTeamKillPoint( GetTeam(), iCount );
}

void User::AddDeathCount( RoomStyle eRoomStyle, ModeType eModeType, int iCount )
{
	bool bUseExtraOption = false;
	BattleRoomNode* pBattleRoom = (BattleRoomNode*)g_BattleRoomManager.GetBattleRoomNode( m_dwMyBattleRoom );
	if( pBattleRoom )
	{
		bUseExtraOption = pBattleRoom->IsUseExtraOption();
	}

	if( !bUseExtraOption )
	{
		switch( eRoomStyle )
		{
		case RSTYLE_BATTLEROOM:
		case RSTYLE_SHUFFLEROOM:
			m_UserRecord.AddRecordDeath( RECORD_BATTLE, iCount );
			break;
		case RSTYLE_LADDERBATTLE:
			if( eModeType == MT_HEROMATCH )
			{	
				m_UserRecord.AddRecordDeath( RECORD_HEROMATCH, iCount );
			}
			else
			{	
				m_UserRecord.AddRecordDeath( RECORD_LADDER, iCount );
			}
			break;
		}
	}

	if( m_pMyRoom )
		m_pMyRoom->AddTeamDeathPoint( GetTeam(), iCount );
}

void User::AddWinCount( RoomStyle eRoomStyle, ModeType eModeType, int iCount )
{
	bool bUseExtraOption = false;
	BattleRoomNode* pBattleRoom = (BattleRoomNode*)g_BattleRoomManager.GetBattleRoomNode( m_dwMyBattleRoom );
	if( pBattleRoom )
	{
		bUseExtraOption = pBattleRoom->IsUseExtraOption();
	}

	if( !bUseExtraOption )
	{
		switch( eRoomStyle )
		{
		case RSTYLE_BATTLEROOM:
		case RSTYLE_SHUFFLEROOM:
			m_UserRecord.AddRecordWin( RECORD_BATTLE, iCount );
			break;
		case RSTYLE_LADDERBATTLE:
			if( eModeType == MT_HEROMATCH )
				m_UserRecord.AddRecordWin( RECORD_HEROMATCH, iCount );
			
			else
				m_UserRecord.AddRecordWin( RECORD_LADDER, iCount );
			break;
		}
	}
}

void User::AddLoseCount( RoomStyle eRoomStyle, ModeType eModeType, int iCount )
{
	bool bUseExtraOption = false;
	BattleRoomNode* pBattleRoom = (BattleRoomNode*)g_BattleRoomManager.GetBattleRoomNode( m_dwMyBattleRoom );
	if( pBattleRoom )
	{
		bUseExtraOption = pBattleRoom->IsUseExtraOption();
	}

	if( !bUseExtraOption )
	{
		switch( eRoomStyle )
		{
		case RSTYLE_BATTLEROOM:
		case RSTYLE_SHUFFLEROOM:
			m_UserRecord.AddRecordLose( RECORD_BATTLE, iCount );
			break;
		case RSTYLE_LADDERBATTLE:
			if( eModeType == MT_HEROMATCH )
				m_UserRecord.AddRecordLose( RECORD_HEROMATCH, iCount );
			else
				m_UserRecord.AddRecordLose( RECORD_LADDER, iCount );
			break;
		}
	}
}

DWORD User::GetEtcMotionAni( DWORD dwMotionType )
{
	DWORDVec kMotionList;
	int iCurrentEtcSlot = m_UserEtcItem.GetEtcItemCurrentSlot();
	for(int i = 0;i < iCurrentEtcSlot;i++)
	{
		ioUserEtcItem::ETCITEMSLOT kSlot;
		if( m_UserEtcItem.GetEtcItemByArray( i, kSlot ) )
		{
			if( COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION1, ioEtcItem::EIT_ETC_MOTION100 + 1 ) || 
				COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION101, ioEtcItem::EIT_ETC_MOTION400 + 1 ) )
			{
				if( kSlot.GetUse() != dwMotionType ) continue;

				kMotionList.push_back( kSlot.m_iType );	
			}
		}
	}

	if( kMotionList.empty() ) 
		return 0;

	int iRandom = rand() % (int)kMotionList.size();
	DWORD kReturn = kMotionList[iRandom];
	kMotionList.clear();
	return kReturn;
}

bool User::InitEtcItemUseBattleRecord()
{	
	// 전투 전적 초기화 - 승/패/킬/데스
	m_UserRecord.InitRecordInfo( RECORD_BATTLE );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s InitEtcItemUseBattleRecord", GetPublicID().c_str() );
	g_UserNodeManager.UpdateUserSync( this );
	return true;
}

bool User::InitEtcItemUseLadderRecord()
{
	// 진영 전적 초기화 - 승/패/킬/데스
	m_UserRecord.InitRecordInfo( RECORD_LADDER );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s InitEtcItemUseLadderRecord", GetPublicID().c_str() );
	g_UserNodeManager.UpdateUserSync( this );
	return true;
}

bool User::InitEtcItemUseHeroRecord()
{
	// 래더 전적 초기화 - 승/패/킬/데스/영웅경험치 - 누적 : 승/패/킬/데스/영웅경험치
	m_UserRecord.InitRecordInfo( RECORD_HEROMATCH );
	m_UserRecord.InitHeroSeasonRecord();	
	m_user_data.m_iAccrueHeroExpert = m_user_data.m_iHeroExpert = 0;

	// DB에 즉시 초기화 쿼리 전송
	g_DBClient.OnInitUserHeroExpert( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex() );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s InitEtcItemUseHeroRecord", GetPublicID().c_str() );
	g_UserNodeManager.UpdateUserSync( this );
	return true;
}

bool User::InitHeroSeasonRecord()
{
	return m_UserRecord.InitHeroSeasonRecord();
}

bool User::HeroSeasonEndDecreaseRate()
{
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::HeroSeasonEndDecreaseRate : %s : %d : %d : %.2f", 
						GetPublicID().c_str(), m_user_data.m_iAccrueHeroExpert, m_user_data.m_iHeroExpert,
						g_LadderTeamManager.GetSeasonEndDecreaseRate() );
	
	if( m_user_data.m_iHeroExpert == -1 ) return false; //이미 초기화가 되었다

    float fDecreaseRate = g_LadderTeamManager.GetSeasonEndDecreaseRate() + 0.000001f; 
	m_user_data.m_iAccrueHeroExpert = (float)m_user_data.m_iAccrueHeroExpert * fDecreaseRate;
	m_user_data.m_iAccrueHeroExpert += m_user_data.m_iHeroExpert;
	m_user_data.m_iHeroExpert = -1;
	m_hero_expert_change = true;

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::HeroSeasonEndDecreaseRate Change: %s : %d : %d", 
							GetPublicID().c_str(), m_user_data.m_iAccrueHeroExpert, m_user_data.m_iHeroExpert );
	return true;
}

void User::AddHeroExpert( int iHeroExpert )
{
	if( m_user_data.m_iHeroExpert == -1 ) 
		m_user_data.m_iHeroExpert = 0;
	m_user_data.m_iHeroExpert = max( 0, m_user_data.m_iHeroExpert + iHeroExpert );
	m_hero_expert_change = true;

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::AddHeroExpert : %s - (%d)%d", GetPublicID().c_str(), m_user_data.m_iHeroExpert, iHeroExpert );
}

void User::AddLadderPoint( int iLadderPoint )
{
	m_user_data.m_ladder_point = max( 0, m_user_data.m_ladder_point + iLadderPoint );
	m_user_data.m_accumulation_ladder_point = max( 0, m_user_data.m_accumulation_ladder_point + iLadderPoint );
	m_ladder_point_change = true;
}

bool User::SetLadderPoint( int iLadderPoint )
{
	if( m_user_data.m_ladder_point == iLadderPoint ) 
		return false;

	m_user_data.m_ladder_point = iLadderPoint;
	m_ladder_point_change = true;
	return true;
}

void User::AddCampSeasonBonus( DWORD dwBonusIndex, int iBlueCampPoint, int iBlueCampBonusPoint, int iBlueEntry, 
							   int iRedCampPoint, int iRedCampBonusPoint, int iRedEntry, int iMyCampType, int iMyCampPoint, int iMyCampRank )
{
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s - CampSeasonBonus Start - %d : %d : %d : %d : %d : %d : %d : %d : %d : %d : %.2f", GetPublicID().c_str(),
							dwBonusIndex, iBlueCampPoint, iBlueCampBonusPoint, iBlueEntry, iRedCampPoint, iRedCampBonusPoint,
							iRedEntry, iMyCampType, iMyCampPoint, iMyCampRank, GetBlockPointPer() );

	int iTotalPoint  = iBlueCampPoint + iRedCampPoint + iBlueCampBonusPoint + iRedCampBonusPoint;
	int iTotalEntry  = iBlueEntry + iRedEntry;
	float fBonus = 0.0f;
	if( iMyCampType != CAMP_NONE && iTotalEntry > 0 && iTotalPoint > 0 && iMyCampPoint > Help::GetLimitCampPoint() )
	{
		float fMyCampPoint, fMyCampBonusPoint, fOtherCampPoint, fOtherCampBonusPoint, fMyCampEntry, fOtherCampEntry;
		if( iMyCampType == CAMP_BLUE )
		{
			fMyCampPoint	  = iBlueCampPoint;
			fMyCampBonusPoint = iBlueCampBonusPoint;
			fMyCampEntry	  = iBlueEntry;
			
			fOtherCampPoint   = iRedCampPoint;
			fOtherCampBonusPoint = iRedCampBonusPoint;
			fOtherCampEntry   = iRedEntry;  
		}
		else
		{
			fMyCampPoint      = iRedCampPoint;
			fMyCampBonusPoint = iRedCampBonusPoint;
			fMyCampEntry      = iRedEntry;

			fOtherCampPoint   = iBlueCampPoint;
			fOtherCampBonusPoint = iBlueCampBonusPoint;
			fOtherCampEntry   = iBlueEntry;
		}
		
		iTotalEntry = max( Help::GetCampBonusMinEntry(), min( Help::GetCampBonusMaxEntry(), iTotalEntry ) );		
		float fDefaultBonus = ( Help::GetCampBonusDefaultA() * iTotalEntry ) / Help::GetCampBonusDefaultB();
		float fValue1 = (float)abs( ( fMyCampPoint + fMyCampBonusPoint ) - ( fOtherCampPoint + fOtherCampBonusPoint ) ) / iTotalPoint;		
		float fValue2 = pow( fValue1, Help::GetCampBonusCorrectionA() ) / 2;		
		float fValue3 = (float)(iMyCampPoint * fMyCampEntry) / fMyCampPoint;
		float fValue4 = pow( fValue3, Help::GetCampBonusCorrectionB() );
		if( fMyCampPoint + fMyCampBonusPoint > fOtherCampPoint + fOtherCampBonusPoint )
		{
			fBonus = fDefaultBonus * ( ( 0.5f + fValue2 ) * fValue4 );
		}
		else
		{
			fBonus = fDefaultBonus * ( ( 0.5f - fValue2 ) * fValue4 );
		}
	}
	
	int iBonusPeso = fBonus * GetBlockPointPer();
	if( iBonusPeso == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - CampSeasonBonus Result Zero!!!", GetPublicID().c_str() );
		// 유저에게 패킷 전송하지 않음
	}
	else
	{
		__int64 iPrevMoney = GetMoney();
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_LADDER_BONUS, 0, 0, iBonusPeso, NULL);
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s - CampSeasonBonus Result %d 페소획득 : %I64d - > %I64d", GetPublicID().c_str(), iBonusPeso, iPrevMoney, GetMoney() );		

		// 유저에게 패킷 전송
		SP2Packet kPacket( STPK_CAMP_SEASON_BONUS );
		kPacket << GetMoney() << iBonusPeso << iBlueCampPoint + iBlueCampBonusPoint << iRedCampPoint + iRedCampBonusPoint;
		kPacket << iMyCampType << iMyCampPoint << iMyCampRank;
		SendMessage( kPacket );
	}

	// 보너스 보상 삭제
	g_DBClient.OnDeleteCampSeasonBonus( GetUserDBAgentID(), GetAgentThreadID(), dwBonusIndex, GetUserIndex(), GetPublicID(), iBonusPeso );
}

void User::InitUserLadderPointNRecord()
{
	bool bSyncSend = false;
	// 시즌 진영 포인트 초기화
	if( SetLadderPoint( 0 ) )
		bSyncSend = true;

	// 시즌 영웅전 경험치 초기화 & 누적 경험치 감소
	if( HeroSeasonEndDecreaseRate() ) 
		bSyncSend = true;
	
	// 시즌 영웅전 전적 초기화
	if( InitHeroSeasonRecord() )
		bSyncSend = true;

	// 진영 타입 초기화
	if( GetUserCampPos() != 0 )
	{
		m_user_data.m_camp_position = 0;
		bSyncSend = true;
	}

	if( bSyncSend )
	{
		// 유저들에게 전송
		SP2Packet kPacket( STPK_USER_LADDER_POINT_RECORD_REFRESH );
		kPacket << GetLadderPoint() << m_user_data.m_iAccrueHeroExpert << GetHeroExp() << GetUserCampPos();
		m_UserRecord.FillHeroSeasonData( kPacket );
		SendMessage( kPacket );
	}
}

DWORD User::GetCharIndex(int array) const 
{	
	if( !COMPARE( array, 0, GetCharCount() ) ) return 0;

	return m_CharList[array]->GetCharIndex(); 
}

int User::GetCharClassType(int array) const 
{	
	if( !COMPARE( array, 0, GetCharCount() ) ) return 0;

	const CHARACTER &charInfo = m_CharList[array]->GetCharInfo();
	return charInfo.m_class_type;
}

int User::GetTopLevelClassType()
{
	return m_ClassExpert.GetTopLevelClassType();
}

int User::GetCharArray( DWORD dwIndex ) const
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( m_CharList[i]->GetCharIndex() == dwIndex ) 
			return i;
	}

	return -1;
}

bool User::IsCharMortmain( int iArray ) const
{
	if( !COMPARE( iArray, 0, GetCharCount() ) ) 
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::IsCharMortmain Error - Char Array Size Over %s", GetPublicID().c_str() );
		return false;
	}

	const CHARACTER &charInfo = m_CharList[iArray]->GetCharInfo();
	
	if( charInfo.m_ePeriodType == CPT_MORTMAIN )
		return true;

	return false;
}

bool User::IsCharClassType( int iClassType ) const
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( !m_CharList[i] ) 
			continue;
		
		const CHARACTER &charInfo = m_CharList[i]->GetCharInfo();
		if( charInfo.m_class_type == iClassType )
			return true;
	}

	return false;
}

bool User::IsActiveRentalClassType( int iClassType )
{
	for(int i = 0;i < GetCharCount();i++)
	{
		if( !m_CharList[i] ) continue;
		if( m_CharList[i]->GetCharInfo().m_class_type != iClassType ) continue;
		if( m_CharList[i]->HasExerciseStyle( EXERCISE_RENTAL ) == false ) return false;
		if( m_CharList[i]->GetRentalLimitTime() == 0 ) return false;

		return true;
	}
	return false;
}

int User::GetSelectClassType()
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::GetSelectClassType( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return 0;
	}
	const CHARACTER &charInfo = m_CharList[m_select_char]->GetCharInfo();

//	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::GetSelectClassType( %s ) : %d: %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
	return charInfo.m_class_type;
}

__int64 User::GetPartyExp()
{
	return m_UserRecord.GetRecordEXP( RECORD_BATTLE );
}

int User::GetPartyLevel()
{
	int iPartyExp = GetPartyExp();
	int iPartyLevel = 0;
	for(;iPartyLevel < 99;iPartyLevel++)
	{
		__int64 iExp = g_LevelMgr.GetNextPartyupExp( iPartyLevel );
		if( iExp > iPartyExp )
			break;
	}
	return iPartyLevel;
}

__int64 User::GetLadderExp()
{
	return m_UserRecord.GetRecordEXP( RECORD_LADDER );
}

int User::GetLadderLevel()
{
	int iLadderExp = GetLadderExp();
	int iLadderLevel = 0;
	for(;iLadderLevel < 99;iLadderLevel++)
	{
		__int64 iExp = g_LevelMgr.GetNextLadderupExp( iLadderLevel );
		if( iExp > iLadderExp )
			break;
	}
	return iLadderLevel;
}

int User::GetHeroExp()
{
	return max( 0, m_user_data.m_iHeroExpert );
}

int User::GetHeroMatchPoint()
{	
	// 유저 경험치
	float fWinPoint  = max( 1.0f, ( m_UserRecord.GetRecordWin( RECORD_HEROMATCH ) / 30 ) + 1.0f );
	float fLosePoint = max( 1.0f, ( m_UserRecord.GetRecordLose( RECORD_HEROMATCH ) / 10 ) + 1.0f );
	float fHeroExpert= GetHeroExp() + m_user_data.m_iAccrueHeroExpert; 
	int   iMatchPoint= (float)fHeroExpert * ( fWinPoint / fLosePoint );

	return iMatchPoint;
}

int User::GetHeroTitle()
{
	return m_UserHeroData.m_iHeroTitle;
}

ModeType User::GetPlayingMode()
{
	if( m_pMyRoom == NULL ) return MT_NONE;

	return m_pMyRoom->GetModeType();
}

void User::SendAllCharInfo()
{
	// 용병 1개당 120byte : 8 * Char = 960byte - 8개씩 나눠 보냄
	const int iSendListSize = 8;
	int iMaxCharCount = GetCharCount();

	if( 0 == iMaxCharCount && GetUserState() != US_TUTORIAL_CLEAR )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"[warning][charSend] first login user don't have hero : %s", GetPublicID().c_str() );
	}

	for(int iStartArray = 0;iStartArray < iMaxCharCount;)
	{
		int iLoop = iStartArray;
		int iSendSize = min( iMaxCharCount - iStartArray, iSendListSize );		
		SP2Packet kPacket( STPK_CHAR_ALL_LOAD );
		kPacket << iSendSize;	
		for(;iLoop < iStartArray + iSendSize;iLoop++)
		{
			ioCharacter *pCharacter = GetCharacter( iLoop );
			if( pCharacter == NULL )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "SendAllCharInfo Character NULL(%s - %d)", GetPublicID().c_str(), iLoop );
				return;
			}

			kPacket << iLoop;
			kPacket << pCharacter->GetCharIndex();
			kPacket << (CHARACTER)pCharacter->GetCharInfo();
		}
		SendMessage( kPacket );		
		if( 0 < iMaxCharCount && GetUserState() != US_TUTORIAL_CLEAR )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"[info][charSend] first login user send char info : %s", GetPublicID().c_str() );
		}
		iStartArray = iLoop;
	}	
}

void User::ClearCharJoinedInfo()
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		m_CharList[i]->m_bPlayJoined = false;
	}
}

void User::SetCharJoined( int iArray, bool bJoined )
{
	if( COMPARE( iArray, 0, GetCharCount() ) )
		m_CharList[iArray]->m_bPlayJoined = bJoined;
}

bool User::IsCharJoined( int iArray )
{
	if( COMPARE( iArray, 0, GetCharCount() ) )
		return m_CharList[iArray]->m_bPlayJoined;

	return false;
}

void User::CheckCharSlot( ioCharacter *pChar )
{
	if( !pChar ) 
		return;

	if( COMPARE( pChar->GetCharSlotIndex(), 0, m_iCurMaxCharSlot ) ) 
		return;

	int i = 0;
	DWORDVec vCharSlotIndex;
	int iCharCount = GetCharCount();
	for( i = 0; i < iCharCount; ++i )
	{
		if( pChar == m_CharList[i] )
			continue;

		int iCharSlotIndex = m_CharList[i]->GetCharSlotIndex();
		if( iCharSlotIndex == -1 )
		{
			//LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::CheckCharSlot(%s) Char Slot Index error!!", GetPublicID().c_str() ); 2013.12.23 유영재 
			//pc방 용병 선택시 한번도 안 써본 용병일 경우 무조건 로그가 남음.
			continue;
		}

		vCharSlotIndex.push_back( iCharSlotIndex );
	}

	if( !vCharSlotIndex.empty() )
		std::sort( vCharSlotIndex.begin(), vCharSlotIndex.end() );

	int iNewCharSlotIndex = 0;
	for( i = 0; i < (int)vCharSlotIndex.size(); ++i )
	{
		if( iNewCharSlotIndex == vCharSlotIndex[i] )
			iNewCharSlotIndex++;
		else
			break;
	}
	pChar->SetCharSlotIndex( iNewCharSlotIndex );
	vCharSlotIndex.clear();

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::CheckCharSlot(%s) New Char Slot Index[%u : %d]", GetPublicID().c_str(), pChar->GetCharIndex(), iNewCharSlotIndex );
}

void User::IntegrityCharSlot()
{
	int i = 0;	
	int iCharCount = GetCharCount();
	for(i = 0;i < iCharCount;i++)
	{
		ioCharacter *pChar = m_CharList[i];
		if( pChar == NULL ) continue;

		int iCharSlotIndex = m_CharList[i]->GetCharSlotIndex();
		if( iCharSlotIndex == -1 )
		{
			CheckCharSlot( pChar );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::IntegrityCharSlot(%s) Char Slot Index Login Set [%d]", GetPublicID().c_str(), pChar->GetCharSlotIndex() );
			continue;
		}
	}
}

int User::GetCharSlotIndexToArray( int iSlotIndex )
{
	int iCharCount = GetCharCount();
	for(int i = 0;i < iCharCount;i++)
	{
		int iCharSloatIndex = m_CharList[i]->GetCharSlotIndex();
		if( iCharSloatIndex == iSlotIndex )
			return i;
	}
    return -1;
}

bool User::IsCharPeriodTime( int iClassType )
{
	int iCharCount = GetCharCount();
	for(int i = 0;i < iCharCount;i++)
	{
		const CHARACTER &rkCharInfo = m_CharList[i]->GetCharInfo();
		if( rkCharInfo.m_class_type != iClassType ) continue;
		if( rkCharInfo.m_ePeriodType != CPT_TIME ) continue;

		return true;
	}
	return false;
}

bool User::UseModeStartMonsterCoin( int iUseCnt, bool bUseGoldCoin )
{

	/*if( IsPCRoomAuthority() )
		return true;*/

	ioUserEtcItem::ETCITEMSLOT kMonsterCoinSlot, kGoldMonsterCoinSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_MONSTER_COIN, kMonsterCoinSlot );
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_GOLDMONSTER_COIN, kGoldMonsterCoinSlot );

	if(bUseGoldCoin)
	{
		if( kMonsterCoinSlot.GetUse() + kGoldMonsterCoinSlot.GetUse() < iUseCnt )
			return false;
	}
	else
	{
		if( kMonsterCoinSlot.GetUse() < iUseCnt)
			return false;
	}

	// 몬스터 코인 감소
	int iMonsterCoin = kMonsterCoinSlot.GetUse();
	kMonsterCoinSlot.AddUse( -min( iMonsterCoin, iUseCnt ) );
	m_UserEtcItem.SetEtcItem( kMonsterCoinSlot );     // 삭제하지 않는다.
	iUseCnt -= min( iMonsterCoin, iUseCnt );

	// 골드 몬스터 코인 감소
	if( iUseCnt > 0 )
	{
		kGoldMonsterCoinSlot.AddUse( -iUseCnt );
		if( kGoldMonsterCoinSlot.GetUse() <= 0 )
		{
			m_UserEtcItem.DeleteEtcItem( kGoldMonsterCoinSlot.m_iType, LogDBClient::ET_DEL );
		}
		else
		{
			m_UserEtcItem.SetEtcItem( kGoldMonsterCoinSlot );
		}
	}	
	return true;
}

bool User::UseGoldMonsterCoin()
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_GOLDMONSTER_COIN, kSlot );
	if( kSlot.m_iType <= 0 || kSlot.GetUse() <= 0 )
	{
		return false;
	}
	kSlot.AddUse( -1 );
	if( kSlot.GetUse() <= 0 )
	{
		m_UserEtcItem.DeleteEtcItem( kSlot.m_iType, LogDBClient::ET_DEL );
	}
	else
	{
		m_UserEtcItem.SetEtcItem( kSlot );
	}
	return true;
}

bool User::UseRouletteCoin( const int iUseCount, const BOOL bOnlyCheck )
{
	if( iUseCount <= 0 )
		return true;

	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_ROULETTE_COIN, kSlot );
	if( kSlot.m_iType <= 0 || kSlot.GetUse() <= 0 )
	{
		return false;
	}

	if( kSlot.GetUse() - iUseCount < 0 )
	{
		return false;
	}

	if( bOnlyCheck == TRUE )
		return true;

	kSlot.AddUse( -iUseCount );
	if( kSlot.GetUse() <= 0 )
	{
		m_UserEtcItem.DeleteEtcItem( kSlot.m_iType, LogDBClient::ET_DEL );
	}
	else
	{
		m_UserEtcItem.SetEtcItem( kSlot, LogDBClient::ET_USE );
	}
	return true;
}

int User::GetEtcMonsterCoin()
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_MONSTER_COIN, kSlot );
	if( kSlot.m_iType <= 0 )
	{
		return 0;
	}

	return kSlot.GetUse();
}

int User::GetEtcGoldMonsterCoin()
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_GOLDMONSTER_COIN, kSlot );
	if( kSlot.m_iType <= 0 )
	{
		return 0;
	}

	return kSlot.GetUse();
}

int User::AddEtcMonsterCoin( int iAddCoin )
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_MONSTER_COIN, kSlot );
	if( kSlot.m_iType <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::AddEtcMonsterCoin : None Etc Item : %s - AddCoin : %d", GetPublicID().c_str(), iAddCoin );
		return 0;
	}
	kSlot.AddUse( iAddCoin );
	m_UserEtcItem.SetEtcItem( kSlot );
	return kSlot.GetUse();
}

int User::AddRefillSeconds( DWORD dwAddSeconds )
{
	int iEtcMonsterCoin = GetEtcMonsterCoin();
	int iRefillCount    = dwAddSeconds / Help::GetRefillCoinSec(); 
	int iRemainSec      = dwAddSeconds % Help::GetRefillCoinSec();	
	if( m_user_data.m_refill_data - iRemainSec <= 0 )
	{
		iRemainSec -= m_user_data.m_refill_data;
		m_user_data.m_refill_data = Help::GetRefillCoinSec() - iRemainSec;
		iRefillCount++;
	}
	else
	{
		m_user_data.m_refill_data -= iRemainSec;
	}

	// 최대 수량을 확보했으면 무조건 최대 초부터 대기한다.
	if( iEtcMonsterCoin + iRefillCount >= Help::GetRefillCoinMax() )
	{
		m_user_data.m_refill_data = Help::GetRefillCoinSec();
	}
	return iRefillCount;
}

int User::GetRefillSeconds()
{
	return m_user_data.m_refill_data;
}

void User::CheckRefillMonsterCoin( DWORD dwProcessSec, bool bFirstSync /* = false  */ )
{
	if( GetUserIndex() == 0 ) return;
	if( dwProcessSec == 0 ) return;
	if( Help::GetRefillCoinSec() == 0 || Help::GetRefillCoinMax() <= 0 ) return;

	int iEtcMonsterCoin = GetEtcMonsterCoin();
	if( iEtcMonsterCoin >= Help::GetRefillCoinMax() ) return;
	
	// 리필 되어야할 몬스터 코인 갯수
	int iRefillCount = AddRefillSeconds( dwProcessSec );
	// 몬스터 코인 지급.
	iRefillCount = min( iRefillCount, Help::GetRefillCoinMax() - iEtcMonsterCoin );
	if( iRefillCount > 0 || bFirstSync )
	{
		// 몬스터 코인 지급 및 최대값이면 시간 초기화.
		if( AddEtcMonsterCoin( iRefillCount ) >= Help::GetRefillCoinMax() )
		{	
			m_user_data.m_refill_data = Help::GetRefillCoinSec();
		}

		// 유저에게 전송해줘야함....
		SP2Packet kPacket( STPK_REFILL_COIN );
		kPacket << m_user_data.m_refill_data;
		kPacket << iRefillCount;
		SendMessage( kPacket );

		if( iRefillCount > 0 )
		{
			SaveUserData();
		}
	}
}

float User::GetSoldierExpBonus( int iClassType )
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	if( m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_SOLDIER_EXP_BONUS, kSlot ) )
	{
		if( kSlot.GetDateExcludeValue2() != iClassType )
			return 0.0f;

		ioEtcItemSoldierExpBonus *pItemItem = static_cast< ioEtcItemSoldierExpBonus * >( g_EtcItemMgr.FindEtcItem( ioEtcItem::EIT_ETC_SOLDIER_EXP_BONUS ) );
		if( pItemItem )
		{
			if( m_ClassExpert.GetClassLevel( iClassType ) >= pItemItem->GetLimitLevel() )
				return 0.0f;

			return (float)pItemItem->GetUseValue() / 100.0f;
		}
	}
	return 0.0f;  //
}

void User::SetTeam( TeamType eTeam )
{
	m_Team = eTeam;
}

void User::SetShamBattleTeam( TeamType eTeam )
{
	m_ShamBattleTeam = eTeam;
}

void User::SetExitRoomDelay( DWORD dwExitTime )
{
	m_dwExitRoomTime	= dwExitTime ;
	m_dwCurExitRoomTime = TIMEGETTIME();
}

bool User::IsExitRoomDelay()
{
	if( m_dwExitRoomTime == 0 ) return false;

	return true;
}

bool User::ExitRoomTimeOver()
{
	if( !IsExitRoomDelay() ) return false;

	return ( TIMEGETTIME() - m_dwCurExitRoomTime > m_dwExitRoomTime );
}

bool User::ToggleExitRoomReserve()
{
	m_bExitRoomReserved = !m_bExitRoomReserved;

	return m_bExitRoomReserved;
}

void User::ClearExitRoomReserve()
{
	m_bExitRoomReserved = false;
}

void User::SetExitPosition( bool bExitLobby )
{
	m_bExitLobby = bExitLobby;
}

void User::SetClientAddr( sockaddr_in client_addr )
{
	char back_iip[16] = "";
	int  back_port = m_client_port;
	strcpy_s( back_iip, m_public_ip );
	CConnectNode::SetClientAddr( client_addr );
	SetClientAddr(back_iip, back_port);
}

void User::SetClientAddr( const char* back_iip, const int back_port )
{
	//antihack
	// 이거 해야함!!

// 	if( strcmp( back_iip, m_public_ip ) != 0 || back_port != m_client_port )
// 	{
// 		SP2Packet kPacket( STPK_CHANGE_UDP_INFO );
// 		ServerNode* node = NULL;
// 		ioHashString ipAddr; //kyg 작업 
// 		int port;
// 		node = g_Relay.GetRelayServer(RelayServerID());
// 		if(node)
// 		{
// 			//kyg 여기도 바꿈 
// 			ipAddr = node->SZPublicIP();
// 			if(GetMyRoom())
// 				port = node->GetRelayServerPort(GetMyRoom()->GetRoomIndex());
// 			else
// 				port = node->GetRelayServerPort(0);
// 			//LOG.PrintTimeAndLog(0,"SetClientAddr::RelayServerNode :%s:%d",ipAddr.c_str(),port);
// 		}
// 		else
// 		{
// 			ipAddr = g_App.GetClientMoveIP();
// 			port = g_App.GetCSPort();
// 		//	LOG.PrintTimeAndLog(0,"Orginal :%s:%d",ipAddr.c_str(),port);
// 		}
// 
// 		kPacket << GetPublicID() << m_public_ip << m_client_port << m_private_ip <<ipAddr << port;
// 		//LOG.PrintTimeAndLog(0,"Public ID:%s Public IP:%s:%d Private IP : %s || %s:%d",GetPublicID().c_str(),m_public_ip,m_client_port,m_private_ip,ipAddr.c_str(),port);
// 		if( m_pMyRoom )
// 		{
// 			m_pMyRoom->RoomSendPacketTcp( kPacket, this );
// 
// 			g_Relay.InsertRelayGroupReserve(m_pMyRoom, GetUserIndex(), GetPublicIP(), GetUDP_port(), GetPublicID() );
// 		}
// 
// 		if( IsBattleRoom() )
// 		{
// 			BattleRoomParent *pBattleRoom = GetMyBattleRoom();
// 			if( pBattleRoom )
// 				pBattleRoom->UserUDPChange( GetUserIndex(), GetPublicID(), m_public_ip, m_client_port, m_private_ip, g_App.GetClientMoveIP(), g_App.GetCSPort() );
// 		}
// 		else if( IsLadderTeam() )
// 		{
// 			LadderTeamParent *pLadderTeam = GetMyLadderTeam();
// 			if( pLadderTeam )
// 				pLadderTeam->UserUDPChange( GetUserIndex(), GetPublicID(), m_public_ip, m_client_port, m_private_ip, g_App.GetClientMoveIP(), g_App.GetCSPort() );
// 		}
// 		SendMessage( kPacket );
// 		m_dwMyIP = Help::GetStringIPToDWORDIP( m_public_ip );
// 		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "UDP Change:%s(%s:%d:%s:%s) (%I64d)", GetPublicID().c_str(),
// 			m_public_ip, m_client_port, m_private_ip, GetCountry().c_str(), (__int64)m_dwMyIP );
// 	}
}

bool User::RoomBroadCast( SP2Packet &rkPacket )
{
	if( !COMPARE( rkPacket.GetPacketID(), CUPK_CONNECT, 0x5000 ) )
	{
		return false;
	}

	switch( rkPacket.GetPacketID() )
	{
	case CUPK_CONNECT:                   //서버가 알아야 할 내용.
	case CUPK_SYNCTIME:
	case CUPK_RESERVE_ROOM_JOIN:
	case CUPK_CHECK_KING_PING:
		return false;
	}

	SP2Packet kPacket( rkPacket.GetPacketID() );
	if( Help::IsServerRelayToTCP() )
	{
		int iCutSize = sizeof( DWORD ) * 4;     // IP / PORT / USER INDEX / UDP INDEX
		if( rkPacket.GetDataSize() > iCutSize )
		{
			kPacket.SetDataAdd( (char*)rkPacket.GetData() + iCutSize, rkPacket.GetDataSize() - iCutSize );
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Size %d)%s [0x%x]", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str(), rkPacket.GetPacketID() );
		}
	}
	else
	{
		// 서버 중계용 패킷에는 IP / PORT 정보가 포함되어있으므로 1,1 세팅
		int iCutSize = sizeof( DWORD ) * 2;     // IP / PORT
		if( rkPacket.GetDataSize() > iCutSize )
		{
			kPacket.SetDataAddCreateUDP( 1, 1, (char*)rkPacket.GetData() + iCutSize, rkPacket.GetDataSize() - iCutSize );
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Size %d)%s [0x%x]", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str(), rkPacket.GetPacketID() );
		}
	}

	int iSendCount = 0;
	if( m_pMyRoom )  // 룸에 있으면 룸 유저들한테만 전송
	{
		if( Help::IsServerRelayToTCP() )
			m_pMyRoom->RoomSendPacketTcp( kPacket, this );
		else
		{
		
			m_pMyRoom->RoomSendPacketUdp( kPacket, this );
		}

		iSendCount = m_pMyRoom->GetJoinUserCnt() - 1;
	}
	else if( IsBattleRoom() )  // 전투방 유저들한테만 전송
	{
		BattleRoomParent *pBattleRoom = GetMyBattleRoom();
		if( pBattleRoom )
		{
			if( Help::IsServerRelayToTCP() )
				pBattleRoom->SendPacketTcp( kPacket, GetUserIndex() );
			else
				pBattleRoom->SendPacketUdp( kPacket, GetUserIndex() );
			iSendCount = pBattleRoom->GetJoinUserCnt() - 1;
		}
	}
	else if( IsLadderTeam() )  // 진영팀 유저들한테만 전송
	{
		LadderTeamParent *pLadderTeam = GetMyLadderTeam();
		if( pLadderTeam )
		{
			if( Help::IsServerRelayToTCP() )
				pLadderTeam->SendPacketTcp( kPacket, GetUserIndex() );
			else
				pLadderTeam->SendPacketUdp( kPacket, GetUserIndex() );
			iSendCount = pLadderTeam->GetJoinUserCnt() - 1;
		}
	}

	g_EtcLogMgr.PlusUDPTransferTCPSend( max( 0, iSendCount ) );
	return true;
}

void User::FillConnectUserData( SP2Packet &rkPacket )
{
	
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_user_idx) );
	PACKET_GUARD_VOID( rkPacket.Write(GetPublicID()) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_cash) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_money) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_connect_count) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_user_state) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_grade_level) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_grade_exp) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_fishing_level) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_fishing_exp) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_refill_data) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_user_event_type) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_user_rank) );
	PACKET_GUARD_VOID( rkPacket.Write(Help::ConvertCTimeToDayCount( m_user_data.m_connect_time )) );
	PACKET_GUARD_VOID( rkPacket.Write((int)m_user_data.m_eEntryType) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_camp_position) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_ladder_point) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_camp_rank) );
	PACKET_GUARD_VOID( rkPacket.Write((int)m_user_data.m_eChannelingType) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_szChannelingUserID) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_szChannelingUserNo) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_iChannelingCash) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_purchased_cash) );
	PACKET_GUARD_VOID( rkPacket.Write((int)m_user_data.m_eBlockType) );
	PACKET_GUARD_VOID( rkPacket.Write(Help::ConvertCTimeToYearMonthDay( m_user_data.m_kBlockTime )) );
	PACKET_GUARD_VOID( rkPacket.Write(Help::ConvertCTimeToHourMinute( m_user_data.m_kBlockTime )) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_iExcavationLevel) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_iExcavationExp) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_iAccrueHeroExpert) ); 
	PACKET_GUARD_VOID( rkPacket.Write(m_user_data.m_iHeroExpert) );

	// 상대계급 정보
	PACKET_GUARD_VOID( rkPacket.Write(m_user_relative_grade_data.m_init_code) );
	PACKET_GUARD_VOID( rkPacket.Write(m_user_relative_grade_data.m_enable_reward) );

	// 최종 접속일로부터 현재 접속까지의 시간(DAY)
	CTime cCurTime = CTime::GetCurrentTime();
	CTime cLogOutTime( Help::GetSafeValueForCTimeConstructor( m_user_data.m_connect_time.GetYear(), m_user_data.m_connect_time.GetMonth(),
															  m_user_data.m_connect_time.GetDay(), 1, 0, 0 ) );
	CTime cLogInTime( Help::GetSafeValueForCTimeConstructor( cCurTime.GetYear(), cCurTime.GetMonth(), cCurTime.GetDay(), 1, 0, 0 ) ); 
	CTimeSpan cGapTime = cLogInTime - cLogOutTime;
	
	// 최종 접속일로부터 현재 접속까지의 시간(Sec)
	CTime cLogOutTime2( Help::GetSafeValueForCTimeConstructor( m_user_data.m_connect_time.GetYear(), m_user_data.m_connect_time.GetMonth(),
															   m_user_data.m_connect_time.GetDay(), m_user_data.m_connect_time.GetHour(), m_user_data.m_connect_time.GetMinute(), m_user_data.m_connect_time.GetSecond() ) );
	CTime cLogInTime2( Help::GetSafeValueForCTimeConstructor( cCurTime.GetYear(), cCurTime.GetMonth(), cCurTime.GetDay(), cCurTime.GetHour(), cCurTime.GetMinute(), cCurTime.GetSecond() ) ); 
	CTimeSpan cGapTime2 = cLogInTime2 - cLogOutTime2;

	int iTotalDays    = (int)cGapTime2.GetDays();
	int iTotalSeconds = (int)cGapTime2.GetTotalSeconds();
	PACKET_GUARD_VOID( rkPacket.Write((int)time(NULL)) );
	PACKET_GUARD_VOID( rkPacket.Write((int)cGapTime.GetDays()) );
	PACKET_GUARD_VOID( rkPacket.Write(iTotalSeconds) );

	time_t tLogOutTime	= cLogOutTime2.GetTime();
	PACKET_GUARD_VOID( rkPacket.Write(tLogOutTime) );

	// 선택중인 용병 어레이
	PACKET_GUARD_VOID( rkPacket.Write(m_select_char) );

	m_Quest.CheckQuestReConnectSeconds( iTotalSeconds );
}

void User::FillEquipItemData( SP2Packet &rkPacket )
{
	rkPacket << GetPublicID();

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		bool bRoom = false;
		if( m_pMyRoom )
			bRoom = true;
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillEquipItemData( %s ) : %d >= %d(IsRoom(%d)IsParty(%d)IsLadderTeam(%d))", 
								GetPublicID().c_str(), m_select_char, GetCharCount(), bRoom, IsBattleRoom(), IsLadderTeam() );
		// 예외가 발생해도 일단 패킷은 정상적으로 보내줘야 꼬이지 않는다. 예외가 발생한 부분은 해결 필요
		for( int i=0 ; i<MAX_EQUIP_SLOT ; i++ )
		{
			rkPacket << 0 << 0 << 0 << 0 << 0 << "";
		}
		return;
	}

	if( m_pMyRoom )
		m_CharList[m_select_char]->FillEquipItemInfo( rkPacket );
	else  // 임시 파티참여 상태에서 장착 아이템 전송
	{
		for( int i=0 ; i<MAX_EQUIP_SLOT ; i++ )
		{
			if( i < MAX_CHAR_DBITEM_SLOT )
			{
				const ITEM_DATA *pItemData = m_CharList[m_select_char]->GetDBItemData( i );
				if( pItemData && pItemData->m_item_code > 0 )
				{
					rkPacket << pItemData->m_item_code;
					rkPacket << pItemData->m_item_reinforce;
					rkPacket << pItemData->m_item_male_custom;
					rkPacket << pItemData->m_item_female_custom;
					rkPacket << m_CharList[m_select_char]->GetCharIndex();
					rkPacket << GetPublicID();
				}
				else
				{
					rkPacket << 0;
					rkPacket << 0;
					rkPacket << 0;
					rkPacket << 0;
					rkPacket << 0;
					rkPacket << "";
				}
			}
			else
			{
				rkPacket << 0;
				rkPacket << 0;
				rkPacket << 0;
				rkPacket << 0;
				rkPacket << 0;
				rkPacket << "";
			}
		}
	}
}

void User::FillJoinUserData( SP2Packet &rkPacket, bool bExperienceChar )
{

#ifndef ANTIHACK
	ServerNode* node = NULL;
	ioHashString szIpAddr;
	int iPort;
	SetTransferAddress(node, szIpAddr, iPort); //for relay 
	ioCharacter *rkChar = GetCharacter( m_select_char );    
	if( rkChar == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::FillJoinUserData( %s ) GetCharacter Not Using!!", GetPublicID().c_str() );

		// 예외 발생.
		static CHARACTER szTemp;		
		rkPacket << GetPublicID() << GetCountRSoldier() << GetCountOfSpecialSoldier(SST_GFRIEND) << m_UserGuild.GetGuildIndex() << m_UserGuild.GetGuildMark() << 0 << GetGradeLevel() << GetClassLevel( m_select_char, false );
		//rkPacket << GetUserIndex() << m_public_ip << m_client_port << m_private_ip << g_App.GetClientMoveIP() << g_App.GetCSPort();
		rkPacket << GetUserIndex() << m_public_ip << m_client_port << m_private_ip << szIpAddr << iPort ;// for relay
		rkPacket << szTemp;
		rkPacket << m_Team << m_select_char << m_bMovieCapturing;
		return ;
	}

	// JOIN정보 세팅시에 유저 아이디 / 리더 이름 세팅.
	rkPacket << GetPublicID() << GetCountRSoldier() << GetCountOfSpecialSoldier(SST_GFRIEND) << m_UserGuild.GetGuildIndex() << m_UserGuild.GetGuildMark() 
			 << rkChar->GetCharIndex() << GetGradeLevel() << GetClassLevel( m_select_char, false );

	//rkPacket << GetUserIndex() << m_public_ip << m_client_port << m_private_ip << g_App.GetClientMoveIP() << g_App.GetCSPort();
	rkPacket << GetUserIndex() << m_public_ip << m_client_port << m_private_ip << szIpAddr << iPort;// for relay

	if( bExperienceChar )
		rkPacket << (CHARACTER&)rkChar->GetExperienceCharInfo();
	else
		rkPacket << (CHARACTER&)rkChar->GetCharInfo();

	rkPacket << m_Team << m_select_char << m_bMovieCapturing;
#else
	ServerNode* node = NULL;
	ioHashString szIpAddr;
	int iPort;
	SetTransferAddress(node, szIpAddr, iPort); //for relay 
	ioCharacter *rkChar = GetCharacter( m_select_char );    
	if( rkChar == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::FillJoinUserData( %s ) GetCharacter Not Using!!", GetPublicID().c_str() );

		// 예외 발생.
		static CHARACTER szTemp;		
		rkPacket << GetPublicID() << GetCountRSoldier() << m_UserGuild.GetGuildIndex() << m_UserGuild.GetGuildMark() << 0 << GetGradeLevel() << GetClassLevel( m_select_char, false );
		rkPacket << GetUserIndex() << m_public_ip << m_client_port << m_private_ip << szIpAddr << iPort << GetUserSeed() << GetNPCSeed();
		rkPacket << szTemp;
		rkPacket << m_Team << m_select_char << m_bMovieCapturing; // << 0 << 0;
		return ;
	}

	// JOIN정보 세팅시에 유저 아이디 / 리더 이름 세팅.
	rkPacket << GetPublicID() << GetCountRSoldier() << m_UserGuild.GetGuildIndex() << m_UserGuild.GetGuildMark() 
		<< rkChar->GetCharIndex() << GetGradeLevel() << GetClassLevel( m_select_char, false );

	rkPacket << GetUserIndex() << m_public_ip << m_client_port << m_private_ip << szIpAddr << iPort;// for relay

	rkPacket << GetUserSeed() << GetNPCSeed();

	if( bExperienceChar )
		rkPacket << (CHARACTER&)rkChar->GetExperienceCharInfo();
	else
		rkPacket << (CHARACTER&)rkChar->GetCharInfo();

	rkPacket << m_Team << m_select_char << m_bMovieCapturing;
#endif
}

void User::FillChangeCharData( SP2Packet &rkPacket )
{
	ioCharacter *rkChar = GetCharacter( m_select_char );    
	if( rkChar == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::FillChangeCharData( %s ) GetCharacter Not Using!!", GetPublicID().c_str() );

		// 캐릭터 예외 발생.
		static CHARACTER szTemp;		
		
		PACKET_GUARD_VOID( rkPacket.Write(0) );
		PACKET_GUARD_VOID( rkPacket.Write((BYTE)0) );
		PACKET_GUARD_VOID( rkPacket.Write(GetClassLevel( m_select_char, false )) );
		PACKET_GUARD_VOID( rkPacket.Write(GetHeroTitle()) );

		PACKET_GUARD_VOID( rkPacket.Write(szTemp.m_class_type) ); 
		PACKET_GUARD_VOID( rkPacket.Write(szTemp.m_kindred) ); 
		PACKET_GUARD_VOID( rkPacket.Write(szTemp.m_sex) );

		PACKET_GUARD_VOID( rkPacket.Write(m_select_char) );
		PACKET_GUARD_VOID( rkPacket.Write(m_bMovieCapturing) );

		// 예외가 발생해도 일단 패킷은 정상적으로 보내줘야 꼬이지 않는다. 예외가 발생한 부분은 해결 필요
		for( int i=0 ; i<MAX_EQUIP_SLOT ; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write(0) );
			PACKET_GUARD_VOID( rkPacket.Write("") );
		}

		PACKET_GUARD_VOID( rkPacket.Write( "" ) );

		for( int i = 0; i < MAX_CHAR_ACCESSORY_SLOT; i++ )
		{
			PACKET_GUARD_VOID(rkPacket.Write(0));
			PACKET_GUARD_VOID(rkPacket.Write(0));
			PACKET_GUARD_VOID(rkPacket.Write(0));
		}
	}
	else
	{
		const CHARACTER &rkCharInfo = rkChar->GetCharInfo();
		PACKET_GUARD_VOID( rkPacket.Write(rkChar->GetCharIndex()) );
		PACKET_GUARD_VOID( rkPacket.Write(rkCharInfo.m_chAwakeType) );
		PACKET_GUARD_VOID( rkPacket.Write(GetClassLevel( m_select_char, false )) ); 
		PACKET_GUARD_VOID( rkPacket.Write(GetHeroTitle()) );
		PACKET_GUARD_VOID( rkPacket.Write(rkCharInfo.m_class_type) );
		PACKET_GUARD_VOID( rkPacket.Write(rkCharInfo.m_kindred) );
		PACKET_GUARD_VOID( rkPacket.Write(rkCharInfo.m_sex) );
		
		PACKET_GUARD_VOID( rkPacket.Write(m_select_char) );
		PACKET_GUARD_VOID( rkPacket.Write(m_bMovieCapturing) );

		// 코스튬 정보
		//rkChar->FillEquipCostumeInfo( rkPacket );
		// 아이템 정보

		rkChar->FillEquipItemInfo( rkPacket );

		if( (GetPlayingMode() == MT_UNDERWEAR) || (GetPlayingMode() == MT_CBT) )
		{
			PACKET_GUARD_VOID( rkPacket.Write( "" ) );

			for( int i = 0; i < MAX_CHAR_ACCESSORY_SLOT; i++ )
			{
				PACKET_GUARD_VOID(rkPacket.Write(0));
				PACKET_GUARD_VOID(rkPacket.Write(0));
				PACKET_GUARD_VOID(rkPacket.Write(0));
			}
		}
		else
		{
			rkChar->FillEquipAccessoryInfo( rkPacket, this );
		}
	}
}

void User::FillExperienceChar( SP2Packet &rkPacket )
{
	ioCharacter *rkChar = GetCharacter( m_select_char );    
	if( rkChar == NULL )
	{
		rkPacket << false;
	}
	else
	{
		rkPacket << true;

		const CHARACTER &rkCharInfo = rkChar->GetExperienceCharInfo();
		rkPacket << rkCharInfo.m_kindred << rkCharInfo.m_sex << rkCharInfo.m_face << rkCharInfo.m_hair << rkCharInfo.m_hair_color
				 << rkCharInfo.m_skin_color << rkCharInfo.m_beard << rkCharInfo.m_accessories << rkCharInfo.m_underwear;
		
		for( int i = 0; i < MAX_CHAR_COSTUME_SLOT; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write(rkCharInfo.m_costume_item[i].m_iCostumeCode) );
		}

		rkChar->FillEquipItemInfo( rkPacket );
	}
}

void User::FillFinalRoundResult( RoomStyle eRoomStyle, ModeType eModeType, SP2Packet &kPacket )
{
	int iWin, iLose, iKill, iDeath;
	iWin = iLose = iKill = iDeath = 0;
	switch( eRoomStyle )
	{
	case RSTYLE_BATTLEROOM:
	case RSTYLE_SHUFFLEROOM:
		{
			m_UserRecord.GetRecordInfo( RECORD_BATTLE, iWin, iLose, iKill, iDeath );
		}
		break;
	case RSTYLE_LADDERBATTLE:
		if( eModeType == MT_HEROMATCH )
		{	
			m_UserRecord.GetRecordInfo( RECORD_HEROMATCH, iWin, iLose, iKill, iDeath );
		}
		else
		{
			m_UserRecord.GetRecordInfo( RECORD_LADDER, iWin, iLose, iKill, iDeath );
		}
		break;
	}
	kPacket << (int)eRoomStyle << (int)eModeType << iWin << iLose << iKill << iDeath << GetLadderPoint();

	// 영웅전은 시즌 정보도 전송한다.
	if( eRoomStyle == RSTYLE_LADDERBATTLE && eModeType == MT_HEROMATCH )
	{
		m_UserRecord.FillHeroSeasonData( kPacket );
	}
}

void User::FillItemSlotData( SP2Packet &rkPacket )
{
	
}

void User::FillClassData( int iClassType, bool bCurrentEquip, SP2Packet &rkPacket )
{
	int iSize = GetCharCount();
	for(int i = 0;i < iSize;i++)
	{
        const CHARACTER &charInfo = m_CharList[i]->GetCharInfo();
		if( charInfo.m_class_type == iClassType )
		{
			rkPacket << (CHARACTER)charInfo;
			rkPacket << GetClassLevelByType( iClassType, false );

			for( int j=0; j < MAX_CHAR_DBITEM_SLOT; ++j )
			{
				if( bCurrentEquip )
				{
					rkPacket << m_CharList[i]->GetCurrentItemCode(j);
					rkPacket << m_CharList[i]->GetCurrentItemReinforce(j);
					rkPacket << m_CharList[i]->GetCurrentItemMaleCustom(j);
					rkPacket << m_CharList[i]->GetCurrentItemFemaleCustom(j);
				}
				else
				{
					rkPacket << m_CharList[i]->GetDBItemData(j)->m_item_code;
					rkPacket << m_CharList[i]->GetDBItemData(j)->m_item_reinforce;
					rkPacket << m_CharList[i]->GetDBItemData(j)->m_item_male_custom;
					rkPacket << m_CharList[i]->GetDBItemData(j)->m_item_female_custom;
				}
			}
			return;
		}
	}

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::FillClassData (%d)용병이 없다 :(%s)", iClassType, GetPublicID().c_str() );
	ioCharacter *rkChar = GetCharacter( m_select_char );    
	if( rkChar )
	{
		rkPacket << (CHARACTER)rkChar->GetCharInfo();
		rkPacket << GetClassLevelByType( rkChar->GetCharInfo().m_class_type, false );

		for( int j=0; j < MAX_CHAR_DBITEM_SLOT; ++j )
		{
			if( bCurrentEquip )
			{
				rkPacket << rkChar->GetCurrentItemCode(j);
				rkPacket << rkChar->GetCurrentItemReinforce(j);
				rkPacket << rkChar->GetCurrentItemMaleCustom(j);
				rkPacket << rkChar->GetCurrentItemFemaleCustom(j);
			}
			else
			{
				rkPacket << rkChar->GetDBItemData(j)->m_item_code;
				rkPacket << rkChar->GetDBItemData(j)->m_item_reinforce;
				rkPacket << rkChar->GetDBItemData(j)->m_item_male_custom;
				rkPacket << rkChar->GetDBItemData(j)->m_item_female_custom;
			}
		}
	}
}

void User::FillRoomAndUserInfo( SP2Packet &rkPacket )
{
	rkPacket << GetPublicID() << GetGradeLevel() << GetKillDeathLevel();
	rkPacket << m_UserRecord.GetTotalKill() << m_UserRecord.GetTotalDeath();
}

int User::GetUserPos()
{
	bool bTournament = false;
	if( m_pMyRoom && m_pMyRoom->IsTournamentRoom() )
		bTournament = true;

	BattleRoomParent *pBattleRoom = g_BattleRoomManager.GetGlobalBattleRoomNode( m_dwMyBattleRoom );
	if( pBattleRoom && pBattleRoom->GetBattleEventType() == BET_TOURNAMENT_BATTLE )
		bTournament = true;

	if( IsBattleRoom() && !bTournament )
	{
		return UP_BATTLE_ROOM;
	}
	else if( IsBattleRoom() && bTournament )
	{
		return UP_TOURNAMENT;
	}
	else if( IsLadderTeam() )
	{
		return UP_LADDER_TEAM;
	}
	else if( IsShuffleRoom() )
	{
		return UP_SHUFFLE;
	}
	else if( m_pMyRoom )
	{
		if( m_pMyRoom->GetModeType() == MT_HEADQUARTERS )
		{
			return UP_HEADQUARTERS;
		}
		else if( m_pMyRoom->GetModeType() == MT_TRAINING )
		{
			if( m_pMyRoom->GetPlazaModeType() == PT_GUILD )
				return UP_GUILD_HQ;
			else
				return UP_TRAINING;
		}
		else if( m_pMyRoom->GetModeType() == MT_HOUSE )
		{
			return UP_HOUSE;
		}
		else
		{
			return UP_LOBBY;
		}
	}
	else if( IsServerLobby() )
	{
		return UP_LOBBY;
	}

	return UP_LOBBY;
}

void User::BattleRoomKickOut( BYTE eType /* = RoomParent::RLT_NORMAL */ )
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LeaveRoom( eType );
		LeaveBattleRoom();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
	}
	else
	{
		LeaveBattleRoom();
	}	
}

void User::BattleRoomMyInfo()
{
	BattleRoomParent *pMyBattleRoom = GetMyBattleRoom();
	if( pMyBattleRoom )
	{
		pMyBattleRoom->UserInfoUpdate( GetUserIndex(), GetGradeLevel(), GetKillDeathLevel(), IsSafetyLevel(), GetUDP_port(), g_App.GetClientMoveIP(), g_App.GetCSPort() );
	}
}

bool User::IsGuildUser( const ioHashString &rkName )
{
	if( !IsGuild() ) return false;
	return m_UserGuild.IsGuildUser( rkName );
}

void User::LadderTeamKickOut()
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LeaveRoom();
		LeaveLadderTeam();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
	}
	else
	{
		LeaveLadderTeam();
	}
}

void User::LadderTeamMyInfo()
{
	LadderTeamParent *pMyLadderTeam = GetMyLadderTeam();
	if( pMyLadderTeam )
	{
		pMyLadderTeam->UserInfoUpdate( GetUserIndex(), GetGradeLevel(), GetKillDeathLevel(), GetHeroMatchPoint(), GetLadderPoint(), GetGuildIndex(), GetGuildMark(), GetUDP_port(), g_App.GetClientMoveIP(), g_App.GetCSPort() );
	}
}

void User::ShuffleRoomKickOut( BYTE eType /*= (BYTE)RoomParent::RLT_NORMAL */ )
{
	if( m_pMyRoom )
	{
		LeaveRoom( eType );
		LeaveShuffleRoom();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
	}
	else
	{
		LeaveShuffleRoom();
	}
}

void User::ShuffleRoomMyInfo()
{
	ShuffleRoomParent *pMyShuffleRoom = GetMyShuffleRoom();
	if( pMyShuffleRoom )
	{
		pMyShuffleRoom->UserInfoUpdate( GetUserIndex(), GetGradeLevel(), GetKillDeathLevel(), GetUDP_port(), g_App.GetClientMoveIP(), g_App.GetCSPort() );
	}
}

bool User::IsUserShuffleRoomJoin()
{
	//래더팀 예약 or 셔플 예약 체크
	if( IsReserveLadderTeam() )
	{		
		return false;
	}

	//이미 참가 상태
	if( IsShuffleRoom() )
	{
		return false;
	}

	//래더팀 체크
	if( IsLadderTeam() )
	{		
		return false;
	}

	CheckLeaveBattleRoomIndex();

	//서버 이동 예약 체크
	if( IsReserveServerMoving() )
	{		
		return false;
	}
	else if( GetBuyCharCount() == 0 )
	{
		return false;
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		return false;
	}

	return true;
}

void User::UserVoteRoomKickOut( const ioHashString &rkReason )
{
	if( !m_pMyRoom ) return;

	m_dwAbuseQuizLimitTime = 0;

	// 강퇴되었다고 알림
	SP2Packet kPacket( STPK_USER_KICK_VOTE );
	PACKET_GUARD_VOID( kPacket.Write( USER_KICK_VOTE_ADOPTION ) );
	PACKET_GUARD_VOID( kPacket.Write( GetPublicID() ) );
	PACKET_GUARD_VOID( kPacket.Write( m_pMyRoom->GetRoomIndex() ) );
	PACKET_GUARD_VOID( kPacket.Write( rkReason ) );

	SendMessage( kPacket );

	// 강퇴처리
	RoomStyle eRoomStyle = m_pMyRoom->GetRoomStyle();
	LeaveRoom();
	switch( eRoomStyle )
	{
	case RSTYLE_BATTLEROOM:
		LeaveBattleRoom();
		break;
	case RSTYLE_SHUFFLEROOM:
		LeaveShuffleRoom();
		break;
	case RSTYLE_PLAZA:
		break;
	case RSTYLE_LADDERBATTLE:
		LeaveLadderTeam();
		break;
	default:
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::UserVoteRoomKickOut(%s) 알 수없는 룸 스타일 : %d", GetPublicID().c_str(), (int)eRoomStyle );
		break;
	}

	//14.4.9 대규모 이후 EXIT_ROOM_LOBBY를 보내면 클라이언트에서 광장 요청 패킷을 보내고 있음.
	ExitRoomToTraining( EXIT_ROOM_LOBBY, false );
}

void User::SendGradeSync()
{
	SP2Packet kPacket( STPK_GRADE_SYNC );
	kPacket << GetPublicID() << GetGradeLevel() << GetGradeExpRate();
	if( m_pMyRoom )
	{
		// 룸 유저들에게 동기화
		m_pMyRoom->RoomSendPacketTcp( kPacket, this );
	}
	else if( IsBattleRoom() )
	{
		BattleRoomParent *pBattleRoom = GetMyBattleRoom();
		if( pBattleRoom )
			pBattleRoom->SendPacketTcp( kPacket, GetUserIndex() );
	}
	else if( IsLadderTeam() )
	{
		LadderTeamParent *pLadderTeam = GetMyLadderTeam();
		if( pLadderTeam )
			pLadderTeam->SendPacketTcp( kPacket, GetUserIndex() );
	}
}

void User::SyncModeEtcItem( IN IntVec &rvModeEtcItemList, OUT IntVec &rvReturnEtcItem )
{
	int iEtcItemSize = rvModeEtcItemList.size();
	for(int i = 0;i < iEtcItemSize;i++)
	{
		ioUserEtcItem::ETCITEMSLOT kSlot;
		m_UserEtcItem.GetEtcItem( rvModeEtcItemList[i], kSlot );
		if( kSlot.IsUse() )  // 사용중인 아이템만 동기화
		{
			rvReturnEtcItem.push_back( rvModeEtcItemList[i] );
		}
	}
}

void User::SetExperienceChar( SP2Packet &rkPacket )
{
	CHARACTER kExperienceChar;
	rkPacket >> kExperienceChar.m_kindred >> kExperienceChar.m_sex >> kExperienceChar.m_face >> kExperienceChar.m_hair >> kExperienceChar.m_hair_color
		     >> kExperienceChar.m_skin_color >> kExperienceChar.m_beard >> kExperienceChar.m_accessories >> kExperienceChar.m_underwear;

	int i = 0;
	ITEM_DATA kExperienceItem[MAX_CHAR_DBITEM_SLOT];
	for(i = 0;i < MAX_CHAR_DBITEM_SLOT;i++)
	{
		rkPacket >> kExperienceItem[i].m_item_code >> kExperienceItem[i].m_item_reinforce
			     >> kExperienceItem[i].m_item_male_custom >> kExperienceItem[i].m_item_female_custom;
	}

	for ( i = 0; i < MAX_CHAR_COSTUME_SLOT; i++ )
	{
		PACKET_GUARD_VOID( rkPacket.Read(kExperienceChar.m_costume_item[i].m_iCostumeCode) );
	}

	ioCharacter *rkChar = GetCharacter( m_select_char );
	if( rkChar == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "SetExperienceChar : %s None Select Char", GetPublicID().c_str() );
		return;
	}

	if( m_pMyRoom == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "SetExperienceChar : %s None Mode", GetPublicID().c_str() );
		return;
	}

	rkChar->SetExperienceChar( kExperienceChar );
	
	for(i = 0;i < MAX_CHAR_DBITEM_SLOT;i++)
	{
		if( kExperienceItem[i].m_item_code <= 0 ) continue;

		ioItem *pNewItem = m_pMyRoom->CreateItem( kExperienceItem[i], GetPublicID() );
		if( pNewItem == NULL ) continue;

		ioItem *pPreItem = rkChar->EquipItem( i, pNewItem );
		SAFEDELETE( pPreItem );
	}
}

void User::ReceivePacket( CPacket &packet )
{
	g_RecvQueue.InsertQueue( (DWORD)this, packet, PK_QUEUE_SESSION );
}

void User::PacketParsing( CPacket &packet )
{
	FUNCTION_TIME_CHECKER( 500000.0f, packet.GetPacketID() );          // 0.5 초 이상 걸리면로그 남김
	SP2Packet &kPacket = (SP2Packet&)packet;

	if( RoomBroadCast( kPacket ) )
		return;
	if( OnRoomProcessPacket( kPacket ) )
		return;
	if( OnBattleRoomProcessPacket( kPacket ) )
		return;
	if( OnLadderTeamProcessPacket( kPacket ) )
		return;


	switch( packet.GetPacketID() )
	{
	//TCP
	case CTPK_CLOSE_SESSION:
		OnClose( kPacket );
		break;
	case CTPK_CONNECT:            // 첫 접속
		OnConnect( kPacket );//로그인 무조간 보내고 
		break;
	case CTPK_MOVING_SERVER:      // 서버 이동으로 인한 접속
		OnMovingServer( kPacket );//검사해서 보내고 
		break;
	case CTPK_JOIN_SERVER_LOBBY_INFO:
		OnJoinServerLobbyInfo( kPacket );
		break;

	case CTPK_FRIEND_LIST_MSG:	// 쌍방 친구 상태 리스트 요청.
		OnFriendList( kPacket );
		break;
	case CTPK_FRIEND_REQUEST_LIST:	// 친구 등록된 리스트 요청.
		OnFriendRequestList( kPacket );
		break;
	case CTPK_FRIEND_APPLICATION:	// 친구 추가시.
		OnFriendApplication( kPacket );
		break;
	case CTPK_FRIEND_COMMAND:	// 친구 승낙/거절/차단 시
		OnFriendCommand( kPacket );
		break;
	case CTPK_FRIEND_DELETE:	// 친구 삭제시.
		OnFriendDelete( kPacket );
		break;

	case CTPK_DELETE_FRIEND_BY_WEB:
		OnDeleteFriendByWeb( kPacket );
		break;
	case CTPK_INSERT_BESTFRIEND:
		OnBestFriendInsert( kPacket );
		break;
	case CTPK_INSERT_BESTFRIEND_FAILED:
		OnBestFriendInsertFailed( kPacket );
		break;
	case CTPK_DISMISS_BESTFRIEND:
		OnBestFriendDismiss( kPacket );
		break;
	case CTPK_BESTFRIEND_EXCEPTION_LIST:
		OnBestFriendExceptionList( kPacket );
		break;
	case CTPK_USER_LOGIN:
		OnUserLogin( kPacket );
		break;		
	case CTPK_REGISTERED_USER:
		OnRegisteredUser( kPacket );
		break;
	case CTPK_USER_POS_REFRESH:
		OnUserPosRefresh( kPacket );
		break;
	case CTPK_CHAR_CREATE:
		OnCharCreate( kPacket );
		break;
	case CTPK_SERVICE_CHAR:
		OnServiceChar( kPacket );
		break;
	case CTPK_CHAR_DELETE:
		OnCharDelete( kPacket );
		break;
	case CTPK_CHANGE_MY_LEADER:
		OnChangeLeaderChar( kPacket );
		break;
	case CTPK_SET_MY_RENTAL:
		OnSetMyRentalChar( kPacket );
		break;
	case CTPK_JOIN_ROOM:
		OnJoinRoom( kPacket );
		break;
	case CTPK_PICK_ITEM:
		OnPickItem( kPacket );
		break;
	case CTPK_SEARCH_PLAZA_ROOM:
		OnSearchPlazaRoom( kPacket );
		break;
	case CTPK_PLAZA_ROOM_LIST:
		OnPlazaRoomList( kPacket );
		break;
	case CTPK_CREATE_PLAZA:
		OnCreatePlaza( kPacket );
		break;
	case CTPK_PLAZA_COMMAND:
		OnPlazaCommand( kPacket );
		break;
	case CTPK_PLAZA_INVITE_LIST:
		OnPlazaInviteList( kPacket );
		break;
	case CTPK_PLAZA_USER_INVITE:
		OnPlazaInvite( kPacket );
		break;
	case CTPK_HEADQUARTERS_INVITE_LIST:
		OnHeadquartersInviteList( kPacket );
		break;	
	case CTPK_JOIN_HEADQUARTERS:
		OnJoinHeadquarters( kPacket );
		break;
	case CTPK_HEADQUARTERS_INFO:
		OnHeadquartersInfo( kPacket );
		break;
	case CTPK_HEADQUARTERS_JOIN_AGREE:
		OnHeadquartersJoinAgree( kPacket );
		break;
	case CTPK_CHANGE_CHAR:
		OnChangeChar( kPacket );
		break;
	case CTPK_USE_ITEM:
		OnUseItem( kPacket );
		break;
	case CTPK_BUY_ITEM:
		OnBuyItem( kPacket );
		break;
	case CTPK_EQUIP_SLOT_ITEM:
		OnEquipItem( kPacket );		
		break;
	case CTPK_INC_STAT:
		OnIncreaseStat( kPacket );
		break;
	case CTPK_INIT_STAT:
		OnInitStat( kPacket );
		break;
	case CTPK_LEVELUP_ITEM:
		OnLevelUpItem( kPacket );
		break;
	case CTPK_ABSTRACT:
		OnAbstract( kPacket );
		break;
	case CTPK_JOIN_BATTLEROOM_LIST:
		OnJoinBattleRoomList( kPacket );
		break;
	case CTPK_CREATE_BATTLEROOM:
		OnCreateBattleRoom( kPacket );
		break;
	case CTPK_USER_BATTLEROOM_JOIN:
		OnUserBattleRoomJoin( kPacket );
		break;
	case CTPK_RESERVE_BATTLEROOM_DELETE:
		OnBattleRoomReserveDelete( kPacket );
		break;
	case CTPK_USER_BATTLEROOM_LEAVE:
		OnUserBattleRoomLeave( kPacket );
		break;
	case CTPK_CHAR_SLOT_CHANGE:
		OnCharSlotChange( kPacket );
		break;
	case CTPK_TUTORIAL_STEP:
		OnTutorialStep( kPacket );
		break;
	case CTPK_CHAR_LIMIT_CHECK:
		OnCharLimitCheck( kPacket );
		break;
	case CTPK_CHAR_DECORATION_BUY:
		OnCharDecorationBuy( kPacket );
 		break;
	case CTPK_CHAR_EXTEND:
		OnCharExtend( kPacket );
		break;
	case CTPK_CHAR_CHARGE:
		OnCharCharge( kPacket );
		break;
	case CTPK_CHAR_CHANGE_PERIOD:
		OnCharChangePeriod( kPacket );
		break;
	case CTPK_CHANGE_SINGLE_CHAR:
		OnChangeSingleChar( kPacket );
		break;
	case CTPK_RELAY_CHAT:
		OnRelayChat( kPacket );
		break;
	case CTPK_BATTLEROOM_JOIN_INFO:
		OnBattleRoomInfo( kPacket );
		break;
	case CTPK_SERVER_LOBBY_CHAT:
		OnServerLobbyChat( kPacket );
		break;
	case CTPK_MYROOM_SERVER_CHANGE:
		OnMyRoomServerChange( kPacket );
		break;
	case CTPK_PLAZA_JOIN_INFO:
		OnPlazaRoomInfo( kPacket );
		break;
	case CTPK_TRIAL:
		OnTrial( kPacket );
		break;
	case CTPK_LOGOUT:
		OnLogOut( kPacket );
		break;
	case CTPK_ETCITEM_BUY:
		OnEtcItemBuy( kPacket );
		break;
	case CTPK_ETCITEM_USE:
		OnEtcItemUse( kPacket );
		break;
	case CTPK_ETCITEM_MOTION_OPTION:
		OnEtcItemMotionOption( kPacket );
		break;
	case CTPK_ETCITEM_SELL:
		OnEtcItemSell( kPacket );
		break;
	case CTPK_GROWTH_LEVEL_UP:
		OnGrowthLevelUp( kPacket );
		break;
	case CTPK_GROWTH_LEVEL_INIT:
		OnGrowthLevelInit( kPacket );
		break;
	case CTPK_ETCITEM_ACTION:
		OnEtcItemAction( kPacket );
		break;
	case CTPK_ETCITEM_SWITCH:
		OnEtcItemSwitch( kPacket );
		break;
	case CTPK_FISHING:
		OnFishingState( kPacket );
		break;
	case CTPK_EXTRAITEM_BUY:
		OnExtraItemBuy( kPacket );
		break;
	case CTPK_EXTRAITEM_CHANGE:
		OnExtraItemChange( kPacket );
		break;
	case CTPK_EXTRAITEM_SELL:
		OnExtraItemSell( kPacket );
		break;
	case CTPK_MEDALITEM_SELL:
		OnMedalItemSell( kPacket );
		break;
	case CTPK_PRESENT_BUY:
		OnPresentBuy( kPacket );
		break;
	case CTPK_ALL_ITEM_DROP:
		OnAllItemDrop( kPacket );
		break;
	case CTPK_CHANGE_GANGSI:
		OnChangeGangsi( kPacket );
		break;
	case CTPK_GASHAPON_LIST:
		OnGashaponList( kPacket );
		break;
	case CTPK_EXCAVATION_COMMAND:
		OnExcavationCommand( kPacket );
		break;
	case CTPK_CONTROL_KEYS:
		OnControlKeys( kPacket );
		break;
	case CTPK_MEDALITEM_CHANGE:
		OnMedalItemChange( kPacket );
		break;
	case CTPK_ROULETTE:
		OnRouletteState( kPacket );
		break;
	case CTPK_SUBSCRIPTION_BUY:
		OnSubscriptionBuy( kPacket );
		break;
	case CTPK_SUBSCRIPTION_RECV:
		OnSubscriptionRecv( kPacket );
		break;
	case CTPK_SUBSCRIPTION_RETR_CHECK:
		OnSubscriptionRetrCheck( kPacket );
		break;
	case CTPK_SUBSCRIPTION_RETR:
		OnSubscriptionRetr( kPacket );
		break;
	case CTPK_SUBSCRIPTION_REQUEST:
		OnSubscriptionRequest( kPacket );
		break;
	case CTPK_SHUFFLEROOM_JOIN:
		OnUserShuffleRoomJoin( kPacket );
		break;
	case CTPK_SHUFFLEROOM_JOIN_CANCEL:
		OnUserShuffleRoomJoinCancel( kPacket );
		break;	
	//채널
	case CTPK_CHANNEL_CREATE:
		OnChannelCreate( kPacket );
		break;
	case CTPK_CHANNEL_INVITE:
		OnChannelInvite( kPacket );
		break;
	case CTPK_CHANNEL_LEAVE:
		OnChannelLeave( kPacket );
		break;
	case CTPK_CHANNEL_CHAT:
		OnChannelChat( kPacket );
		break;
	case CTPK_USER_INFO_REFRESH:
		OnUserInfoRefresh( kPacket );
		break;
	case CTPK_SIMPLE_USER_INFO_REFRESH:
		OnSimpleUserInfoRefresh( kPacket );
		break;
	case CTPK_USER_CHAR_INFO_REFRESH:
		OnUserCharInfoRefresh( kPacket );
		break;
	case CTPK_USER_CHAR_SUB_INFO_REFRESH:
		OnUserCharSubInfoRefresh( kPacket );
		break;
		
	//
	case CTPK_USER_CHAR_RENTAL_REQUEST:
		OnUserCharRentalRequest( kPacket );
		break;
	case CTPK_USER_CHAR_RENTAL_AGREE:
		OnUserCharRentalAgree( kPacket );
		break;
	case CTPK_USER_CHAR_RENTAL_TIME_END:
		OnUserCharRentalTimeEnd( kPacket );
		break;

		//UDP
	case CUPK_CONNECT:
		OnUDPConnect( kPacket );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "UDP:%s(%s:%d:%s)", GetPublicID().c_str() , m_public_ip, m_client_port, m_private_ip );
		break;
	case CUPK_SYNCTIME:
		OnSyncTime( kPacket );
		break;
	case CUPK_RESERVE_ROOM_JOIN:
		OnReserveRoomJoin( kPacket );
		break;
	case CUPK_CHECK_KING_PING:
		OnCheckKingUserPing( kPacket );
		break;
	case WUPK_EVENT:
		OnWebEvent( kPacket );
		break;
	case WUPK_REFRESH_BLOCK:
		OnWebRefreshBlock( kPacket );
		break;
	case WUPK_GET_CASH:
		OnWebGetCash( kPacket );
		break;
	case WUPK_REFRESH_USER_ENTRY:
		OnWebRefreshUserEntry( kPacket );
		break;
	//
	case CTPK_HACK_QUIZ:
		OnHackQuiz( kPacket );
		break;
	case CTPK_ABUSE_QUIZ_START:
		OnAbuseQuizStart( kPacket );
		break;
	case CTPK_ABUSE_QUIZ:
		OnAbuseQuiz( kPacket );
		break;
	case CTPK_FOLLOW_USER:
		OnFollowUser( kPacket );
		break;
	case CTPK_USER_POS_INDEX:
		OnUserPosIndex( kPacket );
		break;
	case CTPK_DEVELOPER_MACRO:
		OnDeveloperMacro( kPacket );
		break;
	case CTPK_EXERCISE_CHAR_CREATE:
		OnExerciseCharCreate( kPacket );
		break;
	case CTPK_BATTLEROOM_INVITE_LIST:
		OnBattleRoomInviteList( kPacket );
		break;
	case CTPK_MEMO_SEND_MSG:
		OnMemoMsg( kPacket );
		break;
	case CTPK_OFFLINE_MEMO_MSG:
		OnOfflineMemoList( kPacket );
		break;
	case CTPK_BANKRUPTCY_PESO:
		OnBankruptcyPeso( kPacket );
		break;
	case CTPK_FIRST_CHANGE_ID:
		OnFirstChangeID( kPacket );
		break;
	case CTPK_PRESENT_TEST_SEND:
		OnPresentTestSend( kPacket );
		break;

	//길드
	case CTPK_GUILD_RANK_LIST:
		OnGuildRankList( kPacket );
		break;
	case CTPK_GUILD_INFO:
		OnGuildInfo( kPacket );
		break;
	case CTPK_GUILD_USER_LIST:
		OnGuildUserList( kPacket );
		break;
	case CTPK_GUILD_JOINER_CHANGE:
		OnGuildJoinerChange( kPacket );
		break;
	case CTPK_GUILD_ENTRY_APP:
		OnGuildEntryApp( kPacket );
		break;
	case CTPK_GUILD_ENTRY_CANCEL:
		OnGuildEntryCancel( kPacket );
		break;
	case CTPK_GUILD_ENTRY_DELAY_MEMBER:
		OnGuildEntryDelayMember( kPacket );
		break;
	case CTPK_GUILD_ENTRY_AGREE:
		OnGuildEntryAgree( kPacket );
		break;
	case CTPK_GUILD_ENTRY_REFUSE:
		OnGuildEntryRefuse( kPacket );
		break;
	case CTPK_GUILD_INVITATION:
		OnGuildInvitation( kPacket );
		break;
	case CTPK_GUILD_LEAVE:
		OnGuildLeave( kPacket );
		break;
	case CTPK_GUILD_TITLE_CHANGE:
		OnGuildTitleChange( kPacket );
		break;
	case CTPK_GUILD_MASTER_CHANGE:
		OnGuildMasterChange( kPacket );
		break;
	case CTPK_GUILD_POSITION_CHANGE:
		OnGuildPositionChange( kPacket );
		break;
	case CTPK_GUILD_KICK_OUT:
		OnGuildKickOut( kPacket );
		break;
	case CTPK_USER_ENTRY_REFRESH:
		OnUserEntryRefresh( kPacket );
		break;
	case CTPK_GUILD_CHAT:
		OnGuildChat( kPacket );
		break;
	case CTPK_GUILD_MARK_KEY_VALUE:
		OnGuildMarkChangeKeyValue( kPacket );
		break;
	case CTPK_GUILD_MARK_KEY_VALUE_DELETE:
		OnGuildMarkChangeKeyValueDelete( kPacket );
		break;
	case CTPK_GUILD_TITLE_SYNC:
		OnGuildTitleSync( kPacket );
		break;
	case CTPK_GUILD_EXIST:
		OnGuildExist( kPacket );
		break;
	case CTPK_USER_INFO_EXIST:
		OnUserInfoExist( kPacket );
		break;
	case CTPK_VOICE_INFO:
	case CTPK_VOICE_INFO_USER:
		OnVoiceInfo( kPacket );
		break;
	case CTPK_LADDER_TEAM_LIST:
		OnLadderTeamList( kPacket );
		break;
	case CTPK_CREATE_LADDERTEAM:
		OnCreateLadderTeam( kPacket );
		break;
	case CTPK_JOIN_LADDERTEAM:
		OnJoinLadderTeam( kPacket );
		break;
	case CTPK_LADDERTEAM_JOIN_INFO:
		OnLadderTeamJoinInfo( kPacket );
		break;
	case CTPK_LADDERTEAM_LEAVE:
		OnLadderTeamLeave( kPacket );
		break;
	case CTPK_LADDERTEAM_INVITE_LIST:
		OnLadderTeamInviteList( kPacket );
		break;
	case CTPK_LADDER_OTHER_NAME_CHANGE:
		OnLadderOtherTeamNameChange( kPacket );
		break;
	case CTPK_LADDER_BATTLE_REQUEST_AGREE:
		OnLadderBattleRequestAgree( kPacket );
		break;
	case CTPK_LADDER_USER_HQ_MOVE:
		OnLadderUserHQMove( kPacket );
		break;
	case CTPK_LADDER_TEAM_RANKING:
		OnLadderTeamRanking( kPacket );
		break;
	case CTPK_LADDER_TEAM_RANK_LIST:
		OnLadderTeamRankList( kPacket );
		break;
	case CTPK_MOVIE_CONTROL:
		OnMovieControl( kPacket );
		break;
	case CTPK_PRESENT_REQUEST:
		OnPresentRequest( kPacket );
		break;
	case CTPK_PRESENT_RECV:
		OnPresentRecv( kPacket );
		break;
	case CTPK_PRESENT_SELL:
		OnPresentSell( kPacket );
		break;
	case CTPK_PROTECT_CHECK:
		OnProtectCheck( kPacket );
		break;
	case CTPK_GET_CASH:
		OnGetCash( kPacket );
		break;
	case CTPK_HOLE_SEND_COMPLETE:
		OnHoleSendComplete( kPacket );
		break;
	case CTPK_UDP_RECV_TIMEOUT:
		OnUDPRecvTimeOut( kPacket );
		break;
	case CTPK_EVENT_DATA_UPDATE:
		OnEventDataUpdate( kPacket );
		break;
	case CTPK_SERVER_LOBBY_INFO:
		OnServerLobbyInfo( kPacket );
		break;
	case CTPK_CAMP_DATA_SYNC:
		OnCampDataSync( kPacket );
		break;
	case CTPK_CAMP_CAHNGE_POS:
		OnCampChangePos( kPacket );
		break;
	case CTPK_CAMP_BATTLE_END_LEAVE_TEAM:
		OnCampBattleEndLeaveTeam( kPacket );
		break;
	case CTPK_SERVER_ALARM_MSG:
		OnServerAlarmMsg( kPacket );
		break;
	case CTPK_TIME_GROWTH_ADD:
		OnAddTimeGrowth( kPacket );
		break;
	case CTPK_TIME_GROWTH_REMOVE:
		OnRemoveTimeGrowth( kPacket );
		break;
	case CTPK_TIME_GROWTH_CHECK:
		OnCheckTimeGrowth( kPacket );
		break;
	case CTPK_QUEST_OCCUR:
		OnQuestOccur( kPacket );
		break;
	case CTPK_QUEST_ATTAIN:
		OnQuestAttain( kPacket );
		break;
	case CTPK_QUEST_ALARM:
		OnQuestAlarm( kPacket );
		break;
	case CTPK_QUEST_REWARD:
		OnQuestReward( kPacket );
		break;
	case CTPK_QUEST_ALL_DELETE:
		OnQuestAllDelete( kPacket );
		break;
	case CTPK_PRESENT_ALL_DELETE:
		OnPresentAllDelete( kPacket );
		break;
	case CTPK_HERO_TOP100_DATA:
		OnHeroTop100Data( kPacket );
		break;
	case CTPK_HERO_MATCH_OTHER_INFO:
		OnHeroMatchOtherInfo( kPacket );
		break;
	// 거래소
	case CTPK_TRADE_CREATE:
		OnTradeCreate( kPacket );
		break;
	case CTPK_TRADE_LIST:
		OnTradeList( kPacket );
		break;
	case CTPK_TRADE_ITEM:
		OnTradeItem( kPacket );
		break;
	case CTPK_TRADE_CANCEL:
		OnTradeCancel( kPacket );
		break;
	// 이벤트 상점
	case CTPK_EVENT_SHOP_GOODS_LIST:
		OnEventShopGoodsList( kPacket );
		break;
	case CTPK_EVENT_SHOP_GOODS_BUY:
		OnEventShopGoodsBuy( kPacket );
		break;
	case CTPK_EVENT_SHOP_STATE:
		OnEventShopState( kPacket );
		break;
	case CTPK_EVENT_SHOP_BUY_USER_CLEAR:
		OnEventShopBuyUserClear( kPacket );
		break;
	// AutoUpgrade
	case ASTPK_OTHER_COMPANY_LOGIN_REQUEST:
		OnAutoUpgradeLogin( kPacket ); 
		break;
	case ASTPK_OTHER_COMPANY_OTP_REQUEST:
		OnAutoUpgradeOTP( kPacket );
		break;
    //
	case CTPK_ROOM_STEALTH_ENTER:
		OnRoomStealthEnter( kPacket );
		break;
	case CTPK_CAMP_SEASON_BONUS:
		OnCampSeasonBonus( kPacket );
		break;
	case CTPK_CUSTOM_ITEM_SKIN_UNIQUE_INDEX:
		OnCustomItemSkinUniqueIndex( kPacket );
		break;
	case CTPK_CUSTOM_COSTUME_SKIN_UNIQUE_INDEX:
		OnCustomCostumeSkinUniqueIndex( kPacket );
		break;
	case CTPK_CUSTOM_ITEM_SKIN_DELETE:
		OnCustomItemSkinDelete( kPacket );
		break;
	case CTPK_CUSTOM_COSTUME_SKIN_DELETE:
		OnCustomCostumeSkinDelete( kPacket );
		break;
	case CTPK_HEADQUARTERS_OPTION_CMD:
		OnHeadquartersOptionCmd( kPacket );
		break;
	case CTPK_HEADQUARTERS_COMMAND:
		OnHeadquartersCommand( kPacket );
		break;
	case CTPK_GET_MILEAGE:
		OnGetMileage( kPacket );
		break;
	case CTPK_DISCONNECT_ALREADY_ID:
		OnDisconnectAlreadyID( kPacket );
		break;
	case CTPK_PCINFO:
		OnPCInfo( kPacket );
		break;
	case CTPK_CHECK_BASE_VALUE:
		//OnCheckBaseValue( kPacket );
		break;
	case CTPK_SHUTDOWN_DATE:
		OnShutdownDate( kPacket );
		break;
	// alchemic
	case CTPK_ALCHEMIC_FUNC:
		OnAlchemicFunc( kPacket );
		break;
	case CTPK_EXTRAITEM_DISASSEMBLE:
		OnExtraItemDisassemble( kPacket );
		break;
	case CTPK_SOLDIER_DISASSEMBLE:
		OnCharDisassemble( kPacket );
		break;
	case CTPK_BUY_SELECT_EXTRA_GASHAPON:
		OnBuySelectExtraGashapon( kPacket );
		break;

	//
	case CTPK_TOURNAMENT_REQUEST:
		OnTournamentRegularRequest( kPacket );
		break;
	case CTPK_TOURNAMENT_MAIN_INFO:
		OnTournamentMainInfo( kPacket );
		break;
	case CTPK_TOURNAMENT_LIST_REQUEST:
		OnTournamentListRequest( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_CREATE:
		OnTournamentTeamCreate( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_INFO:
		OnTournamentTeamInfo( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_USER_LIST:
		OnTournamentTeamUserList( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_INVITATION:
		OnTournamentTeamInvitation( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_ENTRY_MEMBER:
		OnTournamentTeamEntryDelayMember( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_ENTRY_APP:
		OnTournamentTeamEntryApp( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_ENTRY_REFUSE:
		OnTournamentTeamEntryRefuse( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_ENTRY_AGREE:
		OnTournamentTeamEntryAgree( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_LEAVE:
		OnTournamentTeamLeave( kPacket );
		break;
	case CTPK_TOURNAMENT_SCHEDULE_INFO:
		OnTournamentScheduleInfo( kPacket );
		break;
	case CTPK_TOURNAMENT_ROUND_TEAM_DATA:
		OnTournamentRoundTeamData( kPacket );
		break;
	case CTPK_TOURNAMENT_ROOM_LIST:
		OnTournamentRoomList( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_ALLOCATE_LIST:
		OnTournamentTeamAllocateList( kPacket );
		break;
	case CTPK_TOURNAMENT_TEAM_ALLOCATE_DATA:
		OnTournamentTeamAllocateData( kPacket );
		break;
	case CTPK_TOURNAMENT_JOIN_CONFIRM_CHECK:
		OnTournamentJoinConfirmCheck( kPacket );
		break;
	case CTPK_TOURNAMENT_JOIN_CONFIRM_REQUEST:
		OnTournamentJoinConfirmRequest( kPacket );
		break;
	case CTPK_TOURNAMENT_JOIN_CONFIRM_COMMAND:
		OnTournamentJoinConfirmCommand( kPacket );
		break;
	case CTPK_TOURNAMENT_ANNOUNCE_CHANGE:
		OnTournamentAnnounceChange( kPacket );
		break;
	case CTPK_TOURNAMENT_TOTAL_TEAM_LIST:
		OnTournamentTotalTeamList( kPacket );
		break;
	case CTPK_TOURNAMENT_CUSTOM_STATE_START:
		OnTournamentCustomStateStart( kPacket );
		break;
	case CTPK_TOURNAMENT_CUSTOM_REWARD_LIST:
		OnTournamentCustomRewardList( kPacket );
		break;
	case CTPK_TOURNAMENT_CUSTOM_REWARD_BUY:
		OnTournamentCustomRewardBuy( kPacket );
		break;

	case CTPK_GIFTCLOVER_CHARGE:
		OnCloverChargeReq( kPacket );
		break;
	case CTPK_GIFTCLOVER_SEND:
		OnCloverSendReq( kPacket );
		break;
	case CTPK_CLOVER_RECEIVE:
		OnCloverReceiveReq( kPacket );
		break;
	case CTPK_CLOVER_RECEIVE_DELETE:
		OnCloverReceiveDelete( kPacket );
		break;

		// 빙고
	case CTPK_BINGO_START:
		OnBingoStart( kPacket );
		break;
	case CTPK_BINGO_NUMBER_INIT:
		OnBingoNumberInitialize( kPacket );
		break;
	case CTPK_BINGO_ALL_INIT:
		OnBingoALLInitialize( kPacket );
		break;

	case CTPK_FILL_CASH_URL:
		OnFillCashUrl( kPacket );
		break;
	case CTPK_TOURNAMENT_CHEER_DECISION:
		OnTournamentCheerDecision( kPacket ); 
		break;
	case CTPK_EXERCISE_PCROOM_CHAR_CREATE:
		OnPcRoomCharCreate( kPacket );	
		break;
	case CTPK_ATTENDANCE_CHECK:
		OnAttedanceCheck( kPacket );
		break;
	case CTPK_BUY_SELECT_GASHAPON:
		OnBuySelectGashapon( kPacket );
		break;
	case CTPK_PET_CHANGE:
		OnPetChange( kPacket );
		break;
	case CTPK_PET_SELL:
		OnPetSell( kPacket );
		break;
	case CTPK_PET_NURTURE:
		OnPetNurture( kPacket );
		break;
	case CTPK_PET_COMPOUND:
		OnPetComPound( kPacket );
		break;
	case CTPK_PET_EQUIP_INFO:
		OnPetEquipInfo( kPacket );
		break;
	case CTPK_CHAR_AWAKE:
		OnCharAwake( kPacket );
		break;
	case CTPK_CHAR_AWAKE_EXTEND:
		OnCharAwakeExtend( kPacket );
		break;
	case CTPK_PLAYING_USERDATA_INFO:
		OnPlayingUserDataInfo( kPacket );
		break;
//HRYOON 20150102 태국 토큰 복호화 결과 전달
	case CTPK_TH_GA_ID_REQ :
		{
			LOG.PrintTimeAndLog( 0, "TEMPLOG-Receive GA_ID_REQ" );
			OnThailandTokenDecodeReq( kPacket );
			break;

		}

	case CTPK_EXIT_ROOM:
		{
			LeaveAllRoom();
			SP2Packet kPacket(STPK_EXIT_ROOM);
			PACKET_GUARD_VOID(kPacket.Write(EXIT_ROOM_OK));
			PACKET_GUARD_VOID(kPacket.Write(-1));
			PACKET_GUARD_VOID(kPacket.Write(false));
			SendMessage( kPacket );

			//LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][ctpk_exist_room] room is not exist : %d : %d:%d:%d", GetUserIndex(), IsBattleRoom(), IsShuffleRoom(), IsLadderTeam() );
		}
		break;
	case CTPK_COSTUME_BUY:
		OnCostumeBuy( kPacket );
		break;
	case CTPK_COSTUME_SELL:
		OnCostumeSell( kPacket );
		break;
	case CTPK_COSTUME_CHANGE:
		OnCostumeChange( kPacket );
		break;
	case CTPK_COSTUME_DISASSEMBLE:
		OnCostumeDisassemble( kPacket );
		break;
	case CTPK_SPECIAL_SHOP_GOODS_LIST:
		OnSpecialShopGoodsList( kPacket );
		break;
	case CTPK_MISSION_INFO:
		OnMissionInfoRequest( kPacket );
		break;
	case CTPK_MISSION_COMPENSATION_RECV:
		OnMissionCompensationRecv( kPacket );
		break;
	case CTPK_MISSION_TIME_CHECK:
		OnMissionTimeCheck( kPacket );
		break;
	case CTPK_ROLLBOOK_RENEWAL:
		OnRollBookRenewal( kPacket );
		break;
	case CTPK_GUILD_ATTEND:
		OnGuildAttend( kPacket );
		break;
	case CTPK_RECV_GUILDATTEND_REWARD:
		OnRecvGuildAttendReward( kPacket );
		break;
	case CTPK_GUILD_MEMBER_ATTEND_RENEWAL:
		OnRenewalGuildMemberAttendInfo(kPacket);
		break;
	case CTPK_POPUP_ITEM_BUY:
		OnPopupItemBuy( kPacket );
		break;
	case CTPK_ENTER_GUILD_ROOM:
		OnEnterGuildRoom( kPacket );
		break;
	case CTPK_CONSTRUCT_BLOCK:
		OnConstructBlock( kPacket );
		break;
	case CTPK_RETRIEVE_BLOCK:
		OnRetrieveBlock( kPacket );
		break;
	case CTPK_CONSTRUCT_MODE:
		OnConstructMode( kPacket );
		break;
	case CTPK_REQUEST_GUILD_INVEN:
		OnSendGuildInvenInfo( kPacket );
		break;
	case CTPK_JOIN_PERSONAL_HQ:
		OnJoinPersonalHQ( kPacket );
		break;
	case CTPK_PERSONAL_HQ_INVITE_LIST:
		OnPersonalHQInviteList( kPacket );
		break;
	case CTPK_PERSONAL_HQ_JOIN_AGREE:
		OnPersonalHQJoinAgree( kPacket );
		break;
	case CTPK_PERSONAL_HQ_INFO:
		OnPersonalHQInfo( kPacket );
		break;
	case CTPK_PERSONAL_HQ_COMMAND:
		OnPersonalHQCommand( kPacket );
		break;
	case CTPK_PERSONAL_HQ_INVEN_DATA:
		OnReqPersonalHQInvenData( kPacket );
		break;
	case CTPK_BUY_RISING_GASHAPON:
		OnBuyRisingGashapon( kPacket );
		break;
	case CTPK_INIT_RISING_GASHAPON:
		OnInitRisingGashapon( kPacket );
		break;
	case CTPK_SEARCH_ROOM : 
		OnSearchRoom( kPacket );
		break;
	case CTPK_JOIN_LADDERROOM_LIST :
		OnJoinLadderRoomList( kPacket );
		break;
	case CTPK_LADDERROOM_JOIN_INFO :
		OnLadderRoomInfo( kPacket );
		break;
	case CTPK_LADDERROOM_OBSERVER:
		OnLadderRoomObserverJoin( kPacket );
		break;
	case CTPK_TITLE_CHANGE:
		OnTitleChange( kPacket );
		break;
	case CTPK_TITLE_SYNC_EQUIP_TIME:
		OnSyncTimeEquipTitle( kPacket );
		break;
	case CTPK_NEW_TITLE_CONFIRM:
		OnNewTitleConfirm( kPacket );
		break;
	case CTPK_OAK_INFO_REQUEST:
		{
			OnPirateRouletteInfoRequest( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info] CTPK_OAK_INFO_REQUEST");
		}
		break;
	case CTPK_OAK_USE_SWORD:
		{
			OnPirateRouletteUseSwordRequest( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info] CTPK_OAK_USE_SWORD");
		}
		break;
	case CTPK_OAK_RESET:
		{
			OnPirateRouletteResetRequest( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info] CTPK_OAK_RESET");
		}
		break;

	case CTPK_TRADE_LIST_REQ:
		ReqTradeItemList( kPacket );
		break;
	case CTPK_ACCESSORY_CHANGE:
		OnAccessoryChange( kPacket );
		break;
	case CTPK_ACCESSORY_SELL:
		OnAccessorySell( kPacket );
		break;
	default:
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "0x%x Unknown CPacket ",  kPacket.GetPacketID() );
		break;
	}
}

void User::OnClose(SP2Packet &packet)
{
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnClose:privateID : %s", GetPrivateID().c_str() );

	SendUserLogOut();

	if( !IsDisconnectState() )
	{
		OnDestroy();
		if( IsSessionDestroySave() )
		{
			SendFriendAndGuildUserLogOut();		
		}

		g_UserNodeManager.RemoveNode( this );
		OnSessionDestroy();	         //접속 종료 저장 및 노드 초기화( 서버 이동한 유저는 초기화만하고 저장하지 않는다. )	
	}
}

void User::OnConnect(SP2Packet &packet)
{
	// 게임서버 종료 처리 중
	if(g_App.IsReserveLogOut())
	{
		SP2Packet kPacket( STPK_CONNECT );
	 
		PACKET_GUARD_VOID( kPacket.Write(CONNECT_EXITING_SERVER));
		PACKET_GUARD_VOID( kPacket.Write("") );

		SendMessage( kPacket ); 
		return;
	}

	if( g_UserNodeManager.GetNodeSize() > g_UserNodeManager.GetMaxConnection() )
	{
		SP2Packet kPacket( STPK_CONNECT );

		PACKET_GUARD_VOID( kPacket.Write(CONNECT_GAMESERVER_FULL) );
		PACKET_GUARD_VOID( kPacket.Write("") );

		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s | Gameserver is full.", __FUNCTION__ );
		return;
	}
	
	ioHashString szEncLoginKeyAndID, szPrivateIP;
	int iUserClientVersion = 0;
	int iLocalVersion      = 0;

	PACKET_GUARD_VOID( packet.Read(szEncLoginKeyAndID) );		//id 값이어야..
	PACKET_GUARD_VOID( packet.Read(szPrivateIP) );
	PACKET_GUARD_VOID( packet.Read(iUserClientVersion) );
	PACKET_GUARD_VOID( packet.Read(iLocalVersion) );
	 
	char peerIP[64];
	int peerPort;
	CConnectNode::GetPeerIP( peerIP, sizeof(peerIP), peerPort );

	//IP 체크
	if( !g_IPBlock.CheckWhiteList(peerIP) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s | IP is not whitelistIP.", __FUNCTION__ );

		SP2Packet kPacket( STPK_CONNECT );
		PACKET_GUARD_VOID( kPacket.Write(CONNECT_BLOCK_IP) );
		PACKET_GUARD_VOID( kPacket.Write("") );
		SendMessage( kPacket );

		return;
	}

	if( g_IPBlock.CheckBlackList(peerIP) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s | IP is blacklistIP.", __FUNCTION__ );

		SP2Packet kPacket( STPK_CONNECT );
		PACKET_GUARD_VOID( kPacket.Write(CONNECT_BLOCK_IP) );
		PACKET_GUARD_VOID( kPacket.Write("") );
		SendMessage( kPacket );

		return;
	}

	if( ioLocalManager::GetLocalType() != ioLocalManager::LCT_US )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnConnect-%s-%s(%s)-%s-%s-%d userType:%d", szEncLoginKeyAndID.c_str(), szPrivateIP.c_str(), peerIP
			,g_App.GetSecondKey().c_str(), GetGUID().c_str(), iLocalVersion, GetUSMemberType() );
	}
	else
	{
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnConnect-%s-%s(%s)-%s-%s-%d", szEncLoginKeyAndID.c_str(), szPrivateIP.c_str(), peerIP
		                 ,g_App.GetSecondKey().c_str(), GetGUID().c_str(), iLocalVersion );
	}


	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( !pLocal )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"CLogin::OnConnect - pLocal == NULL. %d", (int) ioLocalManager::GetLocalType() );

		SP2Packet kPacket( STPK_CONNECT );

		PACKET_GUARD_VOID( kPacket.Write(CONNECT_EXCEPT) );
		PACKET_GUARD_VOID( kPacket.Write("") );

		SendMessage( kPacket );

		m_sync_time = TIMEGETTIME();
		return;
	}

	ioHashString sPrivateID;
	char szLoginKey[MAX_PATH]="";

	if( pLocal->IsDecryptID() )
	{
		char szDecryptID[DATA_LEN]="";
		if(!pLocal->ParseLoginData( szEncLoginKeyAndID, szLoginKey, sizeof( szLoginKey ), szDecryptID, sizeof( szDecryptID ) ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"CLogin::OnConnect - ParseLoginData() - false :%s",szPrivateIP.c_str());
			SP2Packet kPacket( STPK_CONNECT );

			PACKET_GUARD_VOID( kPacket.Write(CONNECT_EXCEPT) );
			PACKET_GUARD_VOID( kPacket.Write("") );

			SendMessage( kPacket );

			m_sync_time = TIMEGETTIME();
			return;
		}

		sPrivateID = szDecryptID;
	}
	else
	{
#ifdef HRYOON_T
		if( ioLocalManager::GetLocalType() != ioLocalManager::LCT_THAILAND )
#endif
		{
			if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND/* ||
				ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN*/ )
			{
				// youngdie, GUID로 대체
				sPrivateID = m_szGUID; 
			}
			else 
				sPrivateID = szEncLoginKeyAndID;

		}

	}

#ifdef _ITEST
	sPrivateID = szEncLoginKeyAndID;
#endif

	if( pLocal->IsPrivateLowerID() )
	{
		sPrivateID.MakeLower();
	}

	if( !pLocal->IsRightID( sPrivateID.c_str() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - Wrong ID :%s", __FUNCTION__, sPrivateID.c_str());
		SP2Packet kPacket( STPK_CONNECT );

		PACKET_GUARD_VOID( kPacket.Write(CONNECT_ID_NOT) );
		PACKET_GUARD_VOID( kPacket.Write(sPrivateID) );

		SendMessage( kPacket );

		m_sync_time = TIMEGETTIME();
		return;
	}

	SAFEDELETE(m_pEncLoginKey);
	m_pEncLoginKey = new ioHashString;
	*m_pEncLoginKey = szLoginKey;

#ifndef _ITEST
	if( iLocalVersion != ioLocalManager::GetLocalType() )
	{
		if( ioLocalManager::GetLocalType() != ioLocalManager::LCT_EU )
		{
		SP2Packet kPacket( STPK_CONNECT );

		PACKET_GUARD_VOID( kPacket.Write(CONNECT_WRONG_LOCAL_VER) );
		PACKET_GUARD_VOID( kPacket.Write(sPrivateID) );

		SendMessage( kPacket );

		SAFEDELETE(m_pEncLoginKey);
		m_sync_time = TIMEGETTIME();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong local ver : %s : %d", __FUNCTION__, sPrivateID.c_str(), iLocalVersion );
		return;
	}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s LCT_EU local ver : %s : %d", __FUNCTION__, sPrivateID.c_str(), iLocalVersion );
		}
	}


	if( !g_MainServer.IsRightClientVersion( iUserClientVersion ) )
	{
		SP2Packet kPacket( STPK_CONNECT );

		PACKET_GUARD_VOID( kPacket.Write(CONNECT_WRONG_CLIENT_VER) );
		PACKET_GUARD_VOID( kPacket.Write(sPrivateID) );
	 
		SendMessage( kPacket );

		SAFEDELETE(m_pEncLoginKey);
		m_sync_time = TIMEGETTIME();
		return;
	}
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s IsRightClientVersion Succestt %d", __FUNCTION__, iUserClientVersion );	//나중에 삭제


	// jal : 인도네시아 클라이언트 revision 9714 이전 버전은 실행되지 않도록 .. 하드코딩이라 ㅈㅅ
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_INDONESIA ||
		ioLocalManager::GetLocalType() == ioLocalManager::LCT_SINGAPORE ||
		ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND ||
		ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN )
	{
		if( iUserClientVersion < m_iRevision )
		{
		SP2Packet kPacket( STPK_CONNECT );

			PACKET_GUARD_VOID( kPacket.Write(CONNECT_WRONG_CLIENT_VER) );
		PACKET_GUARD_VOID( kPacket.Write(sPrivateID) );

		SendMessage( kPacket );

		SAFEDELETE(m_pEncLoginKey);
		m_sync_time = TIMEGETTIME();
		return;
	}
	}
#endif
	
	if( g_UserNodeManager.IsConnectUser( sPrivateID ) )   //접속중..
	{
		SP2Packet kPacket( STPK_CONNECT );
		
		PACKET_GUARD_VOID( kPacket.Write(CONNECT_ID_ALREADY) );
		PACKET_GUARD_VOID( kPacket.Write(sPrivateID) );
	 
		SendMessage( kPacket );

		SAFEDELETE(m_pEncLoginKey);
		m_sync_time = TIMEGETTIME();
		return;
	}
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s IsConnectUser Success %s", __FUNCTION__, sPrivateID.c_str() );	//나중에 삭제


	pLocal->ApplyConnect( this, packet ); // 에러체크 이후에 값을 셋팅

	SetIPMapping( szPrivateIP.c_str() );
	
	
	SetPrivateID( sPrivateID );
	
	m_dwDBAgentID = Help::GetUserDBAgentID( GetPrivateID() );	
	
	//HRYOON 20150102 태국 토큰 복호화 결과 전달
	//여기서 BSTPK_LOGIN 보냄 ( 토큰 값 복호화 요청 )
	if( !pLocal->SendLoginData( this ) )
	{
		g_DBClient.OnSelectUserLoginInfo( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), sPrivateID );
	}
	m_sync_time = TIMEGETTIME();

	if(strcmp(sPrivateID.c_str(),"segeni") == 0)
	{
		LOG.PrintTimeAndLog( 0, "OnConnect-%s-%s(%s)-%s-%s-%d-ClientVersion:%d", szEncLoginKeyAndID.c_str(), szPrivateIP.c_str(), peerIP
			,g_App.GetSecondKey().c_str(), GetGUID().c_str(), iLocalVersion, iUserClientVersion);
	}
	
	//HRYOON 20150102 바로 클라이언트에 로그인 성공으로 보내준다. 
	//BSTPK_LOGIN_RESULT(OnBillingLogin) 받았을 때 세팅 하는 걸 여기서 진행해준다. 
#ifdef HRYOON_T
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
	{
		ClearBillingGUID();
		g_DBClient.OnSelectMemberConut( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPrivateID() );
	}
#endif


#ifdef XIGNCODE
	g_ioXignCode.SetUserInformation( this, GetPublicIP(), GetPrivateID().c_str() );
#endif
}

//HRYOON 20150102 태국 토큰 복호화 결과 전달
//CTPK_TH_GA_ID_REQ
//클라이언트에서 토큰을 주면 빌링에 디코드 요청을 보낸다. 
void User::OnThailandTokenDecodeReq( SP2Packet &rkPacket )
{
	ioHashString szThailandToken;
	
	PACKET_GUARD_VOID( rkPacket.Read(szThailandToken) );		

	SetBillingUserKey( szThailandToken );			//토큰 세팅( 가레나 암호화된 값)
	
	//빌링에 전달
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( !pLocal )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::OnThailandTokenDecodeReq - pLocal == NULL. %d", (int) ioLocalManager::GetLocalType() );

		SP2Packet kPacket( STPK_TH_GA_ID_REQ );

		PACKET_GUARD_VOID( kPacket.Write(false) );
		PACKET_GUARD_VOID( kPacket.Write("") );

		SendMessage( kPacket );

		m_sync_time = TIMEGETTIME();
		return;
	}
	pLocal->SendTokenData( this );
	LOG.PrintTimeAndLog( 0, "TEMPLOG, User::OnThailandTokenDecodeReq Token: %s", szThailandToken.c_str() );
}

void User::OnMovingServer( SP2Packet &rkPacket )
{
	// 게임서버 종료 처리 중
	if( g_App.IsReserveLogOut() )
	{
		SP2Packet kPacket( STPK_CONNECT );

		PACKET_GUARD_VOID( kPacket.Write((int) CONNECT_EXITING_SERVER) );
		PACKET_GUARD_VOID( kPacket.Write("") );
	 
		SendMessage( kPacket );
		return;
	}

	// 데이터 요청 정보
	int iUserIndex, iMovingValue, iServerIndex;
	rkPacket >> iUserIndex >> iMovingValue >> iServerIndex;

	// 기본 정보
	ioHashString szPrivateID, szPublicID, szPrivateIP;
	rkPacket >> m_user_data.m_private_id >> m_user_data.m_public_id >> szPrivateIP;
	SetIPMapping( szPrivateIP.c_str() );
	
	SP2Packet kPacket( SSTPK_USER_DATA_MOVE );
	kPacket << iUserIndex << iMovingValue;
	g_ServerNodeManager.SendMessageNode( iServerIndex, kPacket );

 
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnMovingServer : %s - %d - > %d :%s", GetPublicID().c_str(), iServerIndex, g_ServerNodeManager.GetServerIndex() ,
		                                                                 GetGUID().c_str() );
	
}

void User::OnJoinServerLobbyInfo( SP2Packet &rkPacket )
{
	bool bPrevLobby = m_bJoinServerLobby;
	rkPacket >> m_bJoinServerLobby;

	if( m_bJoinServerLobby )
	{
		SP2Packet kPacket( STPK_JOIN_SERVER_LOBBY_INFO );
		kPacket << g_ServerNodeManager.GetServerIndex();
		SendMessage( kPacket );
	}

	if( bPrevLobby != m_bJoinServerLobby )
		SyncUserPos();

	//로비에 올 경우 새로운 팝업을 띄울지 검사해서 보내줌..
	if( m_bJoinServerLobby )
	{
		m_bOnPopup = false;
		OnConnectPopupProcess();
		//CheckPopupStoreIndex();
	}
}

void User::OnFriendList( SP2Packet &rkPacket )
{
	int iCount;
	rkPacket >> iCount;
	g_DBClient.OnSelectFriendList( GetUserDBAgentID(), GetAgentThreadID(), m_Friend.GetLastFriendIndex(), GetUserIndex(), GetPublicID(), iCount );
}

void User::OnFriendRequestList( SP2Packet &rkPacket )
{
	DWORD dwLastIndex, dwMaxCount;
	rkPacket >> dwLastIndex >> dwMaxCount;
	g_DBClient.OnSelectFriendRequestList( GetUserDBAgentID(), GetAgentThreadID(), dwLastIndex, GetUserIndex(), dwMaxCount );
}

void User::OnFriendApplication( SP2Packet &rkPacket )
{
	CRASH_GUARD();
	ioHashString szFriendID;
	rkPacket >> szFriendID;

	if( !g_App.IsRightID( szFriendID.c_str() ) || GetPublicID() == szFriendID )
	{
		SP2Packet kPacket( STPK_FRIEND_APPLICATION );
		kPacket << FRIEND_APPLICATION_NOT_ID;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Wrong ID - OnFriendApplication - (%s) %s", GetPublicID().c_str(), szFriendID.c_str());
		return;
	}

	if( GetEntryType() == ET_TERMINATION )
	{
		SP2Packet kPacket( STPK_FRIEND_APPLICATION );
		kPacket << FRIEND_APPLICATION_NONE_FORMALITY;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnFriendApplication - 임시가입만료 유저가 친구 신청(%s)%d", GetPublicID().c_str(), GetEntryType() );
		return;
	}

	int iSlotSize = GetFriendSlotSize();
	if( m_Friend.GetFriendSize() >= iSlotSize )
	{
		SP2Packet kPacket( STPK_FRIEND_APPLICATION );
		kPacket << FRIEND_APPLICATION_MY_SLOT_FULL;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnFriendApplication - Slot is Full. (%s)%d", GetPublicID().c_str(), iSlotSize );
		return;
	}

	if( !m_Friend.IsFriend( szFriendID ) )
	{
		if( IsDeveloper() )
		{
			g_DBClient.OnSelectFriendDeveloperInsert( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), szFriendID );
		}
		else
			g_DBClient.OnSelectFriendApplication( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), szFriendID );
	}
	else
	{
		SP2Packet kPacket( STPK_FRIEND_APPLICATION );
		kPacket << FRIEND_APPLICATION_ALREADY_ID;
		SendMessage( kPacket );
	}
}

void User::OnFriendCommand( SP2Packet &rkPacket )
{	
	int iCommand;
	rkPacket >> iCommand;
	
	DWORD dwTableIndex, dwUserIndex;
	ioHashString szUserName;
	rkPacket >> dwTableIndex >> dwUserIndex >> szUserName;

	if( GetEntryType() == ET_TERMINATION )
	{
		if( iCommand != FRIEND_COMMAND_REFUSE && iCommand != FRIEND_COMMAND_BLACKLIST )
		{
			SP2Packet kPacket( STPK_FRIEND_COMMAND );
			kPacket << FRIEND_COMMAND_NONE_FORMALITY;
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnFriendCommand 임시가입만료유저 - (%s) %d : %d", GetPublicID().c_str(), GetEntryType() , iCommand );
			return;
		}
	}

	switch( iCommand )
	{
	case FRIEND_COMMAND_AGREE:
		{
			g_DBClient.OnSelectInsertFriend( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), dwTableIndex, dwUserIndex, szUserName );
		}
		break;
	case FRIEND_COMMAND_REFUSE:
		{
			g_DBClient.OnDeleteFriendRequest( GetUserDBAgentID(), GetAgentThreadID(), dwTableIndex );
		}
		break;
	case FRIEND_COMMAND_BLACKLIST:
		{
			g_DBClient.OnDeleteFriendRequest( GetUserDBAgentID(), GetAgentThreadID(), dwTableIndex );
			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szUserName );
			if( pUserParent )
			{
				SP2Packet kPacket( STPK_FRIEND_COMMAND );
				kPacket << FRIEND_COMMAND_BLACKLIST << GetPublicID();
				pUserParent->RelayPacket( kPacket );
			}
		}
		break;
	}
}

void User::OnUserPosRefresh( SP2Packet &rkPacket )
{
	int iCurSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurSize) );
	MAX_GUARD(iCurSize, 50);	

	if( iCurSize != 0 )
	{
		SP2Packet kPacket( STPK_USER_POS_REFRESH );
		PACKET_GUARD_VOID( kPacket.Write(iCurSize) );
		for(int i = 0;i < iCurSize;i++)
		{
			ioHashString szFindName;
			PACKET_GUARD_VOID( rkPacket.Read(szFindName) );

			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szFindName );
			if( pUserParent )
			{
				PACKET_GUARD_VOID( kPacket.Write(szFindName) );
				PACKET_GUARD_VOID( kPacket.Write(true) );
				PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetUserPos()) );
				PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetGradeLevel()) );
				PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetGuildIndex()) );
				PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetGuildMark()) );
				PACKET_GUARD_VOID( kPacket.Write(pUserParent->IsBestFriend(GetUserIndex())) );
			}
			else
			{
				PACKET_GUARD_VOID( kPacket.Write(szFindName) );
				PACKET_GUARD_VOID( kPacket.Write(false) );
			}
		}
		SendMessage( kPacket );
	}
}

void User::OnRegisteredUser( SP2Packet &rkPacket )
{
	ioHashString szName;
	rkPacket >> szName;

	if( !g_App.IsRightID( szName.c_str() ) )
	{
		SP2Packet kPacket( STPK_REGISTERED_USER );
		kPacket << -1;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Wrong ID - OnRegisteredUser - %s", szName.c_str());
		return;
	}

	g_DBClient.OnSelectUserIDCheck( GetUserDBAgentID(), GetAgentThreadID(), GetPublicID(), szName );
}

void User::OnDeleteFriendByWeb( SP2Packet &rkPacket )
{
	ioHashString szFriend;
	rkPacket >> szFriend;

    //웹에서 친구 삭제
	int iPrevFriend = m_Friend.GetFriendSize();
	m_Friend.DeleteFriend( szFriend );

	//상대에게도 알려준다.
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szFriend );
	if( pUserParent )
	{
		if( pUserParent->IsUserOriginal() )
		{
			User *pUser = (User*)pUserParent;
			pUser->DeleteFriend( GetPublicID() );

			SP2Packet kPacket( STPK_FRIEND_DELETE );
			kPacket << GetPublicID();
			pUser->SendMessage( kPacket );
			pUser->CheckRoomBonusTable();
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserParent;
			SP2Packet kPacket( SSTPK_FRIEND_DELETE );
			kPacket << pUserParent->GetPublicID() << GetPublicID();
			pUser->SendMessage( kPacket );
		}
		CheckRoomBonusTable();
	}
}

void User::OnBestFriendInsert( SP2Packet &rkPacket )
{
	DWORD dwFriendUserIndex;
	rkPacket >> dwFriendUserIndex;

	// 절친 해제중 시간 체크 및 기간 지난 테이블 삭제
	DWORDVec vDeleteUserIndex;
	m_Friend.CheckBestFriendToDate( BFT_DISMISS, vDeleteUserIndex );
	if( !vDeleteUserIndex.empty() )
	{
		SP2Packet kPacket( STPK_BESTFRIEND_DELETE_LIST );
		kPacket << (int)vDeleteUserIndex.size();
		for(int i = 0;i < (int)vDeleteUserIndex.size();i++)
		{
			kPacket << vDeleteUserIndex[i];

			m_Friend.DeleteBestFriendTable( this, vDeleteUserIndex[i] );
		}
		SendMessage( kPacket );
	}
	
	// 친구가 아니다.
	FRIEND &rkFriend = m_Friend.GetFriendToUserIndex( dwFriendUserIndex );
	if( rkFriend.m_iIndex == -1 )
	{
		SP2Packet kPacket( STPK_INSERT_BESTFRIEND );
		kPacket << BESTFRIEND_INSERT_FRIEND_ERROR << dwFriendUserIndex;
		SendMessage( kPacket );
	}
	else
	{
		// 이미 절친이거나 해제중
		DWORD dwBFState = m_Friend.GetBestFriendState( dwFriendUserIndex );
		if( dwBFState != BFT_NONE )
		{
			SP2Packet kPacket( STPK_INSERT_BESTFRIEND );
			kPacket << BESTFRIEND_INSERT_STATE_ERROR << dwFriendUserIndex << dwBFState;
			SendMessage( kPacket );
		}
		else if( m_Friend.BestFriendLastIterSize( 0 ) >= Help::GetDefaultBestFriendCount() )   // 절친 제한
		{
			SP2Packet kPacket( STPK_INSERT_BESTFRIEND );
			kPacket << BESTFRIEND_INSERT_COUNT_ERROR;
			SendMessage( kPacket );
		}
		else
		{
			g_DBClient.OnInsertBestFriendAdd( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwFriendUserIndex );			
		}
	}
}

void User::OnBestFriendInsertFailed( SP2Packet &rkPacket )
{
	DWORD dwFriendIndex;
	rkPacket >> dwFriendIndex;
	m_Friend.DeleteBestFriendTable( this, dwFriendIndex );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnBestFriendInsertFailed : %s - %d", GetPublicID().c_str(), dwFriendIndex );
}

void User::_OnBestFriendDismiss( const ioHashString &rkFriendName, bool bResult )
{
	// 친구가 아니다.
	FRIEND &rkFriend = m_Friend.GetFriendToUserName( rkFriendName );
	if( rkFriend.m_iIndex == -1 )
	{
		if( bResult )
		{
			SP2Packet kPacket( STPK_DISMISS_BESTFRIEND );
			kPacket << BESTFRIEND_DISMISS_FRIEND_ERROR << 0 << rkFriendName;
			SendMessage( kPacket );
		}
	}
	else
	{
		DWORD dwMagicDate = 0;
		if( m_Friend.ClearBestFriend( this, rkFriend.m_dwUserIndex, dwMagicDate ) )
		{
			SyncUserBestFriend();
			
			SP2Packet kPacket( STPK_DISMISS_BESTFRIEND );
			kPacket << BESTFRIEND_DISMISS_OK << rkFriend.m_dwUserIndex << dwMagicDate << rkFriendName << bResult;
			SendMessage( kPacket );

			// 대상에게 알림
			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( rkFriend.m_dwUserIndex );
			if( pUserParent )
			{
				SP2Packet kOtherPacket( STPK_DISMISS_BESTFRIEND );
				kOtherPacket << BESTFRIEND_DISMISS_OTHER_OK << GetPublicID();
				pUserParent->RelayPacket( kOtherPacket );
			}
		}
		else
		{
			// 절친이 아님
			if( bResult )
			{
				SP2Packet kPacket( STPK_DISMISS_BESTFRIEND );
				kPacket << BESTFRIEND_DISMISS_STATE_ERROR << rkFriend.m_dwUserIndex << rkFriendName;
				SendMessage( kPacket );
			}
		}
	}
}

void User::OnBestFriendDismiss( SP2Packet &rkPacket )
{
	ioHashString kName;
	DWORD dwFriendIndex;
	rkPacket >> dwFriendIndex >> kName;

	// 절친 해제중 시간 체크 및 기간 지난 테이블 삭제
	DWORDVec vDeleteUserIndex;
	m_Friend.CheckBestFriendToDate( BFT_DISMISS, vDeleteUserIndex );
	if( !vDeleteUserIndex.empty() )
	{
		SP2Packet kPacket( STPK_BESTFRIEND_DELETE_LIST );
		kPacket << (int)vDeleteUserIndex.size();
		for(int i = 0;i < (int)vDeleteUserIndex.size();i++)
		{
			kPacket << vDeleteUserIndex[i];

			m_Friend.DeleteBestFriendTable( this, vDeleteUserIndex[i] );
		}
		SendMessage( kPacket );
	}

	_OnBestFriendDismiss( kName, true );
}

void User::OnBestFriendExceptionList( SP2Packet &rkPacket )
{
	int i = 0, iSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iSize) );
	MAX_GUARD(iSize, 100);

	static DWORDVec kUserIndexVec;
	kUserIndexVec.clear();
	for(i = 0;i < iSize;i++)
	{
		DWORD dwUserIndex = 0;
		PACKET_GUARD_VOID( rkPacket.Read(dwUserIndex) );
		kUserIndexVec.push_back( dwUserIndex );
		m_Friend.ExceptionClearBestFriend( this, dwUserIndex, GetLastLogOutTime() );

		char szLog[2048] = ""; 
		sprintf_s( szLog, "로그 오프 상태에서 친구 해제된 유저 절친 처리됨: %s - %d - %d/%d", 
						GetPublicID().c_str(), dwUserIndex, GetLastLogOutTime().GetMonth(), GetLastLogOutTime().GetDay() );		
		SP2Packet kPacket2( LUPK_LOG );
		PACKET_GUARD_VOID( kPacket2.Write("ServerError") );
		PACKET_GUARD_VOID( kPacket2.Write(szLog) );
		g_UDPNode.SendLog( kPacket2 );
	}
	SyncUserBestFriend();

	SP2Packet kPacket( STPK_BESTFRIEND_EXCEPTION_LIST );
	iSize = kUserIndexVec.size();
	PACKET_GUARD_VOID( kPacket.Write(iSize) );
	for(i = 0;i < iSize;i++)
	{
		PACKET_GUARD_VOID( kPacket.Write(kUserIndexVec[i]) );
		PACKET_GUARD_VOID( kPacket.Write(m_Friend.GetBestFriendTime( kUserIndexVec[i])) );
	}
	SendMessage( kPacket );
}

void User::OnFriendDelete( SP2Packet &rkPacket )
{
	ioHashString szName;
	rkPacket >> szName;

	FRIEND &rkFriend = m_Friend.GetFriendToUserName( szName );
	if( rkFriend.m_szName == szName )
	{
		_OnBestFriendDismiss( szName, false );
		if( DeleteFriend( szName ) )
		{
			g_DBClient.OnDeleteFriend( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), szName );
			CheckRoomBonusTable();
		}
	}	
}

void User::OnUserLogin( SP2Packet &rkPacket )
{
	int iCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCount) );
	MAX_GUARD(iCount, 100);

	SP2Packet kPacket( STPK_USER_LOGIN );
	PACKET_GUARD_VOID( kPacket.Write(iCount) );
	for(int i = 0;i < iCount ;i++)
	{
		ioHashString szName;
		PACKET_GUARD_VOID( rkPacket.Read(szName) );
		UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szName );
		if( pUserParent )
		{
			PACKET_GUARD_VOID( kPacket.Write(szName) );
			PACKET_GUARD_VOID( kPacket.Write(true) );
			PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetGradeLevel()) );
			PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetGuildIndex()) );
			PACKET_GUARD_VOID( kPacket.Write(pUserParent->GetGuildMark()) );
			PACKET_GUARD_VOID( kPacket.Write(pUserParent->IsBestFriend(GetUserIndex())) );
		}
		else
		{
			PACKET_GUARD_VOID( kPacket.Write(szName) );
			PACKET_GUARD_VOID( kPacket.Write(false) );
		}
	}
	SendMessage( kPacket );
}

void User::OnLogOut( SP2Packet &rkpacket)
{
	SP2Packet kPacket( STPK_LOGOUT );
	SendMessage( kPacket );
}

void User::OnCharCreate(SP2Packet &packet)
{
	// 상점 블럭.
	if( IsCharCreating() )
	{
		// 레벨업 보상 지급중이다 완료시까지 용병 구매 불가.
		SP2Packet kReturn( STPK_CHAR_CREATE );

		PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_FAIL_WORKING) );

		SendMessage( kReturn );
		return;
	}

	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCreate Billing Wait : %s:%s", GetPublicID().c_str(), m_szBillingGUID.c_str() );

		SP2Packet kReturn( STPK_CHAR_CREATE );

		PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_BILLING_WAIT) );

		SendMessage( kReturn );
		return;
	}


	//////////////////////////////////////////////////////////////////////////
	int iCharCreateType;

	PACKET_GUARD_VOID( packet.Read(iCharCreateType) );

	CHARACTER kCharInfo;
    int iWantPrice			= 0;
	bool bCash				= false;
	bool bBonusCash			= false;
	int  iTempPeriodtype	= 0;
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	
	PACKET_GUARD_VOID( packet.Read(kCharInfo.m_class_type) );
	PACKET_GUARD_VOID( packet.Read(kCharInfo.m_kindred) ); 
	PACKET_GUARD_VOID( packet.Read(kCharInfo.m_sex) ); 
	PACKET_GUARD_VOID( packet.Read(kCharInfo.m_iLimitSecond) ); 
	PACKET_GUARD_VOID( packet.Read(iWantPrice) ); 
	PACKET_GUARD_VOID( packet.Read(bCash) ); 
	PACKET_GUARD_VOID( packet.Read(iTempPeriodtype) );

	if( !g_SaleMgr.IsSelling( ioSaleManager::IT_CLASS, kCharInfo.m_class_type ) )
	{
		SP2Packet kReturn( STPK_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_PESO_FAIL) ); //예외 오류가 발생되었습니다.
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( 0, "%s - Is not possible selling date. | ClassCode(%d)", __FUNCTION__, kCharInfo.m_class_type );
		return;
	}

	//hr 테스트 로그
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCreate ClassType : %d, Kindered : %d, Gender : %d, limitSecond : %d, Price : %d, bCash : %d, PeriodType : %d"
		, kCharInfo.m_class_type, kCharInfo.m_kindred, kCharInfo.m_sex, kCharInfo.m_iLimitSecond, iWantPrice, bCash, iTempPeriodtype );

	kCharInfo.m_ePeriodType =  (CharPeriodType) iTempPeriodtype;
	
	DWORD dwSetItemCode = kCharInfo.m_class_type + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	bool bRightLimit = true;
	
	if( iCharCreateType == CHAR_CREATE_NORMAL )
	{
		if( kCharInfo.m_ePeriodType == CPT_TIME )
		{
			if( bCash )
				bRightLimit = g_ItemPriceMgr.IsCompareLimitDateCash( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
			else
				bRightLimit = g_ItemPriceMgr.IsCompareLimitDatePeso( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
		}
		else if( kCharInfo.m_ePeriodType == CPT_DATE )
		{
			if( bCash )
				bRightLimit = g_ItemPriceMgr.IsCompareLimitDateCash( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
			else
				bRightLimit = g_ItemPriceMgr.IsCompareLimitDatePeso( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
	}
	}
	else if( iCharCreateType == CHAR_CREATE_FIRST_HIRE )
	{
		if( kCharInfo.m_iLimitSecond != g_ItemPriceMgr.GetFirstHireLimit() )
			bRightLimit = false;
	}
	else if( iCharCreateType == CHAR_CREATE_BANKRUPTCY )
	{
		if( kCharInfo.m_iLimitSecond != g_ItemPriceMgr.GetBankruptcyLimit() )
			bRightLimit = false;
	}
	else if( iCharCreateType == CHAR_CREATE_EVENT )
	{
		if( kCharInfo.m_iLimitSecond != g_EventMgr.GetValue( EVT_PROPOSAL, EA_MAX_CHAR_USE_SEC ) )
			bRightLimit = false;
	}
	else
		bRightLimit = false;

	if(  !pSetInfo || !bRightLimit )
	{
		// 잘못된 세트 값.
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnCharCreate 잘못된 세트 값을 보냈다 = %d(%d:%d)", GetPublicID().c_str(), kCharInfo.m_class_type, kCharInfo.m_iLimitSecond, iCharCreateType );
		//
		SP2Packet kReturn( STPK_CHAR_CREATE );

		PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

		SendMessage( kReturn );
		return;
	}

	if( IsClassTypeExceptExercise( kCharInfo.m_class_type ) ) // 연습용병은 보유하고 있어도 구매가 가능하다.
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnCharCreate 이미 보유하고 있는 용병 구매 요청 = %d(%d)", GetPublicID().c_str(), kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
		//
		SP2Packet kReturn( STPK_CHAR_CREATE );

		PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

		SendMessage( kReturn );
		return;
	}

	// Cash 구매
	if( bCash )
	{
		//g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
		//HRYOON BONUS CASH 사용 가능 여부 파악
		//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		if( GetEntryType() == ET_TERMINATION )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCreate Cash Entry Type Error : %s:%d", GetPublicID().c_str(), GetEntryType() );

			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

			SendMessage( kReturn );
			return;
		}

		int iBuyCash = 0;
		if( kCharInfo.m_ePeriodType == CPT_TIME )
			iBuyCash = g_ItemPriceMgr.GetClassBuyCash( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
		else if( kCharInfo.m_ePeriodType == CPT_MORTMAIN )
			iBuyCash = g_ItemPriceMgr.GetMortmainCharCash( kCharInfo.m_class_type );
		else if( kCharInfo.m_ePeriodType == CPT_DATE )
			iBuyCash = g_ItemPriceMgr.GetClassBuyCash( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );

		if( iBuyCash <= 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCreate Cash Price Error : %s:%d:%d:%d", GetPublicID().c_str(), iBuyCash, kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );

			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

			SendMessage( kReturn );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCreate pNode == NULL. : %d:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );

			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_BILLING_FAIL) );

			SendMessage( kReturn );
			return;
		}

		int iItemPrice = iBuyCash;
		
		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_CHAR_CREATE, CREATE_CHAR_CASH_FAIL, kCharInfo.m_class_type, vConsumeInfo ) )
			return;

		int iSize	= vConsumeInfo.size();

		int iSpendBonusCash	= 0;
		for( int i = 0; i < iSize; i++ )
			iSpendBonusCash += vConsumeInfo[i].value2;
		
		//보너스 캐쉬로 장비 구매 가능 
		if( iSpendBonusCash >= iItemPrice )
			bBonusCash = true;

		//실캐시도 쓰고 보너스 캐시도 쓰는 경우
		if( iItemPrice != iSpendBonusCash )
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;

			SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );

			PACKET_GUARD_VOID( kBillingPacket.Write((int) GetChannelingType()) );
			PACKET_GUARD_VOID( kBillingPacket.Write(m_szBillingGUID) );
			PACKET_GUARD_VOID( kBillingPacket.Write( iItemPrice ));
			PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
			PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
			PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicIP()) );
	
			PACKET_GUARD_VOID( kBillingPacket.Write(iBuyCash) );		//s

			PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
			for( int i = 0; i < iSize; i++ )
			{
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
			}

			PACKET_GUARD_VOID( kBillingPacket.Write(OUTPUT_CASH_SOLDIER) );
			PACKET_GUARD_VOID( kBillingPacket.Write(kCharInfo.m_class_type) );
			PACKET_GUARD_VOID( kBillingPacket.Write(kCharInfo.m_kindred) );
			PACKET_GUARD_VOID( kBillingPacket.Write(kCharInfo.m_sex) );
			PACKET_GUARD_VOID( kBillingPacket.Write(kCharInfo.m_iLimitSecond) );
			PACKET_GUARD_VOID( kBillingPacket.Write((int)kCharInfo.m_ePeriodType) );

			if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_CHAR_CREATE, CREATE_CHAR_BILLING_FAIL, NULL, NULL ) )
				return;

			ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
			if( pLocal )
				pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

			if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCreate Cash Send Fail : %s:%s:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );

				SP2Packet kReturn( STPK_CHAR_CREATE );

				PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_BILLING_DISCONNECT) );

				SendMessage( kReturn );
				m_szBillingGUID.Clear();
				return;
			}
			else
			{
				//[HRYOON구매] 유저 구매 중인 상태로 변경함
				SetOutputStatus( true );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharCreate Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharCreate Cash Send : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			}
			return;
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharCreate Cash Send Fail : %s:%s:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			//보너스 캐시로 구매 가능시 
			if( bBonusCash && bCash )
			{
				//db에서 보너스 캐시 응답이 안들어온경우
#ifdef HRYOON_TEST
				if(!GetBonusCashStatus())
				{
					SP2Packet kReturn( STPK_CHAR_CREATE );

					PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_BILLING_WAIT) );

					SendMessage( kReturn );
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash wait-userIndex:%d,PublicID:%s", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );

					return;
				}
#endif
				if(m_szBillingGUID.IsEmpty())
				{
					char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
					Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
					m_szBillingGUID = szTempGUID;
				}
				for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
				{
					//보너스 캐쉬 사용 실패
					if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_SOLDIER, kCharInfo.m_class_type, kCharInfo.m_iLimitSecond) )
					{
						SP2Packet kReturn( STPK_CHAR_CREATE );

						PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

						SendMessage( kReturn );
						LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error-guid:%s,userIndex:%d,PublicID:%s:index:%d,money:%d:ClassType:%d", __FUNCTION__, GetBillingGUID().c_str(),GetUserIndex(), GetPublicID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2, kCharInfo.m_class_type );

						ClearBillingGUID();
						return;
					}
				}

				ClearBillingGUID();

				//아이템 지급
				__int64 iPreMoney = GetMoney();
				bool bMortmain = false;
				if( kCharInfo.m_ePeriodType == CPT_MORTMAIN )
					bMortmain = true;
				int iBonusPeso = g_ItemPriceMgr.GetBonusPeso( kCharInfo.m_class_type, bMortmain );
				if( iBonusPeso > 0 )
				{
					AddMoney( iBonusPeso );
					SaveUserData();
					g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
					g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_SOLDIER, kCharInfo.m_class_type, iBonusPeso, NULL);
				}

				// 착용중인 아이템
				m_Inventory.GetEquipItemCode( kCharInfo );	
				// 착용한 아이템이 없다면 Default 지급
				if( kCharInfo.m_face == -1)
					kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
				if( kCharInfo.m_hair == -1 )
					kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
				if( kCharInfo.m_skin_color == -1 )
					kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
				if( kCharInfo.m_hair_color == -1 )
					kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
				if( kCharInfo.m_underwear == -1 )
					kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	

				m_iCreateCharCount++;
				//캐릭터 생성.
				g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
				g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK , 1, LogDBClient::CT_CASH, iItemPrice ); // false : 페소, true : 캐쉬

				return;
			}
			//보너스 캐시 부족함
			else
			{
				SP2Packet kReturn( STPK_CHAR_CREATE );

				PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

				SendMessage( kReturn );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error BonusCash shortage %userIndex:d,PublicID:%s:BonusCash%d,ActiveBuy:%d:ClassType:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iSpendBonusCash, GetActiveBuyCharCount(), kCharInfo.m_class_type );
				return;
			}
		}
		return;
	}
	
	//캐시 구매 외의 상황
	// 금액이 변동되었는지 확인

	if( iWantPrice != 0 && !bCash )       //0이면 무료
	{
		bool bRefresh = false;
		if( kCharInfo.m_ePeriodType ==  CPT_TIME )
		{
			if( g_ItemPriceMgr.GetClassBuyPeso( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond ) != iWantPrice )
				bRefresh = true;
		}
		else if( kCharInfo.m_ePeriodType == CPT_MORTMAIN )
		{
			if( g_ItemPriceMgr.GetMortmainCharPeso( kCharInfo.m_class_type ) != iWantPrice )
				bRefresh = true;
		}
		else if( kCharInfo.m_ePeriodType == CPT_DATE)
		{
			if( g_ItemPriceMgr.GetClassBuyPeso( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond ) != iWantPrice )
				bRefresh = true;
		}

		if( bRefresh )
		{
			// 가격 전송
			g_ItemPriceMgr.SendClassBuyPriceInfo( this );


			//SP2Packet kClassPricePacket( STPK_CLASSPRICE );
			//g_ItemPriceMgr.FillClassBuyPriceInfo( kClassPricePacket );
			//SendMessage( kClassPricePacket );
			

			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_PRICE_CHANGE) );

			SendMessage( kReturn );
			return;
		}
	}
	
	bool bFirstSoldierSelect = false;
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal && pLocal->IsFirstSoldierSelect() )
		bFirstSoldierSelect = true;

	// 구매할 조건이 되는지확인
	if( !IsCanBuyItem( pSetInfo ) )
	{
		bool bError = true;
		if( iCharCreateType == CHAR_CREATE_FIRST_HIRE )
		{
			if( bFirstSoldierSelect )
			{
				bError = false;
			}
		}
		else if( iCharCreateType == CHAR_CREATE_EVENT )
		{
			bError = false;
		}
		else
		{
			BuyCharNoLevelLimitEventUserNode *pEventNode = static_cast<BuyCharNoLevelLimitEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_BUY_CHAR_NO_LEVEL_LIMIT ) );
			if( pEventNode && pEventNode->IsNoLevelLimit( this, true, iCharCreateType, kCharInfo.m_iLimitSecond, (int) kCharInfo.m_ePeriodType ) )
				bError = false;
		}

		if( bError )
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_NEED_LEVEL) );

			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCreate need level %s:%d", GetPublicID().c_str() , GetGradeLevel() );
			return;
		}
	}

	// 권한아이템 확인
	if( kCharInfo.m_ePeriodType == CPT_MORTMAIN )
	{
		if( iCharCreateType == CHAR_CREATE_FIRST_HIRE )
		{
			
		}
		else
		{
		ioEtcItemBuyMortmainChar *pEtcItem = static_cast<ioEtcItemBuyMortmainChar*> ( g_EtcItemMgr.FindEtcItem( ioEtcItem::EIT_ETC_BUY_MORTMAIN_CHAR ) );
		if( !pEtcItem )
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCreate pEtcItem == NULL %s", GetPublicID().c_str() );
			return;
		}

		if( !pEtcItem->SetUsed( this, GetUserEtcItem() ) )
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_WANT_OF_MORTMAIN_ETCITEM) );

			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCreate don't have mortmain etc item %s", GetPublicID().c_str() );
			return;
		}
	}
	}
	
	int iLogType = LogDBClient::CT_BUY;
	int iBuyPeso = 0;
	if( iCharCreateType == CHAR_CREATE_NORMAL )
	{
		int iResult  = CREATE_CHAR_OK;
		BOOL bUsedBonusCash	= FALSE;
		if( kCharInfo.m_ePeriodType == CPT_DATE )
			iBuyPeso = g_ItemPriceMgr.GetClassBuyPeso( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );

		if( !vConsumeInfo.empty() )
			bUsedBonusCash	= TRUE;
		//용병을 페소구매한 경우
		if( !bUsedBonusCash )
		{
			if( kCharInfo.m_ePeriodType == CPT_TIME )
				iBuyPeso = g_ItemPriceMgr.GetClassBuyPeso( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
			else if( kCharInfo.m_ePeriodType == CPT_MORTMAIN )
				iBuyPeso = g_ItemPriceMgr.GetMortmainCharPeso( kCharInfo.m_class_type );

			if( iBuyPeso <= 0 )
			{
				iResult = CREATE_CHAR_EXCEPTION;
			}
			else
			{
				if( GetMoney() < iBuyPeso )
					iResult = CREATE_CHAR_PESO_FAIL;
			}
		}
		
		if( iResult != CREATE_CHAR_OK )
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );
			
			PACKET_GUARD_VOID( kReturn.Write(iResult) );
			
			SendMessage( kReturn );
			return;
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Char Create[%d초][Type:%d] : %s Before %I64dPeso, %dCash", kCharInfo.m_iLimitSecond, (int)kCharInfo.m_ePeriodType
									,GetPublicID().c_str(), GetMoney(), GetCash() );

			RemoveMoney( iBuyPeso );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CHAR, PRESENT_SOLDIER, kCharInfo.m_class_type, iBuyPeso, NULL);

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Char Create : %s After %I64dPeso, %dCash",
									GetPublicID().c_str(), GetMoney(), GetCash() );

			SaveUserData();  //금액이 차감되었다.

			// 구매 시간 저장
			if( kCharInfo.m_ePeriodType == CPT_TIME )
			{
				g_ItemPriceMgr.SetBuySoldierCollected( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
			}
			else if( kCharInfo.m_ePeriodType == CPT_DATE )		// TODO:jal 
			{
				g_ItemPriceMgr.SetBuySoldierCollected( kCharInfo.m_class_type, kCharInfo.m_iLimitSecond );
			}


			// 구매선물
			IntVec vEventTypeVec;
			vEventTypeVec.reserve(10);
			m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
			int iSize = vEventTypeVec.size();
			for (int i = 0; i < iSize ; i++)
			{
				BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
				if( pEventNode )
				{
					int iValue2 = -1;
					if( kCharInfo.m_ePeriodType == CPT_TIME )
						iValue2 = kCharInfo.m_iLimitSecond;
					else if( kCharInfo.m_ePeriodType == CPT_MORTMAIN )
						iValue2 = 0;
					else if( kCharInfo.m_ePeriodType == CPT_DATE )
						iValue2 = kCharInfo.m_iLimitSecond;
					pEventNode->SendBuyPresent( this, true, ioPresentHelper::BT_SOLDIER, kCharInfo.m_class_type, iValue2, iBuyPeso );
				}
			}
		}
	}	
	else if( iCharCreateType == CHAR_CREATE_FIRST_HIRE ) 
	{		
		bool bCheckDeco = true;
		if( bFirstSoldierSelect )
		{
			PACKET_GUARD_VOID( packet.Read(kCharInfo.m_hair) );
			PACKET_GUARD_VOID( packet.Read(kCharInfo.m_hair_color) );
			PACKET_GUARD_VOID( packet.Read(kCharInfo.m_face) );
			PACKET_GUARD_VOID( packet.Read(kCharInfo.m_skin_color) );
			PACKET_GUARD_VOID( packet.Read(kCharInfo.m_underwear) );

			bCheckDeco = g_FirstSoldierMgr.IsExistDecoAll( kCharInfo );
		}

		if( GetUserState() != 0  || 
			GetCharCount() != 0  || 
			g_ItemPriceMgr.IsCashOnly( kCharInfo.m_class_type ) || 
			!bCheckDeco )  
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );
			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error First hire %d|%s:%d:%d:%d[%d:%d:%d:%d:%d:%d]", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetUserState(), GetCharCount(), kCharInfo.m_class_type, kCharInfo.m_kindred, kCharInfo.m_hair, kCharInfo.m_hair_color, kCharInfo.m_face, kCharInfo.m_skin_color, kCharInfo.m_underwear );
			return;
		}

		_OnLeaderCreate( kCharInfo.m_class_type );
		iLogType = LogDBClient::CT_TUTORIAL;
	}
	else if( iCharCreateType == CHAR_CREATE_BANKRUPTCY )
	{
		// 파산페소지급
		//SP2Packet kReturn( STPK_CHAR_CREATE );
		//kReturn << CREATE_CHAR_EXCEPTION;
		//SendMessage( kReturn );
		//LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Bankruptcy :%I64d:%d", __FUNCTION__, GetMoney(), GetActiveBuyCharCount() );
		//return;
		//

		// 파산캐릭터지급
		if( GetMoney() >= g_ItemPriceMgr.GetBankruptcyPeso() || 
			GetActiveBuyCharCount() != 0                     || 
			GetUserState() == 0                              ||
			g_ItemPriceMgr.IsCashOnly( kCharInfo.m_class_type ) )
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Bankruptcy %d|%s:%I64d:%d:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetMoney(), GetActiveBuyCharCount(), kCharInfo.m_class_type );
			return;
		}

		iLogType = LogDBClient::CT_BANKRUPT;
	}
	else if( iCharCreateType == CHAR_CREATE_EVENT ) 
	{
		int iEventType  = 0;
		packet >> iEventType;
		if( iEventType == EVT_PROPOSAL )
		{
			ProposalEventUserNode *pNode = static_cast<ProposalEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_PROPOSAL ) );
			if( pNode && pNode->IsGiveChar( this ) )
			{
				iLogType = LogDBClient::CT_EVENT_PROPOSAL;
				pNode->SetValueGiveChar();
				if( !pNode->IsGiveChar( this ) )
					pNode->Save( GetUserDBAgentID(), GetAgentThreadID() );
			}
			else
			{
				SP2Packet kReturn( STPK_CHAR_CREATE );

				PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

				SendMessage( kReturn );

				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCreate Event have not : %d:%s:%d", GetUserIndex(), GetPublicID().c_str(), iEventType );
				return;
			}
		}
		else if( iEventType == EVT_PLAYTIME )
		{
			int iGiftType = 0;
			packet >> iGiftType;
			PlayTimeEventUserNode *pEvent = static_cast<PlayTimeEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_PLAYTIME ) );
			if( pEvent && pEvent->IsGift( (PlayTimeEventUserNode::GiftType) iGiftType, this, false ) ) 
			{
				iLogType = LogDBClient::CT_EVENT_PLAYTIME;
				pEvent->SetGift( (PlayTimeEventUserNode::GiftType) iGiftType, this, false );
				kCharInfo.m_iLimitSecond = pEvent->GetLimitSecond( (PlayTimeEventUserNode::GiftType) iGiftType );
				pEvent->Save( GetUserDBAgentID(), GetAgentThreadID() );
			}
			else
			{
				SP2Packet kReturn( STPK_CHAR_CREATE );

				PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

				SendMessage( kReturn );

				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCreate Event have not : %d:%s:%d", GetUserIndex(), GetPublicID().c_str(), iEventType );
				return;
			}
		}
		else
		{
			SP2Packet kReturn( STPK_CHAR_CREATE );

			PACKET_GUARD_VOID( kReturn.Write(CREATE_CHAR_EXCEPTION) );

			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCreate Event Type Error : %d:%s:%d", GetUserIndex(), GetPublicID().c_str(), iEventType );
			return;
		}
	}
	
	if( iCharCreateType == CHAR_CREATE_FIRST_HIRE && bFirstSoldierSelect )
	{
		// 유저가 치장을 선택하므로 디폴트 치장은 장착하지 않는다.
	}
	else
	{
		// 착용중인 아이템
		m_Inventory.GetEquipItemCode( kCharInfo );	
		// 착용한 아이템이 없다면 Default 지급
		if( kCharInfo.m_face == -1)
			kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
		if( kCharInfo.m_hair == -1 )
			kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
		if( kCharInfo.m_skin_color == -1 )
			kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
		if( kCharInfo.m_hair_color == -1 )
			kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
		if( kCharInfo.m_underwear == -1 )
			kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	
	}
	
	m_iCreateCharCount++;


	if( kCharInfo.m_ePeriodType == CPT_DATE )
	{
		SetCharDateType(kCharInfo);
	}

	//캐릭터 생성.
	g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
	g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK, 1, iLogType, iBuyPeso ); 

	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);
}

bool User::SetCharDateType(CHARACTER &kCharInfo)
{
	CTime kCurTime = CTime::GetCurrentTime();

	int nDate = kCharInfo.m_iLimitSecond;

	LOG.PrintTimeAndLog(LOG_DEBUG_LEVEL, "%s limitSec %d", __FUNCTION__, nDate);

	if( nDate == 0)
	{
		LOG.PrintTimeAndLog(LOG_DEBUG_LEVEL, "%s character by date [PeriodType %d][class_type %d]", 
								__FUNCTION__, kCharInfo.m_ePeriodType, kCharInfo.m_class_type);
		return false;
	}

	CTimeSpan kAddTime(0, 0, nDate, 0);
	CTime kCharTime = kCurTime + kAddTime;

	SYSTEMTIME sysCharTime;
	kCharTime.GetAsSystemTime( sysCharTime );

	// 디비 저장용으로 따로 둔다	JCLEE 140416
	m_iLimitSecForLatin = kCharInfo.m_iLimitSecond;

	// 17년은 유지한다는 가정하에 2010 을 뺀다.
	kCharInfo.m_iLimitSecond = Help::ConvertYYMMDDHHMMToDate(sysCharTime.wYear, sysCharTime.wMonth, sysCharTime.wDay,
		sysCharTime.wHour, sysCharTime.wMinute);

	LOG.PrintTimeAndLog(LOG_DEBUG_LEVEL, "%s Set %d[%d]", __FUNCTION__, kCharInfo.m_iLimitSecond, ( (sysCharTime.wYear - 2010) * 100000000));

	return true;
}

void User::_OnLeaderCreate( int iClassType )
{
	// 선택한 세트 아이템으로 훈련 시작
	m_user_data.m_user_state = iClassType * 100;     // 세트 아이템의 마지막 번호가 훈련 종류를 선택
	SaveUserData();
}

void User::OnServiceChar( SP2Packet &rkPacket )
{
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnServiceChar 삭제된 패킷 전송되었음.", GetPublicID().c_str() );
}

void User::_OnCharDelete( int iCharArray )
{
	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
		return;
	//캐릭터 삭제.
	if( m_CharList[iCharArray]->HasExerciseStyle( EXERCISE_GENERAL ) )
	{
		DeleteExerciseChar( EXERCISE_GENERAL );
	}
	else if( m_CharList[iCharArray]->HasExerciseStyle( EXERCISE_PCROOM ) )
	{		
		DeleteExercisePCRoomChar( m_CharList[iCharArray]->GetCharIndex() );
	}
	else if( m_CharList[iCharArray]->HasExerciseStyle( EXERCISE_EVENT ) )
	{
		DeleteExerciseChar( EXERCISE_EVENT );
	}
	else if( m_CharList[iCharArray]->HasExerciseStyle( EXERCISE_RENTAL ) )
	{
		DeleteExerciseChar( EXERCISE_RENTAL );
	}
	else
	{
		g_DBClient.OnDeleteCharData( GetUserDBAgentID(), GetAgentThreadID(), m_CharList[iCharArray]->GetCharIndex() );
		//각성 시 각성 map 삭제
		if( m_CharList[iCharArray]->GetAwakeType() != AWAKE_NONE )
		{
			int iCharIndex = GetCharIndex( iCharArray );
			std::map < int, int >::iterator iter = m_CharAwakeDataMap.find( iCharIndex );

			if( iter != m_CharAwakeDataMap.end() )
			{
				m_CharAwakeDataMap.erase( iter );
			}
			else
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::_OnCharDelete Error - m_CharAwakeDataMap , CharAwakeInfo not Sync %s : Index %d", GetPublicID().c_str(), iCharIndex );
			}
		}

		DeleteCharData( iCharArray );
	}
}

void User::OnCharDelete(SP2Packet &packet)
{
	DWORD dwCharIndex;
	packet >> dwCharIndex;

	int i = 0;
	int iCharArray = -1;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
		{
			iCharArray = i;
			break;
		}
	}
	
	int iResult = DELETE_CHAR_OK;

	if( iCharArray == -1 )
		iResult = DELETE_EXCEPTION;

	if( m_pMyRoom && iCharArray == m_select_char )
		iResult = DELETE_SELECT_CHAR;
	
	int iResellLimitDate = 0;
	int iResellPeso      = 0;
	__int64 iPreMoney    = 0;
	if( iResult == DELETE_CHAR_OK )
	{
		BOOL bRSoldier	= FALSE;

		if( m_CharList[iCharArray]->HasExerciseStyle( EXERCISE_NONE ) )
		{
			// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
			if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
			{
				m_CharList[iCharArray]->UpdateLimitTimer();
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharDelete - UpdateLimitTimer %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
			}	

			/*if( GetMyRoom() )
			{*/
			Room* pMyRoom	= GetMyRoom();
			int iSoldierType	= GetSpecialSoldierType(m_CharList[iCharArray]->GetClassType());

			if( iSoldierType != SST_END )
			{
				if( m_CharList[iCharArray]->IsMortmain() )
				{
					if( SST_RSOLDIER == iSoldierType )
					{
						SP2Packet kPacket(STPK_RSOLDIER_STATUS);
						PACKET_GUARD_VOID( kPacket.Write(RSOLDIER_SELL) );
						PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

						if( pMyRoom )
							pMyRoom->RoomSendPacketTcp(kPacket);
						else
							SendMessage(kPacket);
					}
					else
					{
						SP2Packet kPacket(STPK_SOLDIER_SET_STATUS);
						PACKET_GUARD_VOID( kPacket.Write(RSOLDIER_SELL) );
						PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
						PACKET_GUARD_VOID( kPacket.Write(m_CharList[iCharArray]->GetClassType()) );

						if( pMyRoom )
							pMyRoom->RoomSendPacketTcp(kPacket);
						else
							SendMessage(kPacket);
					}
				}
			}
			/*}*/
			
			const CHARACTER &rkCharInfo = m_CharList[iCharArray]->GetCharInfo();
			iResellLimitDate = rkCharInfo.m_iLimitSecond;

			bool bResell = true;

			if( m_CharList[iCharArray]->IsMortmain() )
			{
				iResellPeso  = g_ItemPriceMgr.GetMortmainCharResellPeso( rkCharInfo.m_class_type );
			}
			else
			{
				if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN)
				{
					CTime cCharTime = Help::ConvertNumberToCTime(iResellLimitDate);
					CTime kCurTime = CTime::GetCurrentTime();

					if(kCurTime < cCharTime)
					{
						CTimeSpan cRemainTime = cCharTime - kCurTime;
						iResellLimitDate = cRemainTime.GetTotalMinutes();
					}
					else
					{
						bResell = false;
						iResellLimitDate = 1;
					}
				}

				// 시간제 용병 계산부 위치 수정		JCLEE 140423
				iResellPeso  = g_ItemPriceMgr.GetTimeCharResellPeso( rkCharInfo.m_class_type, iResellLimitDate  );
			}			

			if( SendBillingAddMileage( PRESENT_SOLDIER, rkCharInfo.m_class_type, 0, iResellPeso, false ) )
			{
				iResellPeso = 0;
			}

			if( !bResell)
				iResellPeso = 0;

			if( iResellPeso > 0 )
			{
				iPreMoney = GetMoney();
				AddMoney( iResellPeso );
				SaveUserData();   //금액이 차감되었다.
				g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_DEL_CHAR, PRESENT_SOLDIER, rkCharInfo.m_class_type, iResellPeso, NULL);
			}

			g_LogDBClient.OnInsertPeso( this, iResellPeso, LogDBClient::PT_DEL_CHAR );

			char szItemIndex[MAX_PATH]="";
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );
			g_LogDBClient.OnInsertChar( this, rkCharInfo.m_class_type, iResellLimitDate, 0, szItemIndex, LogDBClient::CT_DEL ); // 페소는 혼동되지 않게하기 위해서 0으로 보낸다.
		}

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharDelete( %s ) : %d - %u - %d - %d - %I64dPreMoney - %I64dMoney", GetPublicID().c_str(), iCharArray, dwCharIndex, iResellPeso, iResellLimitDate, iPreMoney, GetMoney() );
		_OnCharDelete( iCharArray );

		if( m_select_char > iCharArray )
			m_select_char = max( 0, m_select_char - 1 );
		else if( m_select_char == iCharArray )
		{
			//
			m_select_char = 0;
			for(i = 0;i < GetCharCount();i++)
			{
				if( m_CharList[i]->IsActive() )
				{
					m_select_char = i;
					break;
				}
			}			
		}	
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharDelete( %s ) NewArray : %d", GetPublicID().c_str(), m_select_char  );
	}

	SP2Packet kPacket( STPK_CHAR_DELETE );

	PACKET_GUARD_VOID( kPacket.Write(iResult) );
	PACKET_GUARD_VOID( kPacket.Write(dwCharIndex) );
	PACKET_GUARD_VOID( kPacket.Write(iResellPeso) ); 
	PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );

	SendMessage( kPacket );
}

void User::OnCharSlotChange( SP2Packet &rkPacket )
{
	int iLeftSlotIndex, iRightSlotIndex;
	rkPacket >> iLeftSlotIndex >> iRightSlotIndex;

	if( !COMPARE( iLeftSlotIndex, 0, m_iCurMaxCharSlot ) || !COMPARE( iRightSlotIndex, 0, m_iCurMaxCharSlot ) ) 
	{
		SP2Packet kPacket( STPK_CHAR_SLOT_CHANGE );
		kPacket << CHAR_SLOT_CHANGE_FAIL;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharSlotChange : Slot Index Error : %d : %d", iLeftSlotIndex, iRightSlotIndex  );
		return;
	}

	if( iLeftSlotIndex == iRightSlotIndex )
	{
		SP2Packet kPacket( STPK_CHAR_SLOT_CHANGE );
		kPacket << CHAR_SLOT_CHANGE_FAIL;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharSlotChange : Slot Index Equal : %d : %d", iLeftSlotIndex, iRightSlotIndex  );
		return;
	}

	int iLeftArray = GetCharSlotIndexToArray( iLeftSlotIndex );
	int iRightArray = GetCharSlotIndexToArray( iRightSlotIndex );

	if( COMPARE( iLeftArray, 0, GetCharCount() ) )
	{
        m_CharList[iLeftArray]->SetCharSlotIndex( iRightSlotIndex );	
	}
	if( COMPARE( iRightArray, 0, GetCharCount() ) )
	{
		m_CharList[iRightArray]->SetCharSlotIndex( iLeftSlotIndex );
	}
	SP2Packet kPacket( STPK_CHAR_SLOT_CHANGE );
	kPacket << CHAR_SLOT_CHANGE_OK << iLeftSlotIndex << iRightSlotIndex;
	SendMessage( kPacket );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCharSlotChange : %d < - > %d", iLeftSlotIndex, iRightSlotIndex );
}

void User::OnChangeLeaderChar( SP2Packet &rkPacket )
{
	DWORD dwCharIndex;
	rkPacket >> dwCharIndex;

	int i = 0;
	int iCharArray = -1;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
		{
			iCharArray = i;
			break;
		}
	}

	if( iCharArray == -1 )
	{
		SP2Packet kPacket( STPK_CHANGE_MY_LEADER );
		kPacket << false;	// 실패
		SendMessage( kPacket );
	}
	else
	{
		for(i = 0;i < GetCharCount();i++)
		{
			if( m_CharList[i]->GetCharIndex() == dwCharIndex )
			{
				m_CharList[i]->SetLeaderType( CLT_LEADER );
			}
			else if( m_CharList[i]->GetLeaderType() == CLT_LEADER )
			{
				m_CharList[i]->SetLeaderType( CLT_GENERAL );
			}
		}
		
		SP2Packet kPacket( STPK_CHANGE_MY_LEADER );
		kPacket << true << dwCharIndex;	// 성공
		SendMessage( kPacket );
	}
}

int User::_OnSetMyRentalCharException( DWORD dwCharIndex )
{
	if( GetGradeLevel() < Help::GetCharRentalGrade() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_GRADE_LIMIT", GetPublicID().c_str() );
		return SET_MY_RENTAL_GRADE_LIMIT;
	}

	int i = 0;
	int iMaxRentalChar = 0;
	ioCharacter *pSelectChar = NULL;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetRentalType() == CRT_RENTAL )
		{
			iMaxRentalChar++;
		}

		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
			pSelectChar = m_CharList[i];
	}

	if( iMaxRentalChar >= Help::GetMaxCharRentSet() )
	{	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_SET_LIMIT", GetPublicID().c_str() );
		return SET_MY_RENTAL_SET_LIMIT;
	}

	if( !pSelectChar )
	{	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_NONE_CHAR", GetPublicID().c_str() );
		return SET_MY_RENTAL_NONE_CHAR;
	}

	if( !pSelectChar->IsMortmain() )
	{	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_MORTMAIN_LIMIT", GetPublicID().c_str() );
		return SET_MY_RENTAL_MORTMAIN_LIMIT;
	}

	if( !pSelectChar->HasExerciseStyle( EXERCISE_NONE ) )
	{	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_EXERCISE_LIMIT", GetPublicID().c_str() );
		return SET_MY_RENTAL_EXERCISE_LIMIT;
	}

	if( pSelectChar->IsCharEquipExtraItemPeriodCheck( this, ioUserExtraItem::EPT_TIME ) ||
		pSelectChar->IsCharEquipExtraItemPeriodCheck( this, ioUserExtraItem::EPT_GROW_TIME ) )
	{	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_EXTRAITEM_LIMIT", GetPublicID().c_str() );
		return SET_MY_RENTAL_EXTRAITEM_LIMIT;
	}

	int iTimeGrowthCnt = m_UserGrowthLevel.GetCurTimeGrowthCntInChar( pSelectChar->GetCharInfo().m_class_type );
	if( iTimeGrowthCnt > 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "_OnSetMyRentalCharException %s : SET_MY_RENTAL_TIMEGROWTH_LIMIT", GetPublicID().c_str() );
		return SET_MY_RENTAL_TIMEGROWTH_LIMIT;
	}

	return SET_MY_RENTAL_OK;
}

void User::OnSetMyRentalChar( SP2Packet &rkPacket )
{
	short sRentalType;
	DWORD dwCharIndex;
	rkPacket >> dwCharIndex >> sRentalType;

	int i = 0;
	if( sRentalType == CRT_GENERAL )
	{
		for(i = 0;i < GetCharCount();i++)
		{
			if( m_CharList[i]->GetCharIndex() == dwCharIndex )
			{
				m_CharList[i]->CheckRentalLimitTime();
				if( m_CharList[i]->GetRentalLimitTime() != 0 )
				{
					SP2Packet kPacket( STPK_SET_MY_RENTAL );
					kPacket << SET_MY_RENTAL_USE_LIMIT << dwCharIndex << m_CharList[i]->GetRentalLimitTime();	
					SendMessage( kPacket );
					return;
				}
				else
				{
					m_CharList[i]->SetRentalType( CRT_GENERAL );
				}
				break;
			}
		}

		SP2Packet kPacket( STPK_SET_MY_RENTAL );
		kPacket << SET_MY_RENTAL_OK << dwCharIndex << sRentalType;	
		SendMessage( kPacket );
	}
	else
	{
		int iResult = _OnSetMyRentalCharException( dwCharIndex );
		if( iResult != SET_MY_RENTAL_OK )
		{
			SP2Packet kPacket( STPK_SET_MY_RENTAL );
			kPacket << iResult;	
			SendMessage( kPacket );

		}
		else
		{		
			for(i = 0;i < GetCharCount();i++)
			{
				if( m_CharList[i]->GetCharIndex() == dwCharIndex )
				{
					m_CharList[i]->SetRentalType( CRT_RENTAL );
					break;
				}
			}

			SP2Packet kPacket( STPK_SET_MY_RENTAL );
			kPacket << SET_MY_RENTAL_OK << dwCharIndex << sRentalType;	
			SendMessage( kPacket );
		}
	}
}

void User::OnJoinRoom( SP2Packet &packet )
{
}

void User::OnSearchPlazaRoom( SP2Packet &rkPacket )
{
	if( GetCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnSearchPlazaRoom ERROR : 구매/체험 용병이 없는 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );

		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_8 ) );
		SendMessage( kPacket );

		return;
	}

	if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "임시가입만료 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );

		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_9 ) );
		SendMessage( kPacket );

		return;
	}
	
	if( IsReserveServerMoving() )          //서버 이동이 예약되었다.
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "서버 이동이 예약된 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );

		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_10 ) );
		SendMessage( kPacket );

		return;
	}

	bool bInvite	= false;
	int iRoomIndex	= 0;
	RoomParent *pRoomParent = NULL;
	
	PACKET_GUARD_VOID( rkPacket.Read( iRoomIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( bInvite ) );

	if( iRoomIndex == -1 )
	{
		pRoomParent = g_RoomNodeManager.GetJoinGlobalPlazaNode( GetKillDeathLevel(), (RoomParent*)m_pMyRoom );
	}
	else if( iRoomIndex == -2 )
	{
		//로그인 -> 로비 (방번호 검색)
		pRoomParent = g_RoomNodeManager.GetAutoCreatePlazaNode( GetKillDeathLevel() );

		//입장가능한 방이 없을경우 현재 서버에 광장 생성
		if( !pRoomParent )
		{
			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );  
			AutoCreatePlaza( kPacket );
			return;
		}
	}
	else
		pRoomParent = g_RoomNodeManager.GetJoinGlobalPlazaNodeByNum( iRoomIndex );

	if( pRoomParent )
	{
		if( pRoomParent->GetPlazaModeType() == PT_GUILD && !IsGuild() )
		{
			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_6 ) );
			SendMessage( kPacket );
			return;
		}

		if( m_pMyRoom )
		{
			if( (RoomParent*)m_pMyRoom == pRoomParent )
			{
				// 동일 룸 
				SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
				PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_1 ) );
				SendMessage( kPacket );
				return;
			}
			else if( !m_pMyRoom->IsNoBattleModeType() )
			{
				// 이미 훈련 / 전투 룸에 입장했으면 광장 이동은 무시
				SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
				PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_5 ) );
				SendMessage( kPacket );
				return;
			}
		}

		if( pRoomParent->IsRoomFull() )       
		{
			// 인원 제한
			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_3 ) );
			SendMessage( kPacket );
			return;
		}
//		else if( !bInvite && !IsDeveloper() && !g_LevelMatchMgr.IsPlazaLevelJoin( pRoomParent->GetAverageLevel(), GetKillDeathLevel(), JOIN_CHECK_MIN_LEVEL ) )
//		{
//			// 수준 매칭
//			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
//			kPacket << SEARCH_TRAINING_ERROR_7;
//			SendMessage( kPacket );
//			return;
//		}
		else if( pRoomParent->IsRoomPW() && !IsDeveloper() )
		{
			ioHashString szPW;
			PACKET_GUARD_VOID( rkPacket.Read(szPW) );
			if( pRoomParent->GetRoomPW() != szPW )
			{
				// 비밀번호 오류
				SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
				PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_2 ) );
				SendMessage( kPacket );
				return;
			}
		}

		if( pRoomParent->IsRoomOriginal() )
		{
			Room *pRoom = (Room*)pRoomParent;
			// 입장
			SP2Packet kPacket( STPK_JOIN_ROOM );   
			PACKET_GUARD_VOID( kPacket.Write( JOIN_ROOM_OK ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeType() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeSubNum() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeMapNum() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetRoomNumber() ) );
			PACKET_GUARD_VOID( kPacket.Write( (int)pRoom->GetPlazaModeType() ) );
			SendMessage( kPacket );
			EnterRoom( pRoom );

			if( m_pMyRoom )
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnSearchPlazaRoom : %d", m_pMyRoom->GetRoomIndex() );
		}
		else
		{
			RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;
			// 룸 입장 전송
			SP2Packet kPacket( SSTPK_MOVING_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN_PLAZA ) );
			PACKET_GUARD_VOID( kPacket.Write( iRoomIndex ) );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( GetKillDeathLevel() ) );

			pCopyRoom->SendMessage( kPacket );
		}
	}
	else
	{
		// 원하는 룸이 없다.
		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_4 ) );
		SendMessage( kPacket );
	}
}

int User::CheckPlazaCreateDefaultErr()
{
	if( GetCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "err 구매/체험 용병이 없는 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );
		return CREATE_PLAZA_ERROR_3;
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "err 임시가입만료 유저가 광장 생성 요청 : %s", GetPublicID().c_str() );
		
		return CREATE_PLAZA_ERROR_4;
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		// 이미 훈련 / 전투 룸에 입장했으면 광장 이동은 무시]
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "err 이미 훈련, 전투룸이 입장 : %s", GetPublicID().c_str() );

		return SEARCH_TRAINING_ERROR_5;
	}
	else if( IsReserveServerMoving() )          //서버 이동이 예약되었다.
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "err 서버 이동이 예약된 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );
		return SEARCH_TRAINING_ERROR_5;
	}
	
	return 0;
}

void User::SetPlazaInfoWithPacket( SP2Packet &rkPacket, ioHashString& szPlazaName, ioHashString& szPlazaPW, int& iMaxPlayer, int& iSubIndex, int& iPlazaType )
{
	int iResult = CheckPlazaCreateDefaultErr();
	
	if( iResult != 0 )
	{
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		PACKET_GUARD_VOID( kPacket.Write( iResult ) );
		SendMessage( kPacket );
		return;
	}

	PACKET_GUARD_VOID( rkPacket.Read( szPlazaName ) );
	PACKET_GUARD_VOID( rkPacket.Read( szPlazaPW ) );
	PACKET_GUARD_VOID( rkPacket.Read( iMaxPlayer ) );
	PACKET_GUARD_VOID( rkPacket.Read( iPlazaType ) );
	PACKET_GUARD_VOID( rkPacket.Read( iSubIndex ) );
}

void User::SetPlazaInfoWithDefault( int& iMaxPlayer, int& iSubIndex, int& iPlazaType )
{
	int iResult = CheckPlazaCreateDefaultErr();
	
	if( iResult != 0 )
	{
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		PACKET_GUARD_VOID( kPacket.Write( iResult ) );
		SendMessage( kPacket );
		return;
	}

	iMaxPlayer = 16;
	iSubIndex = -1;
	iPlazaType = PT_COMMUNITY ;
}

void User::SetPlazaInfoWithGuild(int& iMaxPlayer, int& iPlazaType)
{
	int iResult = CheckPlazaCreateDefaultErr();
	
	if( iResult != 0 )
	{
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		PACKET_GUARD_VOID( kPacket.Write( iResult ) );
		SendMessage( kPacket );
		return;
	}

	iMaxPlayer = 32;
	iPlazaType = PT_GUILD;
}

void User::AutoCreatePlaza( SP2Packet &rkPacket )
{
	ioHashString szPlazaName, szPlazaPW;
	int iMaxPlayer, iSubIndex, iPlazaType;
	bool bResult = false;

	SetPlazaInfoWithDefault( iMaxPlayer, iSubIndex, iPlazaType );

	bResult = CreatePlazaInThisSvr( szPlazaName, szPlazaPW, iMaxPlayer, iSubIndex, iPlazaType, true );

	if( !bResult )
	{
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		PACKET_GUARD_VOID( kPacket.Write( CREATE_PLAZA_ERROR_1 ) );
		SendMessage( kPacket );
	}
}

bool User::CreatePlazaInThisSvr( ioHashString& szPlazaName, ioHashString& szPlazaPW, int iMaxPlayer, int iSubIndex, int iPlazaType, bool bAuto )
{
	if( PT_GUILD == iPlazaType )
	{
		// 메인서버 연결 확인.
		if( !g_MainServer.IsActive() )
			return false;
	}

	Room *pRoom = g_RoomNodeManager.CreateNewPlazaRoom( iSubIndex );
	if( pRoom )
	{
		if( !bAuto )
			pRoom->SetRoomMasterID( GetPublicID() );
		if( !szPlazaName.IsEmpty() )
			pRoom->SetRoomName( szPlazaName );
		if( !szPlazaPW.IsEmpty() )
			pRoom->SetRoomPW( szPlazaPW );

		pRoom->SetMaxPlayer( iMaxPlayer );
		pRoom->SetPlazaModeType( (PlazaType)iPlazaType );

		if( PT_GUILD == iPlazaType )
		{
			//해당 방에 길드 오브젝트 정보를 읽는다.
			g_DBClient.OnSelectGuildBlocksInfos(GetUserIndex(), GetGuildIndex(), pRoom->GetRoomIndex());
		}
		else
		{
			// 입장
			SP2Packet kPacket( STPK_JOIN_ROOM );   
			PACKET_GUARD_bool( kPacket.Write( JOIN_ROOM_OK ) );
			PACKET_GUARD_bool( kPacket.Write( pRoom->GetModeType() ) );
			PACKET_GUARD_bool( kPacket.Write( pRoom->GetModeSubNum() ) );
			PACKET_GUARD_bool( kPacket.Write( pRoom->GetModeMapNum() ) );
			PACKET_GUARD_bool( kPacket.Write( pRoom->GetRoomNumber() ) );
			PACKET_GUARD_bool( kPacket.Write( (int)pRoom->GetPlazaModeType() ) );

			SendMessage( kPacket );
			EnterRoom( pRoom );
		}
	}
	else
		return false;

	return true;
}

void User::OnCreatePlaza( SP2Packet &rkPacket )
{
	// 광장 정보
	ioHashString szPlazaName, szPlazaPW;
	int iMaxPlayer, iSubIndex, iPlazaType;

	SetPlazaInfoWithPacket( rkPacket, szPlazaName, szPlazaPW, iMaxPlayer, iSubIndex, iPlazaType );

	if( iPlazaType == PT_GUILD && !IsGuild() )
	{
		// 룸생성 실패
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		kPacket << CREATE_PLAZA_ERROR_2;
		SendMessage( kPacket );
		return;
	}

	// 룸이 적은 서버에 생성 시킨다
	DWORD dwServerIndex = 0;
	bool bResult = g_ServerNodeManager.GetSelectPlazaServer( g_RoomNodeManager.GetPlazaNodeSize(), dwServerIndex );
	if( bResult )
	{
		if( 0 == dwServerIndex )  // 현재 서버에 방을 생성한다
		{
			bResult = CreatePlazaInThisSvr( szPlazaName, szPlazaPW, iMaxPlayer, iSubIndex, iPlazaType, false );
		}
		else // 다른 서버에 방을 생성한다
		{
			ServerNode* pSelectServer = g_ServerNodeManager.GetServerNode( dwServerIndex );
			if( pSelectServer )
			{
				//룸 생성과 동시에 해당 서버로 이동시킨다.
				SP2Packet kPacket( SSTPK_RESERVE_CREATE_ROOM );
				//모드 정보
				PACKET_GUARD_VOID( kPacket.Write( false ) );
				PACKET_GUARD_VOID( kPacket.Write( (int)MT_TRAINING ) );
				PACKET_GUARD_VOID( kPacket.Write( iSubIndex ) );
				PACKET_GUARD_VOID( kPacket.Write( 1 ) );
				
				//광장 정보
				PACKET_GUARD_VOID( kPacket.Write( szPlazaName ) );
				PACKET_GUARD_VOID( kPacket.Write( szPlazaPW ) );
				PACKET_GUARD_VOID( kPacket.Write( iMaxPlayer ) );
				PACKET_GUARD_VOID( kPacket.Write( iPlazaType ) );

				//유저 정보
				PACKET_GUARD_VOID( kPacket.Write( 1 ) );
				PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
				PACKET_GUARD_VOID( kPacket.Write( GetPublicID() ) );
	    
				pSelectServer->SendMessage( kPacket );		
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCreatePlaza Moving Create : %s:%d", pSelectServer->GetServerIP().c_str(), pSelectServer->GetClientPort() );

				SP2Packet kPacket2( STPK_RESERVE_SERVER_MOVE );
				PACKET_GUARD_VOID( kPacket2.Write( (int)MT_TRAINING ) );
				PACKET_GUARD_VOID( kPacket2.Write( iSubIndex ) );
				PACKET_GUARD_VOID( kPacket2.Write( 1 ) );
				PACKET_GUARD_VOID( kPacket2.Write( iPlazaType ) );
				
				SendMessage( kPacket2 );
				ReserveServerMoving();
			}
			else
			{
				bResult = false;
			}
		}
	}

	if( !bResult )
	{
		// 방을 생성할 수 있는 곳이 없다
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		PACKET_GUARD_VOID( kPacket.Write( CREATE_PLAZA_ERROR_1 ) );
		SendMessage( kPacket );
	}
}

void User::OnPlazaCommand( SP2Packet &rkPacket )
{
	if( !m_pMyRoom ) return;
	if( m_pMyRoom->GetModeType() != MT_TRAINING ) return;

	int iCommand;
	rkPacket >> iCommand;
	switch( iCommand )
	{
	case PLAZA_CMD_NAME_PW_CHANGE:
		{
			ioHashString szName, szPW;
			rkPacket >> szName >> szPW;
			m_pMyRoom->SetRoomName( szName );
			m_pMyRoom->SetRoomPW( szPW );

			SP2Packet kPacket( STPK_PLAZA_COMMAND );
			kPacket << PLAZA_CMD_NAME_PW_CHANGE << szName << szPW;
			m_pMyRoom->RoomSendPacketTcp( kPacket, this );
		}
		break;
	case PLAZA_CMD_MAXPLAYER_CHANGE:
		{
			int iMaxPlayer;
			rkPacket >> iMaxPlayer;
			m_pMyRoom->SetMaxPlayer( iMaxPlayer );

			SP2Packet kPacket( STPK_PLAZA_COMMAND );
			kPacket << PLAZA_CMD_MAXPLAYER_CHANGE << m_pMyRoom->GetMaxPlayer();
			m_pMyRoom->RoomSendPacketTcp( kPacket );
		}
		break;
	case PLAZA_CMD_KICK_OUT:
		{
			if( m_pMyRoom->GetMasterName() != GetPublicID() ) 
				return;

			ioHashString szKickOutUser;
			rkPacket >> szKickOutUser;
			m_pMyRoom->RoomKickOut( szKickOutUser );
		}
		break;
	}
}

void User::OnPlazaInviteList( SP2Packet &rkPacket )
{
	if( m_pMyRoom == NULL ) return;
	if( m_pMyRoom->GetModeType() != MT_TRAINING ) return;

	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_UserNodeManager.SendPlazaInviteList( this, m_pMyRoom->GetPlazaModeType(), iCurPage, iMaxCount, m_pMyRoom->GetAverageLevel() );
}


void User::OnPlazaInvite( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
		return;

	if( m_pMyRoom->IsRoomFull() )
		return;

	if( m_pMyRoom->GetModeType() != MT_TRAINING )
		return;

	if( m_pMyRoom->GetPlazaModeType() == PT_COMMUNITY )
		return;

	if( IsReserveServerMoving() )          //서버 이동이 예약되었다.
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "서버 이동이 예약된 유저가 광장 초대 수락 : %s", GetPublicID().c_str() );
		return;
	}

	int iInviteCount	= 0;
	PACKET_GUARD_VOID( rkPacket.Read(iInviteCount) );

	SP2Packet kPacket( STPK_PLAZA_USER_INVITE );
	PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetRoomNumber()) );
	PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetRoomIndex()) );
	PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetRoomName()) );
	PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetRoomPW()) );
	PACKET_GUARD_VOID( kPacket.Write((int)m_pMyRoom->GetPlazaModeType()) );
	PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetModeSubNum()) );
	PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetMaxPlayer()) );
	m_pMyRoom->FillUserList( kPacket );

	for(int i = 0;i < iInviteCount;i++)
	{
		ioHashString szInvitedID;
		PACKET_GUARD_VOID( rkPacket.Read(szInvitedID) );

		UserParent *pUser = g_UserNodeManager.GetGlobalUserNode( szInvitedID );
		if( pUser )
		{	
			if( m_pMyRoom->GetPlazaModeType() == PT_GUILD )
			{
				if( GetGuildIndex() != pUser->GetGuildIndex() )
					continue;
			}

			pUser->RelayPacket( kPacket );
		}
	}
}

void User::OnPlazaRoomList( SP2Packet &rkPacket )
{
	int iCurPage = 0, iMaxCount = 0;

	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_RoomNodeManager.SendPlazaRoomList( this, iCurPage, iMaxCount );
}

void User::OnHeadquartersInviteList( SP2Packet &rkPacket )
{
	if( m_pMyRoom == NULL ) return;
	if( m_pMyRoom->GetModeType() != MT_HEADQUARTERS ) return;

	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_UserNodeManager.SendHeadquartersInviteList( this, iCurPage, iMaxCount, 0 );
}

void User::_OnJoinHeadquarters( UserParent *pRequestUser, int iMapIndex, bool bInvited )
{
	if( pRequestUser == NULL ) return;

	if( IsReserveServerMoving() ) 
	{
		//서버 이동이 예약되었다.
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ALREADY_BATTLE ) );
		
		pRequestUser->RelayPacket( kPacket );				
		return;
	}

	if( pRequestUser->GetPublicID() != GetPublicID() )
	{
		if( !bInvited )
		{
			if( IsHeadquartersLock() )
			{
				// 잠김
				SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
				PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_LOCK ) );
				pRequestUser->RelayPacket( kPacket );				
				return;
			}
			else if( m_pMyRoom && m_pMyRoom->GetRoomIndex() == (int)m_dwMyHeadquartersIndex )   // 본부에 주인이 있으면 띵똥
			{
				if( m_pMyRoom->IsRoomFull() )
				{
					SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
					PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ROOM_FULL ) );
					pRequestUser->RelayPacket( kPacket );
				}
				else
				{
					SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
					PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_JOIN_REQUEST ) );
					pRequestUser->RelayPacket( kPacket );		

					SP2Packet kPacket2( STPK_HEADQUARTERS_JOIN_REQUEST );
					PACKET_GUARD_VOID( kPacket2.Write( pRequestUser->GetPublicID() ) );
					SendMessage( kPacket2 );
				}
				return;
			}
		}
	}

	RoomParent *pRoomParent = g_RoomNodeManager.GetHeadquartersGlobalNode( m_dwMyHeadquartersIndex );
	if( pRoomParent )
	{
		if( pRoomParent->IsRoomFull() )
		{
			SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ROOM_FULL ) );
			pRequestUser->RelayPacket( kPacket );
			return;
		}		
	}
	else
	{
		// 룸 생성
		Room *pRoom = g_RoomNodeManager.CreateNewHeadquartersRoom( iMapIndex );
		if( !pRoom)
		{
			// 메모리가 부족하다
			SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ROOM_CREATE_FAILED ) );
			pRequestUser->RelayPacket( kPacket );				
			return;
		}

		pRoom->SetHeadquartersMaster( GetPublicID() );
		pRoom->SetMaxPlayer( MAX_PLAZA_PLAYER );
		pRoom->CreateHeadquartersCharacter( this );
		if( GetPublicID() == pRequestUser->GetPublicID() )
			pRoom->SetHeadquartersCharState( HeadquartersMode::STATE_OPEN_CHAR );
		else
			pRoom->SetHeadquartersCharState( HeadquartersMode::STATE_DISPLAY_CHAR );

		pRoomParent = pRoom;
	}

	if( pRoomParent )
	{
		m_dwMyHeadquartersIndex = pRoomParent->GetRoomIndex();
		if( pRoomParent->IsRoomOriginal() )
		{
			Room *pRoom = static_cast< Room * >( pRoomParent );

			// 입장
			if( pRequestUser->IsUserOriginal() )
			{				
				User *pUser = static_cast< User * >( pRequestUser );

				SP2Packet kPacket( STPK_JOIN_ROOM );   
				PACKET_GUARD_VOID( kPacket.Write( JOIN_ROOM_OK ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeType() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeSubNum() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeMapNum() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetRoomNumber() ) );
				PACKET_GUARD_VOID( kPacket.Write( (int)pRoom->GetPlazaModeType() ) );
				
				pUser->SendMessage( kPacket );
				pUser->EnterRoom( pRoom );
			}
			else
			{
				pRoom->EnterReserveUser( pRequestUser->GetUserIndex() );

				// 해당 유저에게 입장 알림
				UserCopyNode *pUser = static_cast< UserCopyNode * >( pRequestUser );

				SP2Packet kPacket( SSTPK_MOVING_ROOM_RESULT );
				PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN ) );
				PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN_HEADQUARTERS ) );
				PACKET_GUARD_VOID( kPacket.Write( (int)pRoom->GetModeType() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetRoomIndex() ) );
				PACKET_GUARD_VOID( kPacket.Write( pUser->GetUserIndex() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeSubNum() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeMapNum() ) );

				pUser->SendMessage( kPacket );
			}
		}
		else
		{
			// 본부가 진짜 있는지 확인하고 있으면 입장하고 없으면 다시 와야한다.  
			RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;
			// 룸 입장 전송
			SP2Packet kPacket( SSTPK_MOVING_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN_HEADQUARTERS ) );
			PACKET_GUARD_VOID( kPacket.Write( pCopyRoom->GetRoomIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRequestUser->GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( iMapIndex ) );
			PACKET_GUARD_VOID( kPacket.Write( bInvited ) );

			pCopyRoom->SendMessage( kPacket );
		}
	}
	else
	{   // 룸생성 실패
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ROOM_CREATE_FAILED ) );

		pRequestUser->RelayPacket( kPacket );
	}
}

void User::OnJoinHeadquarters( SP2Packet &rkPacket )
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		// 이미 훈련 / 전투 룸에 입장했으면 본부 이동은 무시
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ALREADY_BATTLE ) );
		SendMessage( kPacket );		
	}
	else if( IsBattleRoom() )
	{
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ALREADY_BATTLE ) );
		SendMessage( kPacket );		
	}
	else if( IsLadderTeam() )
	{
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ALREADY_BATTLE ) );
		SendMessage( kPacket );		
	}
	else if( IsReserveServerMoving() ) 
	{
		//서버 이동이 예약되었다.
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ALREADY_BATTLE ) );
		SendMessage( kPacket );				
	}
	else
	{
		// 본부 정보
		bool bInvited;
		int iMapIndex;
		ioHashString szOwnerName;

		PACKET_GUARD_VOID( rkPacket.Read( szOwnerName ) );
		PACKET_GUARD_VOID( rkPacket.Read( iMapIndex ) );
		PACKET_GUARD_VOID( rkPacket.Read( bInvited ) );

		if( IsDeveloper() )  // 개발자는 항상 초대받은거로 처리
			bInvited = true;
		
		UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szOwnerName );
		if( pUserParent == NULL )
		{
			// 오너가 오프라인
			SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_OWNER_OFFLINE ) );
			SendMessage( kPacket );
		}
		else if( pUserParent->IsUserOriginal() )
		{
			User *pUser = static_cast< User * >( pUserParent );
			pUser->_OnJoinHeadquarters( this, iMapIndex, bInvited );
		}
		else
		{
			UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );

			SP2Packet kPacket( SSTPK_JOIN_HEADQUARTERS_USER );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( pUser->GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( iMapIndex ) );
			PACKET_GUARD_VOID( kPacket.Write( bInvited ) );
			
			pUser->SendMessage( kPacket );
		}
	}
}

void User::_OnHeadquartersInfo( UserParent *pRequestUser )
{
	if( pRequestUser == NULL ) return;

	if( m_dwMyHeadquartersIndex == 0 )
	{
		SP2Packet kPacket( STPK_HEADQUARTERS_INFO );
		kPacket << GetPublicID() << (MAX_PLAYER / 2) << IsHeadquartersLock() << 0;       // - 
		pRequestUser->RelayPacket( kPacket );
	}
	else
	{
		RoomParent *pRoomParent = g_RoomNodeManager.GetHeadquartersGlobalNode( m_dwMyHeadquartersIndex );
		if( pRoomParent == NULL )
		{
			SP2Packet kPacket( STPK_HEADQUARTERS_INFO );
			kPacket << GetPublicID() << (MAX_PLAYER / 2) << IsHeadquartersLock() << 0;       // - 
			pRequestUser->RelayPacket( kPacket );
		}
		else if( pRoomParent->IsRoomOriginal() )
		{
			Room *pRoom = static_cast< Room * >( pRoomParent );
			SP2Packet kPacket( STPK_HEADQUARTERS_INFO );
			pRoom->FillHeadquartersInfo( GetPublicID(), IsHeadquartersLock(), kPacket );
			pRequestUser->RelayPacket( kPacket );
		}
		else
		{
			// 룸이 있는 서버로 신호 전송
			RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;
			SP2Packet kPacket( SSTPK_HEADQUARTERS_ROOM_INFO );
			kPacket << pCopyRoom->GetRoomIndex() << GetPublicID() << IsHeadquartersLock() << pRequestUser->GetUserIndex();
			pCopyRoom->SendMessage( kPacket );
		}
	}
}

void User::OnHeadquartersInfo( SP2Packet &rkPacket )
{
	// 본부 정보
	ioHashString szOwnerName;
	rkPacket >> szOwnerName;

	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szOwnerName );
	if( pUserParent == NULL )
	{
		// 오너가 오프라인
		SP2Packet kPacket( STPK_HEADQUARTERS_INFO );
		kPacket << szOwnerName << (MAX_PLAYER / 2) << false << 0;       // - 
		SendMessage( kPacket );
	}
	else if( pUserParent->IsUserOriginal() )
	{
		User *pUser = static_cast< User * >( pUserParent );
		pUser->_OnHeadquartersInfo( this );
	}
	else
	{
		UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );

		SP2Packet kPacket( SSTPK_HEADQUARTERS_INFO );
		kPacket << GetUserIndex() << pUser->GetUserIndex() << GetPublicID();
		pUser->SendMessage( kPacket );
	}
}

void User::_OnHeadquartersJoinAgree( DWORD dwHeadquartersModeIndex )
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnHeadquartersJoinAgree - %d Is Battle/Ladder Room", GetUserIndex() );
	}
	else if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnHeadquartersJoinAgree - %d Is Battle/Ladder Room", GetUserIndex() );
	}
	else if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnHeadquartersJoinAgree - %d Is Battle/Ladder Room", GetUserIndex() );
	}
	else if( IsReserveServerMoving() ) 
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnHeadquartersJoinAgree - %d Already Server Moving...", GetUserIndex() );
	}
	else
	{
		RoomParent *pRoomParent = g_RoomNodeManager.GetHeadquartersGlobalNode( dwHeadquartersModeIndex );
		if( pRoomParent )
		{
			if( pRoomParent->IsRoomFull() )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnHeadquartersJoinAgree - %d - Full HQ.", dwHeadquartersModeIndex );
				return;
			}		
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnHeadquartersJoinAgree - %d - None HQ.", dwHeadquartersModeIndex );
			return;
		}

		if( pRoomParent )
		{
			if( pRoomParent->IsRoomOriginal() )
			{
				Room *pRoom = static_cast< Room * >( pRoomParent );

				// 입장
				SP2Packet kPacket( STPK_JOIN_ROOM );   
				kPacket << JOIN_ROOM_OK;
				kPacket << pRoom->GetModeType();
				kPacket << pRoom->GetModeSubNum();
				kPacket << pRoom->GetModeMapNum();
				kPacket << pRoom->GetRoomNumber();
				kPacket << (int)pRoom->GetPlazaModeType();
				SendMessage( kPacket );
				EnterRoom( pRoom );
			}
			else
			{
				// 본부가 진짜 있는지 확인하고 입장
				RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;

				// 룸 입장 전송
				SP2Packet kPacket( SSTPK_MOVING_ROOM );
				kPacket << SS_MOVING_ROOM_JOIN_HEADQUARTERS_AGREE << pCopyRoom->GetRoomIndex() << GetUserIndex();
				pCopyRoom->SendMessage( kPacket );
			}
		}
	}
}

void User::OnHeadquartersJoinAgree( SP2Packet &rkPacket )
{
	if( m_pMyRoom == NULL ) return;
	if( m_pMyRoom->GetModeType() != MT_HEADQUARTERS ) return;

	ioHashString kRequestName;
	rkPacket >> kRequestName;
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kRequestName );
	if( pUserParent == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnHeadquartersJoinAgree - %s - Owner Offline.", kRequestName.c_str() );
	}
	else if( pUserParent->IsUserOriginal() )
	{
		User *pUser = static_cast< User * >( pUserParent );
		pUser->_OnHeadquartersJoinAgree( m_dwMyHeadquartersIndex );
	}
	else
	{
		UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );

		SP2Packet kPacket( SSTPK_HEADQUARTERS_JOIN_AGREE );
		kPacket << pUser->GetUserIndex() << m_dwMyHeadquartersIndex;
		pUser->SendMessage( kPacket );
	}
}

void User::OnDropItem( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnDropItem - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnDropItem( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	int iGameIndex, iItemCode, iSlot;
	rkPacket >> iGameIndex >> iItemCode >> iSlot;

	ioItem *pPreItem = m_CharList[m_select_char]->ReleaseItem( iGameIndex, iItemCode );
	if( !pPreItem )
	{
		// 아이템 코드로 드랍할 아이템을 찾지 못하면 슬롯 아이템을 무조건 드랍시킨다.
		// 서버와 클라이언트 아이템은 동일한게 맞지만 버그나 핵으로 인해 아이템 코드가 
		// 왜곡되면 아이템을 벗지 않아 죽지 않게 되므로 아이템은 무조건 드랍이 원칙
		pPreItem = m_CharList[m_select_char]->ReleaseItem( iSlot );
	}

	if( !pPreItem || !m_pMyRoom->IsCanPickItemState() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnDropItem - %s Not Has Item %d - %d", GetPublicID().c_str(), iItemCode, iSlot );

		SP2Packet kFailReturn( STPK_DROP_ITEM_FAIL );
		kFailReturn << GetPublicID();
		kFailReturn << iSlot;
		SendMessage( kFailReturn );
		return;
	}

	float fCurGauge;
	rkPacket >> fCurGauge;
	pPreItem->SetCurItemGauge( fCurGauge );

	int iCurBullet;
	rkPacket >> iCurBullet;

	Vector3 vDropPos;
	rkPacket >> vDropPos;
	pPreItem->SetItemPos( vDropPos );

	bool bDropZone;
	rkPacket >> bDropZone;


	if( pPreItem->IsNotDeleteItem() && pPreItem->GetCrownItemType() == ioItem::MCT_NONE && bDropZone )
	{
		pPreItem->SetEnableDelete( false );

		m_iCurCheckKingIndex = 0;
		m_iCurRecvKingPingCnt = 0;
	}

	m_pMyRoom->DropItemOnField( this, pPreItem, iSlot, fCurGauge, iCurBullet );
	m_pMyRoom->NotifyDropItemToMode( pPreItem );
}

void User::OnItemMoveDrop( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnItemMoveDrop - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnItemMoveDrop( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	int iGameIndex, iItemCode, iSlot;
	rkPacket >> iGameIndex >> iItemCode >> iSlot;

	ioItem *pPreItem = m_CharList[m_select_char]->ReleaseItem( iGameIndex, iItemCode );
	if( !pPreItem || !m_pMyRoom->IsCanPickItemState() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnItemMoveDrop - %s Not Has Item %d", GetPublicID().c_str(), iItemCode );

		SP2Packet kFailReturn( STPK_DROP_ITEM_FAIL );
		kFailReturn << GetPublicID();
		kFailReturn << iSlot;
		SendMessage( kFailReturn );
		return;
	}

	float fCurGauge;
	rkPacket >> fCurGauge;
	pPreItem->SetCurItemGauge( fCurGauge );

	int iCurBullet;
	rkPacket >> iCurBullet;

	// Drop Info
	ioHashString szAttacker, szSkillName;
	Vector3 vStartPos, vDropPos;
	float fMoveSpeed;

	rkPacket >> szAttacker >> szSkillName >> vStartPos >> vDropPos >> fMoveSpeed;

	pPreItem->SetItemPos( vStartPos );

	m_pMyRoom->MoveDropItemOnField( this, pPreItem, iSlot, fCurGauge, iCurBullet, szAttacker, szSkillName, vDropPos, fMoveSpeed );
	m_pMyRoom->NotifyDropItemToMode( pPreItem );
}

void User::OnAllItemDrop( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAllItemDrop - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAllItemDrop( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	int iCnt = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCnt) );
	MAX_GUARD(iCnt, 10);

	if( iCnt == 0 )
	{
		// Exception
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAllItemDrop - %s ItemCnt Zero.", GetPublicID().c_str() );
		return;
	}

	// Fill
	SP2Packet kPacket( STPK_ALL_ITEM_DROP );
	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
	PACKET_GUARD_VOID( kPacket.Write(iCnt) );

	for( int i=0; i < iCnt; ++i )
	{
		int iGameIndex = 0, iItemCode = 0, iSlot = 0;
		PACKET_GUARD_VOID( rkPacket.Read(iGameIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(iItemCode) );
		PACKET_GUARD_VOID( rkPacket.Read(iSlot) );

		float fCurGauge = 0.0f;
		int iCurBullet = 0;
		Vector3 vDropPos;
		bool bDropZone = false;

		PACKET_GUARD_VOID( rkPacket.Read(fCurGauge) );
		PACKET_GUARD_VOID( rkPacket.Read(iCurBullet) );
		PACKET_GUARD_VOID( rkPacket.Read(vDropPos) );
		PACKET_GUARD_VOID( rkPacket.Read(bDropZone) );

		ioItem *pPreItem = m_CharList[m_select_char]->ReleaseItem( iGameIndex, iItemCode );
		if( !pPreItem || !m_pMyRoom->IsCanPickItemState() )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAllItemDrop - %s Not Has Item %d", GetPublicID().c_str(), iItemCode );		
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kPacket.Write(vDropPos) );
			PACKET_GUARD_VOID( kPacket.Write(fCurGauge) );
			PACKET_GUARD_VOID( kPacket.Write(iCurBullet) );
			continue;
		}

		pPreItem->SetCurItemGauge( fCurGauge );
		pPreItem->SetItemPos( vDropPos );

		if( pPreItem->IsNotDeleteItem() && pPreItem->GetCrownItemType() == ioItem::MCT_NONE && bDropZone )
		{
			pPreItem->SetEnableDelete( false );

			m_iCurCheckKingIndex = 0;
			m_iCurRecvKingPingCnt = 0;
		}

		m_pMyRoom->AddFieldItem( pPreItem );

		PACKET_GUARD_VOID( kPacket.Write(iSlot) );
		pPreItem->FillFieldItemInfo( kPacket );
		PACKET_GUARD_VOID( kPacket.Write(iCurBullet) );
		m_pMyRoom->NotifyDropItemToMode( pPreItem );
	}

	m_pMyRoom->RoomSendPacketTcp( kPacket );
}

void User::OnChangeGangsi( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChangeGangsi - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChangeGangsi( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	int i = 0, iDropItemCnt = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iDropItemCnt) );
	MAX_GUARD(iDropItemCnt, 10);

	// 아이템을 모두 드랍하고 강시로 만든다.		
	SP2Packet kPacket( STPK_CHANGE_GANGSI );
	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
	{	
		// 드랍 아이템 전송		
		PACKET_GUARD_VOID( kPacket.Write(iDropItemCnt) );
		for(i = 0;i < iDropItemCnt;i++)
		{
			int iGameIndex = 0, iItemCode = 0, iSlot = 0;
			PACKET_GUARD_VOID( rkPacket.Read(iGameIndex) );
			PACKET_GUARD_VOID( rkPacket.Read(iItemCode) );
			PACKET_GUARD_VOID( rkPacket.Read(iSlot) );

			float fCurGauge = 0.0f;
			int iCurBullet = 0;
			Vector3 vDropPos;
			bool bDropZone = false;
			PACKET_GUARD_VOID( rkPacket.Read(fCurGauge) );
			PACKET_GUARD_VOID( rkPacket.Read(iCurBullet) );
			PACKET_GUARD_VOID( rkPacket.Read(vDropPos) );
			PACKET_GUARD_VOID( rkPacket.Read(bDropZone) );

			/*PACKET_GUARD_VOID( rkPacket.Read(fCurGauge) );
			PACKET_GUARD_VOID( rkPacket.Read(iCurBullet) );
			PACKET_GUARD_VOID( rkPacket.Read(vDropPos) );
			PACKET_GUARD_VOID( rkPacket.Read(bDropZone) );*/

			ioItem *pPreItem = m_CharList[m_select_char]->ReleaseItem( iGameIndex, iItemCode );
			if( !pPreItem || !m_pMyRoom->IsCanPickItemState() )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChangeGangsi - %s Not Has Item %d", GetPublicID().c_str(), iItemCode );		
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
				PACKET_GUARD_VOID( kPacket.Write(vDropPos) );
				PACKET_GUARD_VOID( kPacket.Write(fCurGauge) );
				PACKET_GUARD_VOID( kPacket.Write(iCurBullet) );
				continue;
			}
			pPreItem->SetCurItemGauge( fCurGauge );
			pPreItem->SetItemPos( vDropPos );
			if( pPreItem->IsNotDeleteItem() && pPreItem->GetCrownItemType() == ioItem::MCT_NONE && bDropZone )
			{
				pPreItem->SetEnableDelete( false );

				m_iCurCheckKingIndex  = 0;
				m_iCurRecvKingPingCnt = 0;
			}
			m_pMyRoom->AddFieldItem( pPreItem );
			PACKET_GUARD_VOID( kPacket.Write(iSlot) );
			pPreItem->FillFieldItemInfo( kPacket );
			PACKET_GUARD_VOID( kPacket.Write(iCurBullet) );
			m_pMyRoom->NotifyDropItemToMode( pPreItem );
		}
	}

	{	// 강시 세팅
		SetTeam( TEAM_BLUE );		

		EquipGangsiItemToAllChar();

		ioCharacter *rkChar = GetCharacter( m_select_char );    
		if( rkChar == NULL )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChangeGangsi( %s ) GetCharacter Not Using!!", GetPublicID().c_str() );
			// 예외가 발생해도 일단 패킷은 정상적으로 보내줘야 꼬이지 않는다. 예외가 발생한 부분은 해결 필요
			for( int i=0 ; i<MAX_EQUIP_SLOT ; i++ )
			{
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write(0) );
				PACKET_GUARD_VOID( kPacket.Write("") );
			}
		}
		else
		{
			// 아이템 정보
			rkChar->FillEquipItemInfo( kPacket );		
		}
	}
	m_pMyRoom->ChangeGangsiUser( this );
	m_pMyRoom->RoomSendPacketTcp( kPacket );
}

void User::OnGashaponList( SP2Packet &rkPacket )
{
	DWORD dwEtcItemType = 0;
	rkPacket >> dwEtcItemType;
	g_PresentHelper.SendGashponPresentList( this, dwEtcItemType );
}

void User::OnExcavationCommand( SP2Packet &rkPacket )
{
	g_ExcavationMgr.OnExcavationPacket( this, rkPacket );
}

void User::OnPickItem( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnPickItem - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnPickItem( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	int iGameIndex;
	int iItemSlot;
	rkPacket >> iGameIndex;
	rkPacket >> iItemSlot;

	ioItem *pPickItem = m_pMyRoom->FindFieldItem( iGameIndex );
	if( !pPickItem || !m_pMyRoom->IsCanPickItemState() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnPickItem() - Fail!(%s)", GetPublicID().c_str() );

		SP2Packet kFailReturn( STPK_PICK_ITEM_FAIL );
		kFailReturn << GetPublicID();
		kFailReturn << iGameIndex;
		kFailReturn << iItemSlot;
		SendMessage( kFailReturn );
		return;
	}

	if( !m_pMyRoom->IsPickItemToModeUse( pPickItem , this ) )
	{
		SP2Packet kFailReturn( STPK_PICK_ITEM_FAIL );
		kFailReturn << GetPublicID();
		kFailReturn << iGameIndex;
		kFailReturn << iItemSlot;
		SendMessage( kFailReturn );
		return;
	}

	int iEquipedBullet;
	float fEquipedGauge;
	rkPacket >> iEquipedBullet;
	rkPacket >> fEquipedGauge;

	Vector3 vDropPos;
	rkPacket >> vDropPos;
	
	SP2Packet kReturn( STPK_PICK_ITEM );
	kReturn << GetPublicID();
	kReturn << pPickItem->GetGameIndex();
	kReturn << iEquipedBullet;
	kReturn << fEquipedGauge;
	kReturn << vDropPos;
	m_pMyRoom->RoomSendPacketTcp( kReturn );

	ioItem *pPreItem = m_CharList[m_select_char]->EquipItem( pPickItem );
	if( pPreItem )
	{
		pPreItem->SetItemPos( vDropPos );
		m_pMyRoom->AddFieldItem( pPreItem );
	}

	if( pPickItem->GetCrownItemType() != ioItem::MCT_NONE )
	{
		m_iCurCheckKingIndex = 0;
		m_iCurRecvKingPingCnt = 0;
	}
#ifdef ANTIHACK
	//여기서 sp 회복 아이템이면 relaygroup 에도 알려줌..
	//아이템 코드 
	if( pPickItem->GetItemCode() == 401002 || 
		pPickItem->GetItemCode() == 401003 )
	{
		UpdateSpPotion();
	}
#endif
	m_pMyRoom->RemoveFieldItem( pPickItem );
	m_pMyRoom->NotifyPickItemToMode( pPickItem , this );
}

bool User::OnRoomProcessPacket( SP2Packet &rkPacket )
{
	if( m_pMyRoom )
		return m_pMyRoom->ProcessTCPPacket( this, rkPacket );

	return false;
}

bool User::OnBattleRoomProcessPacket( SP2Packet &rkPacket )
{
	if( !IsBattleRoom() )
		return false;
	BattleRoomParent *pBattleRoom = GetMyBattleRoom();
	if( !pBattleRoom )
		return false;

	return pBattleRoom->OnProcessPacket( rkPacket, (UserParent*)this );
}

bool User::OnLadderTeamProcessPacket( SP2Packet &rkPacket )
{
	if( !IsLadderTeam() )
		return false;
	LadderTeamParent *pLadderTeam = GetMyLadderTeam();
	if( !pLadderTeam )
		return false;

	return pLadderTeam->OnProcessPacket( rkPacket, (UserParent*)this );
}

void User::OnChangeChar( SP2Packet &rkPacket )
{
	int iCharArray = 0;
	bool bWait;
	DWORD dwCharChangeIndex;
	rkPacket >> iCharArray >> bWait >> dwCharChangeIndex;
	
	SetChangeChar( iCharArray, bWait, m_select_char, dwCharChangeIndex );
}

void User::OnChangeSingleChar( SP2Packet &rkPacket )
{
	if( m_pMyRoom ) return;

	DWORD dwPrevIdx, dwNextIdx;
	
	rkPacket >>dwPrevIdx >> dwNextIdx;

	int iPrevArray = GetCharArray( dwPrevIdx );
	int iNextArray = GetCharArray( dwNextIdx );

	if( !COMPARE( iPrevArray, 0, GetCharCount() ) || !COMPARE( iNextArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChangeSingleChar - %s Char Overflow(%d - > %d)",
							 GetPublicID().c_str(), iPrevArray, iNextArray );
		return;
	}

	m_select_char = iNextArray;
	
	//캐릭터 정보 전송.
	SP2Packet kPacket( STPK_CHANGE_SINGLE_CHAR );
	kPacket << dwPrevIdx << dwNextIdx;
	SendMessage( kPacket );
}

void User::OnAbstract(SP2Packet &packet)
{
#if 0 
	int iAbstractType;
	packet >> iAbstractType;

	if( iAbstractType == 1 )
	{
		char szTestID[MAX_PATH] = "";
		int abstract_value = 0;
		packet >> abstract_value >> szTestID;

		if( GetPrivateID().IsEmpty() )
		{
			SetPrivateID( szTestID );
			SetPublicID( szTestID );
		}

		SP2Packet kPacket( STPK_ABSTRACT );
		kPacket << abstract_value;
		SendMessage( kPacket );

		UserParent *pTestUser = g_UserNodeManager.GetGlobalUserNode( "개발자B" );
		if( pTestUser )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Good Test Find", pTestUser->GetPublicID().c_str() );
		}
	}
	else if( iAbstractType == 1930 )
	{
		ioHashString szID, szChat;
		packet >> szID >> szChat;

		SP2Packet kSPacket( SSTPK_WHOLE_CHAT );
		kSPacket << szID << szChat;
		g_ServerNodeManager.SendMessageAllNode( kSPacket );

		SP2Packet kPacket ( STPK_WHOLE_CHAT );
		kPacket << szID << szChat;
		g_UserNodeManager.SendMessageAll( kPacket, this );
	}
	else if( iAbstractType == 3000 )
	{
		//ioHashString szID, szChat;
		//packet >> szID >> szChat;

		//SP2Packet kPacket( STPK_ABSTRACT );
		//kPacket << iAbstractType << szID << szChat;
		ioHashString szID;
		packet >> szID;
		char sztemp[ 32768 ] = {0,};
		packet >> sztemp;

		SP2Packet kPacket( STPK_ABSTRACT );
		kPacket << sztemp;

		SendMessage( kPacket );

		// test
		//g_UserNodeManager.SendMessageTest( kPacket, this );
	}
#endif
//for test
	int rommindex;
	packet>>rommindex;
	int opid;
	packet >> opid;

	ioHashString tmp;
	tmp = "127.0.0.1";
	rommindex = 200;

	//g_Relay.InsertRelayGroupReserve(rommindex,rommindex,tmp,rommindex);
	//g_Relay.RemoveRelayGroupReserve(rommindex,0);


}

void User::OnUseItem( SP2Packet &rkPacket )
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnUseItem( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	int iGameIndex	= 0;
	int iItemCode	= 0;
	int eState		= -1;

	PACKET_GUARD_VOID( rkPacket.Read( iGameIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( iItemCode ) );
	PACKET_GUARD_VOID( rkPacket.Read( eState ) );	

	ioItem *pPreItem = m_CharList[m_select_char]->ReleaseItem( iGameIndex, iItemCode );
	if( !pPreItem )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnUseItem - %s Not Has Item %d", GetPublicID().c_str(), iItemCode );
		return;
	}

	delete pPreItem;

	SP2Packet kReturn( STPK_OBJECT_ITEM_RELEASE );
	PACKET_GUARD_VOID( kReturn.Write( GetPublicID() ) ) ;
	PACKET_GUARD_VOID( kReturn.Write( iGameIndex ) ) ;
	PACKET_GUARD_VOID( kReturn.Write( iItemCode ) ) ;
	PACKET_GUARD_VOID( kReturn.Write( eState ) ) ;

	if( m_pMyRoom )
		m_pMyRoom->RoomSendPacketTcp( kReturn );
	else
		SendMessage( kReturn );
}

void User::OnBuyItem( SP2Packet &rkPacket )
{
	int iCharArray;
	rkPacket >> iCharArray;

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBuyItem - %s Char Array Exception(%d)",
								GetPublicID().c_str(), iCharArray );

		SP2Packet kReturn( STPK_BUY_ITEM );
		kReturn << BUY_ITEM_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	DWORD dwSetItemCode, dwSubItemCode;
	rkPacket >> dwSetItemCode >> dwSubItemCode;

	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !pSetInfo )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBuyItem - %s SetItem(%d) Not Exist Exception",
								GetPublicID().c_str(), dwSetItemCode );

		SP2Packet kReturn( STPK_BUY_ITEM );
		kReturn << BUY_ITEM_EXCEPTION;
		SendMessage( kReturn );
		return;
	}	
}

void User::OnIncreaseStat( SP2Packet &rkPacket )
{
	int iCharArray;
	rkPacket >> iCharArray;

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnIncreaseStat - %s Char Array Exception(%d)",
								GetPublicID().c_str(), iCharArray );

		SP2Packet kReturn( STPK_INC_STAT );
		kReturn << INC_STAT_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	if( IsCharJoined( iCharArray ) )
	{
		SP2Packet kReturn( STPK_INC_STAT );
		kReturn << INC_STAT_CHAR_JOINED;
		SendMessage( kReturn );
		return;
	}

	int iSelectStat, iResult;
	rkPacket >> iSelectStat;
	const CHARACTER &kChar = m_CharList[iCharArray]->GetCharInfo();
	iResult = m_CharList[iCharArray]->IncreaseStat( iSelectStat );

	if( iResult == 0 )
	{
		SP2Packet kReturn( STPK_INC_STAT );
		kReturn << INC_STAT_EXCEPTION;
		SendMessage( kReturn );
		return;
	}
	else if( iResult == -1 )
	{
		SP2Packet kReturn( STPK_INC_STAT );
		kReturn << INC_STAT_MAX;
		SendMessage( kReturn );
		return;
	}

	SP2Packet kReturn( STPK_INC_STAT );
	kReturn << INC_STAT_OK;	
	kReturn << iCharArray << iSelectStat;
	kReturn << iResult;
	SendMessage( kReturn );
}

void User::OnInitStat( SP2Packet &rkPacket )
{
	int iCharArray;
	rkPacket >> iCharArray;

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnInitStat - %s Char Array Exception(%d)",
								GetPublicID().c_str(), iCharArray );

		SP2Packet kReturn( STPK_INIT_STAT );
		kReturn << INIT_STAT_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	if( IsCharJoined( iCharArray ) )
	{
		SP2Packet kReturn( STPK_INC_STAT );
		kReturn << INIT_STAT_CHAR_JOINED;
		SendMessage( kReturn );
		return;
	}

	m_CharList[iCharArray]->InitStat();
	const CHARACTER &kChar = m_CharList[iCharArray]->GetCharInfo();

	SP2Packet kReturn( STPK_INIT_STAT );
	kReturn << INIT_STAT_OK;
	kReturn << iCharArray;
	SendMessage( kReturn );
}

void User::OnLevelUpItem( SP2Packet &rkPacket )
{
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "삭제된 패킷 받았음: OnLevelUpItem" );
}

void User::OnJoinBattleRoomList( SP2Packet &rkPacket )
{
	CheckLeaveBattleRoomIndex();

	bool bSameTeamPlayer = false;
	int iPage = 0, iMaxCount = 0, iSelectTerm = 0, iMinPlayer = 0, iMaxPlayer = 0;
	PACKET_GUARD_VOID(rkPacket.Read(iPage));
	PACKET_GUARD_VOID(rkPacket.Read(iMaxCount));
	PACKET_GUARD_VOID(rkPacket.Read(iSelectTerm));
	PACKET_GUARD_VOID(rkPacket.Read(iMinPlayer));
	PACKET_GUARD_VOID(rkPacket.Read(iMaxPlayer));
	PACKET_GUARD_VOID(rkPacket.Read(bSameTeamPlayer));
	MAX_GUARD(iPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_BattleRoomManager.SendCurBattleRoomList( this, iPage, iMaxCount, iSelectTerm, m_iLeaveBattleRoomIndex, iMinPlayer, iMaxPlayer, bSameTeamPlayer );	
}

void User::OnCreateBattleRoom( SP2Packet &rkPacket )
{
	if( IsReserveBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"타서버에 전투방을 예약 생성한 유저가 전투방 생성 요청 :%s",GetPublicID().c_str());
		return;
	}
	else if( IsReserveLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "타서버에 길드팀을 예약 생성한 유저가 전투방 생성 요청 : %s", GetPublicID().c_str() );
		return;
	}

	int result = CREATE_BATTLEROOM_OK;
	BattleRoomNode *pBattleRoom = NULL;

	if( IsBattleRoom() || IsLadderTeam() )
	{
		result = CREATE_BATTLEROOM_NOT;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateBattleRoom : 이미 파티에있는 유저가 파티생성 :%s",GetPublicID().c_str());
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		result = CREATE_BATTLEROOM_NOT;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateBattleRoom : 이미 룸에있는 유저가 파티생성 :%s",GetPublicID().c_str());
	}
	else if( GetBuyCharCount() == 0 )
	{
		result = CREATE_BATTLEROOM_NOT;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateBattleRoom : 구입 용병이 없는 유저가 파티생성 :%s",GetPublicID().c_str());
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		result = CREATE_BATTLEROOM_NOT;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateBattleRoom : 임시가입 만료 유저가 파티생성 :%s", GetPublicID().c_str() );
	}
	else
	{
		int iSelectTerm;
		ioHashString szName, szPW;
		int iBluePlayer, iRedPlayer, iObserver;
		rkPacket >> iSelectTerm >> szName >> szPW >> iBluePlayer >> iRedPlayer >> iObserver;		
		
		DWORD dwServerIndex = 0;
		bool bResult = g_ServerNodeManager.GetSelectBattleRoomServer( g_BattleRoomManager.GetNodeSize(), dwServerIndex );
		if( bResult)
		{
			if( (0 == dwServerIndex) || (GetUserEventType() == USER_TYPE_BROADCAST_AFRICA) || (GetUserEventType() == USER_TYPE_BROADCAST_MBC) )
			{
				pBattleRoom = g_BattleRoomManager.CreateNewBattleRoom();
				if( pBattleRoom )
				{
					if( GetUserEventType() == USER_TYPE_BROADCAST_AFRICA ) 
						pBattleRoom->SetBattleEventType( BET_BROADCAST_AFRICA );
					else if( GetUserEventType() == USER_TYPE_BROADCAST_MBC )
						pBattleRoom->SetBattleEventType( BET_BROADCAST_MBC );

					if( !szName.IsEmpty() )
						pBattleRoom->SetName( szName );
					pBattleRoom->SetPW( szPW );
					pBattleRoom->SetMaxPlayer( iBluePlayer, iRedPlayer, iObserver );
					pBattleRoom->SetDefaultMode( iSelectTerm );
				}
				else
				{
					result = CREATE_BATTLEROOM_NOT;
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateBattleRoom : LowMemory - %d", g_BattleRoomManager.GetNodeSize() );
				}
			}
			else
			{
				ServerNode *pSelectServer = g_ServerNodeManager.GetServerNode( dwServerIndex );
				if( pSelectServer )      
				{			
					SP2Packet kPacket( SSTPK_RESERVE_CREATE_BATTLEROOM );
					kPacket << true << szName << szPW << iBluePlayer << iRedPlayer << iObserver << iSelectTerm;
					kPacket << 1 << GetUserIndex() << GetPublicID();
					pSelectServer->SendMessage( kPacket );

					ReserveBattleRoom( true );
					LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCreateBattleRoom Create : %s:%d", pSelectServer->GetServerIP().c_str(), pSelectServer->GetClientPort() );
					return;
				}

				result = CREATE_BATTLEROOM_NOT;
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCreateBattleRoom Server Failed" );
			}
		}
		else
		{
			result = CREATE_BATTLEROOM_NOT;
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateBattleRoom : Server Full :%d", g_BattleRoomManager.GetNodeSize() );
		}
	}

	SP2Packet kPacket( STPK_CREATE_BATTLEROOM );
	kPacket << result;
	SendMessage( kPacket );

	if( pBattleRoom )
		EnterBattleRoom( pBattleRoom, false );	
}

void User::OnBattleRoomReserveDelete( SP2Packet &rkPacket )
{
}

void User::SetRoomEntryType( bool bServerMove, BYTE& byEntryType )
{
	if( bServerMove )
	{
		if( IsBattleRoom() || IsShuffleRoom() )
			byEntryType = RET_MOVE_ROOM_TO_ROOM;
		else
			byEntryType = RET_MOVE_PLAZA_TO_ROOM;
	}
	else
	{
		if( IsBattleRoom() || IsShuffleRoom() )
			byEntryType = RET_ROOM_TO_ROOM;
		else
			byEntryType = RET_PLAZA_TO_ROOM;
	}
}

void User::_OnBattleRoomJoinResult( int iResultType, bool bMovePenalty, int iPenaltyPeso, bool bServerMove )
{
	if( iResultType != USER_BATTLEROOM_JOIN_OK )
	{
		if( m_iSearchBatleRoomIndex != -1 ) //자동 접속은 결과를 통보하지 않는다.
		{
			BYTE byEntryType = 0;
			SetRoomEntryType(bServerMove, byEntryType);
			SP2Packet kPacket( STPK_USER_BATTLEROOM_JOIN );
			PACKET_GUARD_VOID( kPacket.Write(iResultType) );
			PACKET_GUARD_VOID( kPacket.Write(byEntryType) );
			SendMessage( kPacket );
		}

	}
	m_iSearchBatleRoomIndex = -1;
}

void User::OnUserBattleRoomJoin( SP2Packet &rkPacket )
{
	if( IsReserveBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "타서버에 전투방을 예약 생성한 유저가 전투방 입장 요청 :%s", GetPublicID().c_str() );
		return;
	}
	else if( IsReserveLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "타서버에 길드팀을 예약 생성한 유저가 길드팀 입장 요청 :%s", GetPublicID().c_str() );
		return;
	}
/*	// 전투방에서 전투방으로 이동이 가능해짐 2013.01.31 LJH
	if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserBattleRoomJoin : 이미 파티에있는 유저가 신호보냄 :%s", GetPublicID().c_str() );
		return;
	}
*/	
	if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserBattleRoomJoin : 이미 길드팀에있는 유저가 전투방 입장 요청 :%s", GetPublicID().c_str() );
		return;
	}

	CheckLeaveBattleRoomIndex();

	// 전투방 입장 위치 체크
	/*
	if( m_pMyRoom && m_pMyRoom->GetRoomStyle() == RSTYLE_BATTLEROOM )
		g_App.IncreaseRoomPosCheckCnt( 1 );
	else
		g_App.IncreaseRoomPosCheckCnt( 2 );
	*/

	bool bObserver = false;
	PACKET_GUARD_VOID( rkPacket.Read(bObserver) );

	int iPenaltyPeso = 0;
	bool bInvite = false;
	bool bMovePenalty = false ;
	PACKET_GUARD_VOID( rkPacket.Read(bInvite) );
	PACKET_GUARD_VOID( rkPacket.Read(bMovePenalty) );
	PACKET_GUARD_VOID( rkPacket.Read(iPenaltyPeso) );
	PACKET_GUARD_VOID( rkPacket.Read(m_iSearchBatleRoomIndex) );
	
	int result    = USER_BATTLEROOM_JOIN_OK;
	BattleRoomParent *pBattleRoom = NULL;
	if( m_iSearchBatleRoomIndex == -1 )  //자동 접속.
	{		
		if( IsReserveServerMoving() )          //서버 이동이 예약되었다.
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "서버 이동이 예약된 유저가 전투방 검색 요청 : %s", GetPublicID().c_str() );
			return;
		}
		else if( GetBuyCharCount() == 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnUserBattleRoomJoin : 구입 용병이 없는 유저가 전투룸 검색 :%s",GetPublicID().c_str());
			return;
		}
		else if( GetEntryType() == ET_TERMINATION )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserBattleRoomJoin : 임시가입 만료 유저가 전투룸 검색 :%s", GetPublicID().c_str() );
			return;
		}
/*		else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserBattleRoomJoin : 이미 룸에있는 유저가 신호보냄 :%s", GetPublicID().c_str() );
			return;
		}
*/
		bool bSameTeamPlayer = false;
		int iSearchBattleRoomTerm = 0;
		int iMinPlayer = 0;
		int iMaxPlayer = 0;      // 자동 참여 조건

		PACKET_GUARD_VOID( rkPacket.Read(iSearchBattleRoomTerm) );
		PACKET_GUARD_VOID( rkPacket.Read(iMinPlayer) );
		PACKET_GUARD_VOID( rkPacket.Read(iMaxPlayer) );
		PACKET_GUARD_VOID( rkPacket.Read(bSameTeamPlayer) );

		if( IsBattleRoom() )
			m_iLeaveBattleRoomIndex = GetMyBattleRoomIndex();

		/* 자신이 입장 가능한 파티 검색. */
		pBattleRoom = g_BattleRoomManager.GetJoinBattleRoomNode( m_iLeaveBattleRoomIndex, IsSafetyLevel(), GetGradeLevel(), GetKillDeathLevel(), iSearchBattleRoomTerm, iMinPlayer, iMaxPlayer, bSameTeamPlayer );
		if( !pBattleRoom )    // 파티가 없으면
		{
			return;
		}
	}
	else
	{
		pBattleRoom = g_BattleRoomManager.GetGlobalBattleRoomNode( m_iSearchBatleRoomIndex );
		if( pBattleRoom == NULL )
		{
			//존재하지 않는 파티입니다.
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_NOT_NODE, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( !bObserver && pBattleRoom->IsFull() )
		{
			//인원이 초과 되었습니다.
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_FULL_USER, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( !bObserver && pBattleRoom->IsMapLimitPlayerFull() )
		{
			//맵 최대 인원이 초과 되었습니다.
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_MAP_LIMIT_PLAYER, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( !bObserver && pBattleRoom->IsMapLimitGrade( GetGradeLevel() ) )
		{
			//맵 입장 레벨 제한.
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_MAP_LIMIT_GRADE, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( bObserver && pBattleRoom->IsObserverFull() )
		{
			//옵저버 초과 되었습니다.
			//HRYOON 옵저버 기능 껏을때
			if( IsDeveloper() == false )
			{
				_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_FULL_USER, bMovePenalty, iPenaltyPeso );
				return;
			}
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnUserBattleRoomJoin GM User %d, %s", GetUserIndex(), GetPublicID().c_str() );
		}
		else if( !bObserver && !bInvite && pBattleRoom->IsBattleTimeClose() )
		{
			//플레이 시간이 지난 파티
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_TIME_CLOSE, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( !bObserver && pBattleRoom->IsStartRoomEnterX() )
		{
			//플레이 시작 후 입장 불가 파티
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_START_ROOM_ENTER_X, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( !bInvite && !bObserver && pBattleRoom->IsNoChallenger() )
		{
			//도전자 참여 불가
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_NO_CHALLENGER, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( !bObserver && pBattleRoom->GetSelectModeTerm() == BMT_TEAM_SURVIVAL_FIRST && !IsSafetyLevel() )
		{
			//초보 스틸서바에는 안전 레벨 유저만 입장 가능
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_SAFETY_ROOM, bMovePenalty, iPenaltyPeso );
			return;
		}   
		else if( GetBuyCharCount() == 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserBattleRoomJoin : 구입 용병이 없는 유저가 전투룸 입장 :%s", GetPublicID().c_str() );
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_EXCEPTION, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( GetEntryType() == ET_TERMINATION )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserBattleRoomJoin : 임시가입 만료 유저가 전투룸 선택 입장 :%s", GetPublicID().c_str() );
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_EXCEPTION, bMovePenalty, iPenaltyPeso );
			return;
		}
		else if( pBattleRoom->IsPassword() && !IsDeveloper() )
		{
			ioHashString szPassword;
			rkPacket >> szPassword;
			if( pBattleRoom->GetPW() != szPassword )
			{
				// 비밀 번호 다름
				_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_NOT_PASSWORD, bMovePenalty, iPenaltyPeso );
				return;
			}
		}

		if( !bObserver && pBattleRoom->GetBattleEventType() == BET_TOURNAMENT_BATTLE )
		{
			// 옵저버 아닌 유저는 팀 세팅
			ioUserTournament::TeamData &rkTeamData = m_UserTournament.GetTournamentTeamData( pBattleRoom->GetTournamentIndex() );
			if( rkTeamData.m_dwTeamIndex != 0 )
			{
				pBattleRoom->TournamentInfo( GetUserIndex(), rkTeamData.m_dwTeamIndex );
			}
		}
	}

/*	// 전투방에서 전투방으로 이동이 가능해짐 2013.01.31 LJH
	// 이미 파티에 있을 수 있다. 초대와 자동참가 순서
	if( IsBattleRoom() || IsLadderTeam() )     
	{
		_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_EXCEPTION );
		return;
	}	
*/
	// 이미 파티에 있을 수 있다. 초대와 자동참가 순서
	if( IsLadderTeam() )
	{
		_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_EXCEPTION, bMovePenalty, iPenaltyPeso );
		return;
	}	

	//
	ExitRoomToBattleRoomJoin( pBattleRoom, bObserver, bMovePenalty, iPenaltyPeso );
}

void User::OnUserBattleRoomLeave( SP2Packet &rkPacket )
{
	LeaveBattleRoom();

	SP2Packet kPacket( STPK_BATTLEROOM_LEAVE );
	kPacket << GetPublicID();
	SendMessage( kPacket );

	// 서버에서의 룸 입장과 유저의 이탈이 서로 타이밍이 안맞으면 룸에서 이탈시킨다.
	if( m_pMyRoom && m_pMyRoom->GetRoomStyle() == RSTYLE_BATTLEROOM )
	{
		LeaveRoom();

		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << EXIT_ROOM_OK;
		kPacket << -1;
		kPacket << false;
		SendMessage( kPacket );
	}
}

void User::OnTutorialStep( SP2Packet &rkPacket )
{
	if(m_user_data.m_user_state == US_TUTORIAL_CLEAR) return;

	// 훈련 단계가 끝날 때마다 갱신
	int iType;
	int iState;
	int iMaxStep;
	rkPacket >> iType >> iState >> iMaxStep;

	if( iType == TUTORIAL_STEP_NEXT )
	{
		m_user_data.m_user_state = iState;
		if( m_user_data.m_user_state == US_TUTORIAL_CLEAR )    //훈련 종료
		{
			// 매일매일 골드 아이템~♬ : 튜토리얼을 클리어하지 못한 유저는 클리어할 때 지급한다.
			OneDayGoldItemEvent *pEventNode = static_cast<OneDayGoldItemEvent*>( m_EventUserMgr.GetEventUserNode( EVT_ONE_DAY_GOLD_ITEM ) );
			if( pEventNode )
			{
				pEventNode->CheckGoldItemDate( this );
			}
		}
		g_LogDBClient.OnInsertTutorialTime( this );
		SetStartTimeLog( TIMEGETTIME() );
	}
}

void User::OnCharLimitCheck( SP2Packet &rkPacket )
{
	// 캐릭터 기간 정보 전송
	SP2Packet kPacket( STPK_CHAR_LIMIT_CHECK );
	kPacket << GetCharCount();
	for(int i = 0;i < GetCharCount();i++)
	{
		kPacket << m_CharList[i]->GetCharIndex();
		kPacket << m_CharList[i]->IsActive();
		kPacket << m_CharList[i]->GetCharLimitDate();
	}
	SendMessage( kPacket );
}

void User::OnCharDecorationBuy( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		kPacket << CHAR_DECORATION_BILLING_WAIT;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Billing Wait %s:%s",GetPublicID().c_str(), m_szBillingGUID.c_str() );
 		return;
	}

	int iSelectArray;
	ITEMSLOT kSlot;

	bool bCash		= false;
	bool bBonusCash = false;
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	rkPacket >> iSelectArray >> kSlot.m_item_type >> kSlot.m_item_code >> bCash;
	
	if( !COMPARE( iSelectArray, 0, GetCharCount() ) )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		kPacket << CHAR_DECORATION_EXCEPTION;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Array Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
		//
	}

	if( g_ExerciseCharIndexMgr.IsRight( GetCharIndex( iSelectArray ) ) )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		kPacket << CHAR_DECORATION_EXERCISE_FAIL;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Exercise char Fail %s) %d - %u",GetPublicID().c_str(), iSelectArray,
			                 GetCharIndex( iSelectArray ));
		return;
	}

	if( m_Inventory.IsFull() )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		PACKET_GUARD_VOID( kPacket.Write( CHAR_DECORATION_MAX_COUNT ) );
		SendMessage( kPacket );
		return;		
	}

	if( m_Inventory.IsSlotItem( kSlot ) )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		kPacket << CHAR_DECORATION_EXCEPTION;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy 보유중인 아이템 Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
		//
	}

	int iBuyCash = 0;
	if( bCash )
	{
		//HRYOON BONUS CASH 사용 가능 여부 파악
		//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		if( GetEntryType() == ET_TERMINATION )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Cash Entry Type Error : %s:%d", GetPublicID().c_str(), GetEntryType() );
			SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
			kReturn << CHAR_DECORATION_EXCEPTION;
			SendMessage( kReturn );
			return;
		}

		// cash 구입시에는 제한이 없다.
		iBuyCash = g_DecorationPrice.GetDecoCash( kSlot.m_item_type, kSlot.m_item_code );

		if( iBuyCash <= 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Cash Price Error : %s:%d %d:%d", GetPublicID().c_str(), iBuyCash , kSlot.m_item_type, kSlot.m_item_code );
			SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
			kReturn << CHAR_DECORATION_EXCEPTION;
			SendMessage( kReturn );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy pNode == NULL. : %d:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
			kReturn << CHAR_DECORATION_BILLING_FAIL;
			SendMessage( kReturn );
			return;
		}

		int iItemPrice = iBuyCash;

		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_CHAR_DECORATION_BUY, CHAR_DECORATION_BILLING_WANT_OF_CASH, kSlot.m_item_type, vConsumeInfo ) )
			return;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;

		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;
		kBillingPacket << OUTPUT_CASH_DECO;
		kBillingPacket << kSlot.m_item_type;
		kBillingPacket << kSlot.m_item_code;
		kBillingPacket << iSelectArray;
		int iSize	= vConsumeInfo.size();
		int iSpendBonusCash	= 0;
		for( int i = 0; i < iSize; i++ )
			iSpendBonusCash += vConsumeInfo[i].value2;
		
		//보너스 캐쉬로 구매 가능 
		if( iSpendBonusCash >= iItemPrice )
			bBonusCash = true;
		if( iItemPrice != iSpendBonusCash )
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;
			SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
			kBillingPacket << (int) GetChannelingType();
			kBillingPacket << m_szBillingGUID;
			kBillingPacket << iItemPrice;
			kBillingPacket << GetUserIndex();
			kBillingPacket << GetPublicID();
			kBillingPacket << GetPrivateID();
			kBillingPacket << GetPublicIP();
			kBillingPacket << iBuyCash;

			PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
			for( int i = 0; i < iSize; i++ )
			{
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
			}

			kBillingPacket << OUTPUT_CASH_DECO;
			kBillingPacket << kSlot.m_item_type;
			kBillingPacket << kSlot.m_item_code;
			kBillingPacket << iSelectArray;

			if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_CHAR_DECORATION_BUY, CHAR_DECORATION_BILLING_FAIL, NULL, NULL ) )
				return;

			ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
			if( pLocal )
				pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

			if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Cash Send Fail : %s:%s:%d", GetPublicID().c_str(),GetBillingGUID().c_str(), iBuyCash );
				SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
				kReturn << CHAR_DECORATION_BILLING_DISCONNECT;
				SendMessage( kReturn );
				m_szBillingGUID.Clear();
			}
			else
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCharDecorationBuy Cash Send : %s:%s:%d(%s)", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash, m_szBillingUserKey.c_str() );
			return;
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharDecorationBuy Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]User::OnCharDecorationBuy Cash Send : %s:%s:%d(%s)", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash, m_szBillingUserKey.c_str() );
		}
		return;
	}
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);

	int iClassLevel = GetClassLevel( iSelectArray, true );
	// 용병레벨을 최대로하여 모든 치장을 구매 가능하도록 한다.
	if( GetUserEventType() == USER_TYPE_LIMIT_IGNORE )
	{
		iClassLevel = 99999999;           
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy (%d:%d) Level Ignore : %s", kSlot.m_item_type, kSlot.m_item_code, GetPublicID().c_str() );
	}

	int iPeso = g_DecorationPrice.GetDecoPeso( kSlot.m_item_type, kSlot.m_item_code, iClassLevel );

	//페소 & 보너스 캐시로 구매 가능 한지
	if( iPeso <= 0 && vConsumeInfo.empty() )
	{
		if( GetMoney() < iPeso )
		{
			SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
			kPacket << CHAR_DECORATION_MONEY_FAIL;
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy 돈없음 Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
			return;
			//
		}
	}
	else if( bBonusCash && bCash )
	{
		//로그에 남기는 billingID 때문에 생성함
		if(m_szBillingGUID.IsEmpty())
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;
		}

		for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
		{
			//보너스 캐쉬 사용 실패
			if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_DECORATION, kSlot.m_item_type, kSlot.m_item_code) )
			{
				SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
				kReturn << CHAR_DECORATION_EXCEPTION;
				SendMessage( kReturn );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Spend Bonus Cash Error-guid:%s,userIndex:%d,publicID:%s:index:%d,money:%d,itemType:%d,itemCode:%d", GetBillingGUID().c_str(), GetUserIndex(), GetPublicID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2, kSlot.m_item_type, kSlot.m_item_code );
				
				ClearBillingGUID();
				return;
			}
		}
		ClearBillingGUID();
		
		//보너스페소지급
		int iBonusPeso = g_DecorationPrice.GetBonusPeso( kSlot.m_item_type, kSlot.m_item_code );
		if( iBonusPeso > 0 )
		{
			AddMoney( iBonusPeso );
			g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, (kSlot.m_item_type % 1000), kSlot.m_item_code, iBonusPeso, NULL);
		}


		//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);

	}
	else if( iPeso > 0 && !bCash )
	{
		//페소로 구매 하는 경우
		RemoveMoney( iPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_DECO, (kSlot.m_item_type % 1000), kSlot.m_item_code, iPeso, NULL);
	}
	else if( !bBonusCash && bCash )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Error : %s:%d %d:%d", GetPublicID().c_str(), iBuyCash , kSlot.m_item_type, kSlot.m_item_code );
		SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
		kReturn << CHAR_DECORATION_EXCEPTION;
		SendMessage( kReturn );
		return;
	}
	/*if( iPeso <= 0 )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		kPacket << CHAR_DECORATION_EXCEPTION;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy (%d) Fail %s) %d - %d - %d", iPeso, GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
	}*/
	
	
	// 장착
	if( m_CharList[iSelectArray]->SetCharDecoration( kSlot.m_item_type, kSlot.m_item_code ) )
	{
		// 
		

		// 아래 구문이 수정되면 _OnBillingOutputCashDeco() 함수도 수정해야 함.

		// 슬롯 추가
		DWORD dwIndex = 0;
		int   iArray  = 0;

		m_Inventory.AddSlotItem( kSlot, false, iPeso, LogDBClient::DT_BUY, dwIndex, iArray );


		m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code );
		

		
		if( dwIndex != 0 )
		{
			char szItemIndex[MAX_PATH]="";
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, iPeso, szItemIndex, LogDBClient::DT_BUY );
		}
		
		// 종족 치장을 구매하면 랜덤 치장 아이템을 지급한다.
		if( kSlot.m_item_type % 1000 == UID_KINDRED )
		{
			const CHARACTER &rkCharInfo = m_CharList[iSelectArray]->GetCharInfo();
			CHARACTER rkChangeInfo = rkCharInfo;
			m_Inventory.GetEquipItemCode( rkChangeInfo );
			m_CharList[iSelectArray]->SetChangeKindred( rkChangeInfo, GetPrivateID().GetHashCode() );
			SetDefaultDecoItem( m_CharList[iSelectArray]->GetCharInfo() );
		}

		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		kPacket << CHAR_DECORATION_OK << GetMoney() << GetCash() << GetChannelingCash() << kSlot.m_item_type << kSlot.m_item_code 
				<< m_CharList[iSelectArray]->GetCharIndex() << (CHARACTER)m_CharList[iSelectArray]->GetCharInfo();
		SendMessage( kPacket );	
		SaveInventory();
		SaveUserData();

		m_UserGrowthLevel.AddCharGrowthPointByDecoWoman( kSlot.m_item_type, kSlot.m_item_code );


		// 구매 선물
		IntVec vEventTypeVec;
		vEventTypeVec.reserve(10);
		m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
		int iSize = vEventTypeVec.size();
		for (int i = 0; i < iSize ; i++)
		{
			BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
			if( pEventNode )
				pEventNode->SendBuyPresent( this, true, ioPresentHelper::BT_DECO, kSlot.m_item_type, kSlot.m_item_code, iBuyCash );
		}

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharDecoUpdate( this, m_CharList[iSelectArray] );
		}

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCharDecorationBuy Ok %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
	}	
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Critical Error %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
	}
}

void User::OnEquipItem( SP2Packet &rkPacket )
{
	int iType;
	rkPacket >> iType;

	switch( iType )
	{
	case EQUIP_SLOT_ITEM_STATE:
		EquipSlotItem( rkPacket );
		break;
	case RELEASE_SLOT_ITEM_STATE:
		ReleaseSlotItem( rkPacket );
		break;
	}
}

void User::OnCharExtend( SP2Packet &rkPacket )
{
	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnCharExtend Billing Wait %s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_CHAR_EXTEND );
		kReturn << CHAR_EXTEND_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	int   iType;
	DWORD dwCharIndex;
	int   iLimitDate;
	bool  bCash;

	rkPacket >> iType >> dwCharIndex >> iLimitDate >> bCash;

	if( g_ExerciseCharIndexMgr.IsRight( dwCharIndex ) )
	{
		SP2Packet sendPacket( STPK_CHAR_EXTEND );
		sendPacket << CHAR_EXTEND_EXERCISE_CHAR_FAIL << dwCharIndex;
		SendMessage(sendPacket);
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharExtend( %s ) : %u ", GetPublicID().c_str(), dwCharIndex  );
		return;
	}

	int iCharArray = -1;
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
		{
			iCharArray = i;
			break;
		}
	}

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		SP2Packet kPacket( STPK_CHAR_EXTEND );
		kPacket << CHAR_EXTEND_EXCEPTION;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharExtend Fail %s) %d - %d - %d",GetPublicID().c_str(), iCharArray, dwCharIndex, iLimitDate );
		return;
	}

	const CHARACTER &charInfo = m_CharList[iCharArray]->GetCharInfo();

	if( charInfo.m_ePeriodType == CPT_MORTMAIN )
	{
		SP2Packet kPacket( STPK_CHAR_EXTEND );
		kPacket << CHAR_EXTEND_MORTMAIN_CHAR;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharExtend Fail mortmain char %s) %d - %d - %d - %d",GetPublicID().c_str(), iCharArray, dwCharIndex, iLimitDate, (int) charInfo.m_ePeriodType );
		return;
	}

	if( bCash && iType == CHAR_EXTEND_NORMAL )
	{
		int iBuyCash = g_ItemPriceMgr.GetClassBuyCash( charInfo.m_class_type, iLimitDate );
		if( iBuyCash <= 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharExtend Cash Price Error : %s:%d:%d:%d", GetPublicID().c_str(), iBuyCash, charInfo.m_class_type, iLimitDate );
			SP2Packet kReturn( STPK_CHAR_EXTEND );
			kReturn << CHAR_EXTEND_EXCEPTION;
			SendMessage( kReturn );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharExtend pNode == NULL. : %d:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_CHAR_EXTEND );
			kReturn << CHAR_EXTEND_BILLING_FAIL;
			SendMessage( kReturn );
			return;
		}

		static IntOfTwoVec vConsumeInfo;
		vConsumeInfo.clear();

		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_CHAR_EXTEND, CHAR_EXTEND_BILLING_WANT_OF_CASH, charInfo.m_class_type, vConsumeInfo ) )
			return;

		int iSize	= vConsumeInfo.size();

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << iBuyCash;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;

		PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
		for( int i = 0; i < iSize; i++ )
		{
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		kBillingPacket << OUTPUT_CASH_SOLDIER_EXTEND;
		kBillingPacket << iCharArray;
		kBillingPacket << charInfo.m_class_type;
		kBillingPacket << iLimitDate;

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_CHAR_EXTEND, CHAR_EXTEND_BILLING_FAIL, NULL, NULL ) )
			return;

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharExtend Cash Send Fail : %s:%s:%d", GetPublicID().c_str(),GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_CHAR_EXTEND );
			kReturn << CHAR_EXTEND_BILLING_DISCONNECT;
			SendMessage( kReturn );
			m_szBillingGUID.Clear();
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharExtend Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharExtend Cash Send : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
		}
		return;
	}

	int iResult = CHAR_EXTEND_OK;
	DWORD dwSetItemCode = charInfo.m_class_type + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !IsCanBuyItem( pSetInfo ) && iType != CHAR_EXTEND_EVENT )
	{
		bool bEvent = false;
		BuyCharNoLevelLimitEventUserNode *pEventNode = static_cast<BuyCharNoLevelLimitEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_BUY_CHAR_NO_LEVEL_LIMIT ) );
		if( pEventNode && pEventNode->IsNoLevelLimit( this, false, iType, iLimitDate, (int) charInfo.m_ePeriodType ) )
			bEvent = true;

		if( !bEvent )
		{
			SP2Packet kPacket( STPK_CHAR_EXTEND );
			kPacket << CHAR_EXTEND_NEED_LEVEL;
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharExtend Need Level %s) %d - %d - %d - %d"
				                  ,GetPublicID().c_str(), iCharArray, dwCharIndex, iLimitDate ,GetGradeLevel() );
			return;
		}
	}

	int iBuyPeso = 0;
	if( iType == CHAR_EXTEND_NORMAL )
	{
		iBuyPeso = g_ItemPriceMgr.GetClassBuyPeso( charInfo.m_class_type, iLimitDate );
		if( iLimitDate == g_ItemPriceMgr.GetDefaultLimit() ) 
			iBuyPeso = (float)iBuyPeso * g_ItemPriceMgr.GetLimitExtendDiscount();
		if( iBuyPeso <= 0 )
		{
			iResult = CHAR_EXTEND_EXCEPTION;
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 1 : %s(%d):%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate );
		}
		else if( GetMoney() < iBuyPeso )
		{
			iResult = CHAR_EXTEND_MONEY_FAIL;
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 2 : %s(%d):%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate );
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Char Extend[%d초]: %s Before %I64dPeso, %dCash - %dSecond", iLimitDate, GetPublicID().c_str(), GetMoney(), 
				                 GetCash(), m_CharList[iCharArray]->GetCharLimitDate() );
			RemoveMoney( iBuyPeso );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CHAR, PRESENT_SOLDIER, charInfo.m_class_type, iBuyPeso, NULL);

			// 구매 시간 저장
			if( charInfo.m_ePeriodType == CPT_TIME )
			{
				g_ItemPriceMgr.SetBuySoldierCollected( charInfo.m_class_type, iLimitDate );
			}
			else if( charInfo.m_ePeriodType == CPT_DATE )
			{
				g_ItemPriceMgr.SetBuySoldierCollected( charInfo.m_class_type, iLimitDate );
		}
	}
	}
	else if( iType == CHAR_EXTEND_BANKRUPTCY )
	{
		// 파산 페소 지급 ( 파산 연장 캐릭터 디서블 )
		//iResult = CHAR_EXTEND_EXCEPTION;
		//LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 3 : %s(%d):%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate );
		//
		
		// 파산 캐릭터 지급 ( 캐릭터 연장 )
		if( GetMoney() >= g_ItemPriceMgr.GetBankruptcyPeso() || 
			GetActiveBuyCharCount() != 0                     ||
			iLimitDate != g_ItemPriceMgr.GetBankruptcyLimit()||
			GetUserState() == 0 )
		{
			iResult = CHAR_EXTEND_EXCEPTION;
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 3 : %s(%d):%d:%d:%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate, GetActiveBuyCharCount(), GetUserState() );
		}
	}
	else if( iType == CHAR_EXTEND_EVENT )
	{
		int iEventType = 0;
		rkPacket >> iEventType;

		if( iEventType == EVT_PROPOSAL )
		{
			ProposalEventUserNode *pNode = static_cast<ProposalEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_PROPOSAL ) );
			if( pNode && pNode->IsGiveChar( this ) && !charInfo.m_bActive )
			{
				iLimitDate = g_EventMgr.GetValue( EVT_PROPOSAL, EA_MAX_CHAR_USE_SEC );
				pNode->SetValueGiveChar();
				if( !pNode->IsGiveChar( this ) )
					pNode->Save( GetUserDBAgentID(), GetAgentThreadID() );
			}
			else
			{
				iResult = CHAR_EXTEND_EXCEPTION;
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 4 : %s(%d):%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate );
			}
		}
		else if( iEventType == EVT_PLAYTIME )
		{
			int iGiftType = 0;
			rkPacket >> iGiftType;
			PlayTimeEventUserNode *pEvent = static_cast<PlayTimeEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_PLAYTIME ) );
			if( pEvent && pEvent->IsGift( (PlayTimeEventUserNode::GiftType) iGiftType, this, false ) )
			{
				pEvent->SetGift( (PlayTimeEventUserNode::GiftType) iGiftType, this, false );
				pEvent->Save( GetUserDBAgentID(), GetAgentThreadID() );
				iLimitDate = pEvent->GetLimitSecond( (PlayTimeEventUserNode::GiftType) iGiftType );
			}
			else
			{
				iResult = CHAR_EXTEND_EXCEPTION;
				EventLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s IsGift Error :%s : %d", __FUNCTION__, GetPublicID().c_str(), iGiftType );
			}

		}
		else
		{
			iResult = CHAR_EXTEND_EXCEPTION;
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 5 : %s(%d):%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate );
		}
	}
	else
	{
		iResult = CHAR_EXTEND_EXCEPTION;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error 6 : %s(%d):%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iType, charInfo.m_class_type, iLimitDate );
	}

	if( iResult != CHAR_EXTEND_OK )
	{
		SP2Packet kReturn( STPK_CHAR_EXTEND );
		kReturn << iResult;
		SendMessage( kReturn );
		return;
	}

	// 아래 부분이 수정되면 _OnBillingOutputCashSoldierExtend() 함수도 수정해야 함.

	// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->UpdateLimitTimer();
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::UpdateCharLimitDate Extend %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}	
	// 플레이 연장
	if(m_CharList[iCharArray]->GetCharInfo().m_ePeriodType == CPT_DATE)
		m_CharList[iCharArray]->SetCharLimitExtendDate( iLimitDate );
	else
	m_CharList[iCharArray]->SetCharLimitExtend( iLimitDate );

	// 플레이중이면 연장한 시간부터 세팅한다. 
	m_CharList[iCharArray]->SetActive( true );
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->StartLimitTimer( m_pMyRoom->GetCharLimitCheckTime() );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::StartCharLimitDate Extend %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}		
	SaveCharacter();  //변경된 정보 저장
	SaveUserData();   //금액이 차감되었다.

	//
	

	//판매 기록
	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );
	LogDBClient::CharType eCharType = LogDBClient::CT_BUY;
	if( GetUserState() != US_TUTORIAL_CLEAR )
		eCharType = LogDBClient::CT_TUTORIAL;
	else if( iType ==  CHAR_EXTEND_BANKRUPTCY )
		eCharType = LogDBClient::CT_BANKRUPT;
	else if( iType ==  CHAR_EXTEND_EVENT )
		eCharType = LogDBClient::CT_EVENT_PROPOSAL;
	g_LogDBClient.OnInsertChar( this, charInfo.m_class_type, iLimitDate, iBuyPeso, szItemIndex, eCharType );

	const CHARACTER &ExtendInfo = m_CharList[iCharArray]->GetCharInfo();		
	SP2Packet kPacket( STPK_CHAR_EXTEND );
	kPacket << CHAR_EXTEND_OK << GetMoney() << GetCash() << GetChannelingCash() << iCharArray << 0; // 0은 bonuspeso
	kPacket << m_CharList[iCharArray]->IsActive() << m_CharList[iCharArray]->GetCharLimitDate() << m_CharList[iCharArray]->GetLimitCheckSecond();
	SendMessage( kPacket );		
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Char Extend : %s After %I64dPeso, %dCash - %dSecond", GetPublicID().c_str(), GetMoney(), GetCash(), m_CharList[iCharArray]->GetCharLimitDate() );
}

void User::OnCharCharge( SP2Packet &rkPacket )
{
	DWORD dwCharIndex;
	rkPacket >> dwCharIndex;

	if( g_ExerciseCharIndexMgr.IsRight( dwCharIndex ) )
	{
		SP2Packet sendPacket( STPK_CHAR_CHARGE );
		sendPacket << CHAR_CHARGE_EXCEPTION << dwCharIndex;
		SendMessage( sendPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharCharge ERROR( %s ) : %u ", GetPublicID().c_str(), dwCharIndex  );
		return;
	}

	int iCharArray = -1;
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
		{
			iCharArray = i;
			break;
		}
	}

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		SP2Packet kPacket( STPK_CHAR_CHARGE );
		kPacket << CHAR_CHARGE_EXCEPTION;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCharge Fail %s) %d - %d",GetPublicID().c_str(), iCharArray, dwCharIndex );
		return;
	}

	const CHARACTER &charInfo = m_CharList[iCharArray]->GetCharInfo();

	DWORD dwSetItemCode = charInfo.m_class_type + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !IsCanBuyItem( pSetInfo ) )
	{
		SP2Packet kPacket( STPK_CHAR_CHARGE );
		kPacket << CHAR_CHARGE_NEED_LEVEL;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharCharge Need Level %s) %d - %d - %d"
			                  ,GetPublicID().c_str(), iCharArray, dwCharIndex, GetGradeLevel() );
		return;
	}
	
	// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->UpdateLimitTimer();		
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::UpdateCharLimitDate Charge %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}	
	int iResult = CHAR_CHARGE_OK;
	int iLimitDate = g_ItemPriceMgr.GetDefaultLimit();
	int iBuyPeso   = (float)g_ItemPriceMgr.GetClassBuyPeso( charInfo.m_class_type, iLimitDate );
	
	int iNeedSecond = max( 0, iLimitDate - m_CharList[iCharArray]->GetCharLimitDate() );
	float fSecondPeso = (float)iBuyPeso / iLimitDate;

	__int64 iNeedPeso = (__int64)( (float)iNeedSecond * fSecondPeso );	
	if( m_CharList[iCharArray]->GetCharLimitDate() == 0 )
		iNeedPeso = iBuyPeso;

	if( iNeedPeso <= 0 )
	{
		iResult = CHAR_CHARGE_EXCEPTION;
	}
	else
	{
		if( GetMoney() < iNeedPeso )
			iResult = CHAR_CHARGE_MONEY_FAIL;
	}

	if( iResult != CHAR_CHARGE_OK )
	{
		SP2Packet kReturn( STPK_CHAR_CHARGE );
		kReturn << iResult;
		SendMessage( kReturn );
		return;
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Char Charge[%d초:%.2f]: %s Before %I64dPeso, %dCash - %dSecond", iNeedSecond, fSecondPeso, GetPublicID().c_str(), GetMoney(), GetCash(), m_CharList[iCharArray]->GetCharLimitDate() );

		RemoveMoney( iNeedPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CHAR, PRESENT_SOLDIER, charInfo.m_class_type, iNeedPeso, NULL);

		// 구매 시간 저장
		if( charInfo.m_ePeriodType == CPT_TIME )
		{
			g_ItemPriceMgr.SetBuySoldierCollected( charInfo.m_class_type, iLimitDate );
		}
		else if( charInfo.m_ePeriodType == CPT_DATE )
		{
			g_ItemPriceMgr.SetBuySoldierCollected( charInfo.m_class_type, iLimitDate );
		}

		//판매 기록
		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );
		g_LogDBClient.OnInsertChar( this, charInfo.m_class_type, iNeedSecond, iNeedPeso, szItemIndex, LogDBClient::CT_BUY );

		// 플레이 연장
		if(m_CharList[iCharArray]->GetCharInfo().m_ePeriodType == CPT_DATE)
			m_CharList[iCharArray]->SetCharLimitExtendDate( iNeedSecond );
		else
		m_CharList[iCharArray]->SetCharLimitExtend( iNeedSecond );
		// 플레이중이면 연장한 시간부터 세팅한다. 
		m_CharList[iCharArray]->SetActive( true );
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			m_CharList[iCharArray]->StartLimitTimer( m_pMyRoom->GetCharLimitCheckTime() );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::StartCharLimitDate Charge %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
		}		
		SaveCharacter();  //변경된 정보 저장
		SaveUserData();   //금액이 차감되었다.

		//
		const CHARACTER &ExtendInfo = m_CharList[iCharArray]->GetCharInfo();		
		SP2Packet kPacket( STPK_CHAR_CHARGE );
		kPacket << CHAR_CHARGE_OK << GetMoney() << iCharArray;
		kPacket << m_CharList[iCharArray]->IsActive() << m_CharList[iCharArray]->GetCharLimitDate() << m_CharList[iCharArray]->GetLimitCheckSecond();
		SendMessage( kPacket );		
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Char Charge : %s After %I64dPeso, %dCash - %dSecond", GetPublicID().c_str(), GetMoney(), GetCash(), m_CharList[iCharArray]->GetCharLimitDate() );
	}
}

void User::OnCharChangePeriod( SP2Packet &rkPacket )
{
	// 상점 블럭.
	if( IsCharCreating() )
	{
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CHAR_CHANGE_PERIOD_CREATING_CHAR;
		SendMessage( kReturn );
		return;
	}

	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnCharChangePeriod Billing Wait %s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CHAR_CHANGE_PERIOD_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	DWORD dwCharIndex;
	bool  bCash;

	rkPacket >> dwCharIndex >> bCash;

	if( g_ExerciseCharIndexMgr.IsRight( dwCharIndex ) )
	{
		SP2Packet sendPacket( STPK_CHAR_CHANGE_PERIOD );
		sendPacket << CHAR_CHANGE_PERIOD_EXERCISE_CHAR << dwCharIndex;
		SendMessage(sendPacket);
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharChangePeriod( %s ) : %u ", GetPublicID().c_str(), dwCharIndex  );
		return;
	}

	int iCharArray = -1;
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
		{
			iCharArray = i;
			break;
		}
	}

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		SP2Packet kPacket( STPK_CHAR_CHANGE_PERIOD );
		kPacket << CHAR_CHANGE_PERIOD_EXCEPTION;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharChangePeriod Fail %s) %d - %d",GetPublicID().c_str(), iCharArray, dwCharIndex );
		return;
	}

	const CHARACTER &charInfo = m_CharList[iCharArray]->GetCharInfo();

	if( charInfo.m_ePeriodType == CPT_MORTMAIN )
	{
		SP2Packet kPacket( STPK_CHAR_CHANGE_PERIOD );
		kPacket << CHAR_CHANGE_PERIOD_MORTMAIN_CHAR;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharChangePeriod Fail mortmain char %s) %d - %d - %d",GetPublicID().c_str(), iCharArray, dwCharIndex, (int) charInfo.m_ePeriodType );
		return;
	}
	int iBuyCash = 0;
	if( bCash )
	{
		iBuyCash = g_ItemPriceMgr.GetMortmainCharCash( charInfo.m_class_type );
		if( iBuyCash <= 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharChangePeriod Cash Price Error : %s:%d:%d", GetPublicID().c_str(), iBuyCash, charInfo.m_class_type );
			SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
			kReturn << CHAR_CHANGE_PERIOD_EXCEPTION;
			SendMessage( kReturn );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharChangePeriod pNode == NULL. : %d:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
			kReturn << CHAR_CHANGE_PERIOD_BILLING_FAIL;
			SendMessage( kReturn );
			return;
		}

		static IntOfTwoVec vConsumeInfo;
		vConsumeInfo.clear();

		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_CHAR_CHANGE_PERIOD, CHAR_CHANGE_PERIOD_BILLING_WANT_OF_CASH, charInfo.m_class_type, vConsumeInfo ) )
			return;

		int iSize	= vConsumeInfo.size();

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << iBuyCash;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;

		PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
		for( int i = 0; i < iSize; i++ )
		{
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		kBillingPacket << OUTPUT_CASH_SOLDIER_CHANGE_PERIOD;
		kBillingPacket << iCharArray;
		kBillingPacket << charInfo.m_class_type;

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_CHAR_CHANGE_PERIOD, CHAR_CHANGE_PERIOD_BILLING_FAIL, NULL, NULL ) )
			return;

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharChangePeriod Cash Send Fail : %s:%s:%d", GetPublicID().c_str(),GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
			kReturn << CHAR_CHANGE_PERIOD_BILLING_DISCONNECT;
			SendMessage( kReturn );
			m_szBillingGUID.Clear();
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnCharChangePeriod Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]OnCharChangePeriod Cash Send : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
		}
		return;
	}

	int iResult = CHAR_CHANGE_PERIOD_OK;
	DWORD dwSetItemCode = charInfo.m_class_type + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !IsCanBuyItem( pSetInfo ) )
	{
		SP2Packet kPacket( STPK_CHAR_CHANGE_PERIOD );
		kPacket << CHAR_CHANGE_PERIOD_NEED_LEVEL;
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharChangePeriod Need Level %s) %d - %d - %d",GetPublicID().c_str(), iCharArray, dwCharIndex, GetGradeLevel() );
		return;
	}

	// 권한아이템 확인
	ioEtcItemBuyMortmainChar *pEtcItem = static_cast<ioEtcItemBuyMortmainChar*> ( g_EtcItemMgr.FindEtcItem( ioEtcItem::EIT_ETC_BUY_MORTMAIN_CHAR ) );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CREATE_CHAR_EXCEPTION;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharChangePeriod pEtcItem == NULL %s", GetPublicID().c_str() );
		return;
	}

	if( !pEtcItem->SetUsed( this, GetUserEtcItem() ) )
	{
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CREATE_CHAR_WANT_OF_MORTMAIN_ETCITEM;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCharChangePeriod don't have mortmain etc item %s", GetPublicID().c_str() );
		return;
	}
	
	bool bProposalEvent = false;
	int iBuyPeso = 0;
	iBuyPeso = g_ItemPriceMgr.GetMortmainCharPeso( charInfo.m_class_type );
	if( iBuyPeso <= 0 )
	{
		iResult = CHAR_CHANGE_PERIOD_EXCEPTION;
	}
	else if( GetMoney() < iBuyPeso )
	{
		iResult = CHAR_CHANGE_PERIOD_WANT_OF_MONEY;
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Change Mortmain[%d]: %s Before %I64dPeso, %dCash", m_CharList[iCharArray]->GetCharIndex(), GetPublicID().c_str(), GetMoney(), GetCash() );
		RemoveMoney( iBuyPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CHAR, PRESENT_SOLDIER, charInfo.m_class_type, iBuyPeso, NULL);
	}

	if( iResult != CHAR_CHANGE_PERIOD_OK )
	{
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << iResult;
		SendMessage( kReturn );
		return;
	}

	// 아래 부분이 수정되면 _OnBillingOutputCashSoldierChange() 함수도 수정해야 함.

	// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->UpdateLimitTimer();
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCharChangePeriod - UpdateLimitTimer %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}	
	
	int iResellLimitDate = m_CharList[iCharArray]->GetCharLimitDate();

	bool bResell = true;

	if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN)
	{
		CTime cCharTime = Help::ConvertNumberToCTime(iResellLimitDate);
		CTime kCurTime = CTime::GetCurrentTime();

		if(kCurTime < cCharTime)
		{
			CTimeSpan cRemainTime = cCharTime - kCurTime;
			iResellLimitDate = cRemainTime.GetTotalMinutes();
		}
		else
		{
			bResell = false;
			iResellLimitDate = 1;
		}
	}

	int iResellPeso      = g_ItemPriceMgr.GetTimeCharResellPeso( charInfo.m_class_type, iResellLimitDate  );

	if(!bResell)
		iResellPeso = 0;

	if( iResellPeso > 0 )
	{
		AddMoney( iResellPeso );
		g_LogDBClient.OnInsertPeso( this, iResellPeso, LogDBClient::PT_DEL_CHAR );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_DEL_CHAR, PRESENT_SOLDIER, charInfo.m_class_type, iResellPeso, NULL);
	}

	// 변경
	m_CharList[iCharArray]->SetPeriodType( CPT_MORTMAIN );
	m_CharList[iCharArray]->SetCharLimitDate( 0 );
	m_CharList[iCharArray]->SetActive( true );

	SaveCharacter();  //변경된 정보 저장
	SaveUserData();   //금액이 차감되었다.

	//판매 기록
	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );
	g_LogDBClient.OnInsertChar( this, charInfo.m_class_type, m_CharList[iCharArray]->GetCharLimitDate(), iBuyPeso, szItemIndex, LogDBClient::CT_BUY );

	SP2Packet kPacket( STPK_CHAR_CHANGE_PERIOD );
	kPacket << CHAR_CHANGE_PERIOD_OK << GetMoney() << GetCash() << GetChannelingCash() << iCharArray << iResellPeso << 0 << false; // bCash
	SendMessage( kPacket );		

	CreateSelectCharData( m_CharList[iCharArray] );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, true, ioPresentHelper::BT_SOLDIER, charInfo.m_class_type, 0, iBuyCash );
	}

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Change Mortmain[%d]: %s After %I64dPeso, %dCash - %dResellPeso - %dResellSecond", m_CharList[iCharArray]->GetCharIndex(), GetPublicID().c_str(), GetMoney(), GetCash(), iResellPeso, iResellLimitDate );
}

void User::OnRelayChat( SP2Packet &rkPacket )
{
	int iChatType;
	rkPacket >> iChatType;
	switch( iChatType )
	{
	case CT_PARTY:
		{
			if( !IsBattleRoom() )
				return;

			int iTeam;
			ioHashString szID, szChat;
			bool bNoSound;

			rkPacket >> iTeam;
			rkPacket >> szID;
			rkPacket >> szChat;
			rkPacket >> bNoSound;

			SP2Packet kPacket( STPK_RELAY_CHAT );
			kPacket << iChatType << iTeam << szID << szChat << bNoSound;

			BattleRoomParent *pBattleRoom = GetMyBattleRoom();
			if( pBattleRoom )
				pBattleRoom->SendPacketTcp( kPacket, GetUserIndex() );	
		}
		break;
	case CT_LADDER:
		{
			if( !IsLadderTeam() )
				return;

			ioHashString szID, szChat;
			bool bNoSound;

			rkPacket >> szID;
			rkPacket >> szChat;
			rkPacket >> bNoSound;

			SP2Packet kPacket( STPK_RELAY_CHAT );
			kPacket << iChatType << szID << szChat << bNoSound;

			LadderTeamParent *pLadderTeam = GetMyLadderTeam();
			if( pLadderTeam )
				pLadderTeam->SendPacketTcp( kPacket, GetUserIndex() );	
		}
		break;
	}
}

void User::OnBattleRoomInfo( SP2Packet &rkPacket )
{
	CheckLeaveBattleRoomIndex();

	DWORD dwBattleRoomIndex;
	rkPacket >> dwBattleRoomIndex;
	g_BattleRoomManager.SendBattleRoomJoinInfo( (UserParent*)this, dwBattleRoomIndex, m_iLeaveBattleRoomIndex );
}

void User::OnServerLobbyChat( SP2Packet &rkPacket )
{
	if( !m_bJoinServerLobby ) return;

	ioHashString szID, szChat;
	rkPacket >> szID >> szChat;

	SP2Packet kPacket( STPK_SERVER_LOBBY_CHAT );
	kPacket << CT_SERVER_LOBBY << szID << szChat;
	g_UserNodeManager.SendLobbyMessageAll( kPacket, this );
}

void User::OnMyRoomServerChange( SP2Packet &rkPacket )
{

#ifdef _ITEST
	;
#else
	if( GetMyRoom() )
	{
		//본부에서만 가능하다.
		SP2Packet kPacket( STPK_MYROOM_SERVER_CHANGE );
		kPacket << MYROOM_SERVER_CHANGE_NOT_MYROOM;
		SendMessage( kPacket );
		return;        
	}
	if( IsBattleRoom() )
	{
		//전투방 유저이다
		SP2Packet kPacket( STPK_MYROOM_SERVER_CHANGE );
		kPacket << MYROOM_SERVER_CHANGE_BATTLE_ROOM;
		SendMessage( kPacket );
		return;  
	}
	 
	if( IsLadderTeam() )
	{
		//래더팀 유저이다
		SP2Packet kPacket( STPK_MYROOM_SERVER_CHANGE );
		kPacket << MYROOM_SERVER_CHANGE_LADDER_TEAM;
		SendMessage( kPacket );
		return;  
	}
#endif

	if( IsReserveServerMoving() )
	{
		//서버 이동이 예약된 유저다.
		SP2Packet kPacket( STPK_MYROOM_SERVER_CHANGE );
		kPacket << MYROOM_SERVER_CHANGE_RESERVE_MOVE;
		SendMessage( kPacket );
		return;        
	}

	int iMoveServerIndex;
	rkPacket >> iMoveServerIndex;
	if( iMoveServerIndex == g_ServerNodeManager.GetServerIndex() )
	{
		//이미 동일한 서버에 연결되어있다.
		SP2Packet kPacket( STPK_MYROOM_SERVER_CHANGE );
		kPacket << MYROOM_SERVER_CHANGE_ALREADY_SERVER;
		SendMessage( kPacket );
		return;
	}

	ServerNode *pServerNode = g_ServerNodeManager.GetServerNode( iMoveServerIndex );
	if( !pServerNode )
	{
		//없는 서버이다.
		SP2Packet kPacket( STPK_MYROOM_SERVER_CHANGE );
		kPacket << MYROOM_SERVER_CHANGE_NOT_SERVER;
		SendMessage( kPacket );
		return;
	}

#ifdef SRC_LATIN
	// 서버 이동 구문에 왔을 시 클라이언트 CHCEnd() 호출 전에 G 메시지 전송.	JCLEE 140310
	LOG.PrintTimeAndLog( 0, "Apex G Msg Send, User::OnMyRoomServerChange() " );
	g_ioApex.NoticeApexProxy_UserLogout( GetUserIndex(), GetPrivateID() );

#endif

	int iMovingValue = SetServerMoving();
	SP2Packet kMovePacket( STPK_MOVING_SERVER );   
	kMovePacket << MT_NONE << 0 << 0 << 0 << 0 << -1;
	kMovePacket << pServerNode->GetClientMoveIP() << pServerNode->GetClientPort();
	kMovePacket << iMovingValue << g_ServerNodeManager.GetServerIndex();
	SendMessage( kMovePacket );		

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "본부에서 서버 이동 시도 : %s [%s:%d - > %s:%d]", GetPublicID().c_str(), g_App.GetClientMoveIP().c_str(), g_App.GetSSPort(), pServerNode->GetServerIP().c_str(), pServerNode->GetServerPort() );
	ReserveServerMoving();
}

void User::OnPlazaRoomInfo( SP2Packet &rkPacket )
{
	DWORD dwRoomIndex;
	rkPacket >> dwRoomIndex;
	g_RoomNodeManager.SendPlazaRoomJoinInfo( (UserParent*)this, dwRoomIndex );
}

void User::OnBattleRoomInviteList( SP2Packet &rkPacket )
{
	BattleRoomParent *pBattleRoom = GetMyBattleRoom();
	if( pBattleRoom == NULL ) return;

	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_UserNodeManager.SendBattleRoomInviteList( this, iCurPage, iMaxCount, pBattleRoom->GetAbilityMatchLevel(), pBattleRoom->GetSelectModeTerm() );
}

void User::OnUserShuffleRoomJoin( SP2Packet &rkPacket )
{
	int iGlobalSearchingTryCount = 0;
	rkPacket >> iGlobalSearchingTryCount;

	if( IsServerMoving() )
	{
		LOG.PrintTimeAndLog( LOG_SHUFFLE, "%s : 서버이동중인 유저가 오늘의모드 입장 요청 : %s", __FUNCTION__, GetPublicID().c_str() );
		return;
	}
	
	if( IsReserveLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : 타서버에 진영전(래더팀)을 예약 생성한 유저가 오늘의 모드 입장 요청 :%s", __FUNCTION__, GetPublicID().c_str() );
		return;
	}

	if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : 이미 진영전(래더팀)팀에있는 유저가 오늘의 모드 입장 요청 :%s", __FUNCTION__, GetPublicID().c_str() );
		return;
	}
	
	CheckLeaveBattleRoomIndex();

	if( IsReserveServerMoving() )          //서버 이동이 예약되었다.
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : 서버 이동이 예약된 유저가 오늘의 모드 검색 요청 : %s", __FUNCTION__, GetPublicID().c_str() );
		return;
	}
	else if( GetBuyCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s : 구입 용병이 없는 유저가 오늘의 모드 검색 :%s", __FUNCTION__, GetPublicID().c_str() );
		return;
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : 임시가입 만료 유저가 오늘의 모드 검색 :%s", __FUNCTION__, GetPublicID().c_str() );
		return;
	}

	if( IsShuffleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "이미 오늘의 모드에 참여중인 유저가 매칭 시도 :%s : %d", GetPublicID().c_str(), m_dwMyShuffleRoom );
		return;

		/* 재입장 처리 블럭
		ShuffleRoomParent *pNode = g_ShuffleRoomManager.GetGlobalShuffleRoomNode( m_dwMyShuffleRoom );
		if( pNode )
		{
			pNode->ReJoinTry( GetUserIndex(), GetPublicID() );
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - 존재하지 않는 오늘의 모드 pNode == NULL : %d, %s", __FUNCTION__, m_dwMyShuffleRoom, GetPublicID().c_str() );
			return;
		}
		*/
	}

	if( IsBattleRoom() )
		m_iLeaveBattleRoomIndex = GetMyBattleRoomIndex();

	//대기열에 등록하기전에 바로 플레이 가능 유저가 있는지 체크
	g_ShuffleRoomReserveMgr.AddShuffleQueue( this, iGlobalSearchingTryCount );
}

void User::OnUserShuffleRoomJoinCancel( SP2Packet &rkPacket )
{
	g_ShuffleRoomReserveMgr.DeleteShuffleQueue( this );
	_OnShuffleRoomJoinResult( USER_SHUFFLEROOM_SEARCH_END );
}

void User::_OnShuffleRoomJoinResult( int iResultType )
{
	if( iResultType != USER_SHUFFLEROOM_JOIN_OK )
	{
		LeaveShuffleRoom( true );

		SP2Packet kPacket( STPK_SHUFFLEROOM_JOIN_CANCEL );
		kPacket << iResultType;
		SendMessage( kPacket );
	}
}

void User::OnTrial( SP2Packet &rkPacket )
{
	ioHashString szCriminalID, szCriminalChat;
	PACKET_GUARD_VOID( rkPacket.Read(szCriminalID) );
	PACKET_GUARD_VOID( rkPacket.Read(szCriminalChat) );


	ioHashString szChatType;
	int iChatType = 0;
	DWORD dwChannelIndex = 0;
	PACKET_GUARD_VOID( rkPacket.Read(szChatType) );
	PACKET_GUARD_VOID( rkPacket.Read(iChatType) );

	if( iChatType == TT_CHANNEL_CHAT )
	{
		PACKET_GUARD_VOID( rkPacket.Read(dwChannelIndex) );
	}

	int iBattleUserSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iBattleUserSize) );
	MAX_GUARD(iBattleUserSize, 100);

	char szUserBuf[MAX_QUERY_SIZE] = "";
	memset( szUserBuf, 0, sizeof( MAX_QUERY_SIZE ) );
	for(int i = 0;i < iBattleUserSize;i++)
	{
		ioHashString szUserName;
		int          iTeamType = 0;
		PACKET_GUARD_VOID( rkPacket.Read(szUserName) );
		PACKET_GUARD_VOID( rkPacket.Read(iTeamType) );

		char szInfo[MAX_PATH] = "";
		sprintf_s( szInfo, "%s(%s), ", szUserName.c_str(), Help::GetTeamTypeString( (TeamType)iTeamType ).c_str() );
		strcat_s( szUserBuf, szInfo );
	}
	ioHashString szCriminalIP, szReason;
	PACKET_GUARD_VOID( rkPacket.Read(szCriminalIP) );
	PACKET_GUARD_VOID( rkPacket.Read(szReason) );
	g_DBClient.OnInsertTrial( GetUserDBAgentID(), GetAgentThreadID(), this, szCriminalID, szCriminalChat, szChatType, szUserBuf, szCriminalIP , szReason, iChatType, dwChannelIndex );
}

bool User::_OnFollowUser( UserParent *pRequestUser, int iUserPos, int iRoomIndex, int iLeaveRoomIndex, int iLeaveBattleRoomIndex, bool bDeveloper, int iAbilityLevel )
{
	int iResult		= FOLLOW_USER_OK;
	int iNextUserPos= iUserPos;
	switch( iUserPos )
	{
	case UP_TRAINING:
		{
			Room *pRoom = GetMyRoom();
			if( pRoom && pRoom->GetModeType() == MT_TRAINING )
			{
				if( pRoom->IsRoomEmpty() )
				{
					iResult = FOLLOW_USER_ERROR_4;
					iNextUserPos = GetUserPos();
				}
				else if( pRoom->IsRoomFull() )
					iResult = FOLLOW_USER_ERROR_5;
				else if( pRoom->GetRoomIndex() == iRoomIndex )
					iResult = FOLLOW_USER_ERROR_6;		
				else if( !bDeveloper && 
						 !g_LevelMatchMgr.IsPlazaLevelJoin( pRoom->GetAverageLevel(), iAbilityLevel, JOIN_CHECK_MIN_LEVEL ) )
					iResult = FOLLOW_USER_ERROR_8;
				else if( pRoom->IsRoomPW() )
				{
					// 패스워드 입력 필요
					SP2Packet kPacket( STPK_FOLLOW_USER );
					kPacket << FOLLOW_USER_PLAZA_PW << GetPublicID() << iUserPos 
							<< pRoom->GetRoomIndex() << pRoom->GetAverageLevel() 
							<< pRoom->GetJoinUserCnt() << pRoom->GetPlayUserCnt() << pRoom->GetMaxPlayer()
							<< pRoom->GetRoomName() << (int)pRoom->GetPlazaModeType();
			 		pRequestUser->RelayPacket( kPacket );
					return false;
				}
				else if( pRoom->GetPlazaModeType() == PT_GUILD )
					iResult	= FOLLOW_USER_ERROR_15;
				else
				{
					return true;					
				}
			}
			else
			{
				iResult = FOLLOW_USER_ERROR_4;
				iNextUserPos = GetUserPos();
			}
		}
		break;
	case UP_BATTLE_ROOM:
		{
			BattleRoomParent *pBattleRoom = GetMyBattleRoom();
			Room  *pRoom  = GetMyRoom();
			if( pRoom &&
				( !pRoom->IsNoBattleModeType() && pRoom->GetRoomStyle() != RSTYLE_BATTLEROOM ) )
			{
				iResult = FOLLOW_USER_ERROR_9;
			}
			else if( !pBattleRoom )
			{
				iResult = FOLLOW_USER_ERROR_4;
				iNextUserPos = GetUserPos();
			}
			else 
			{
				bool bLevelMatch = true;
				if( bDeveloper || pBattleRoom->IsLevelMatchIgnore() )
					bLevelMatch = false;

				if( !bDeveloper && pBattleRoom->GetIndex() == iLeaveBattleRoomIndex )
					iResult = FOLLOW_USER_ERROR_13;
				else if( pBattleRoom->IsFull() )
					iResult = FOLLOW_USER_ERROR_5;
				else if( pBattleRoom->IsBattleTimeClose() )
					iResult = FOLLOW_USER_ERROR_7;
				else if( pBattleRoom->IsStartRoomEnterX() )
					iResult = FOLLOW_USER_ERROR_12;
				else if( pBattleRoom->IsNoChallenger() )
					iResult = FOLLOW_USER_ERROR_17;
				else if( bLevelMatch && 
						 !g_LevelMatchMgr.IsPartyLevelJoin( pBattleRoom->GetAbilityMatchLevel(), iAbilityLevel, JOIN_CHECK_MIN_LEVEL ) )
					iResult = FOLLOW_USER_ERROR_8;
				else if( pBattleRoom->IsPassword() )
				{
					// 패스워드 입력 필요
					SP2Packet kPacket( STPK_FOLLOW_USER );
					kPacket << FOLLOW_USER_PARTY_PW << GetPublicID() << iUserPos << pBattleRoom->GetIndex() << pBattleRoom->GetRoomLevel() 
							<< pBattleRoom->GetJoinUserCnt() << pBattleRoom->GetPlayUserCnt() << pBattleRoom->GetMaxPlayerBlue()
							<< pBattleRoom->GetMaxPlayerRed() << pBattleRoom->GetName();
					pRequestUser->RelayPacket( kPacket );
					return false;
				}
				else
				{
					return true;
				}
			}
		}
		break;
	case UP_LADDER_TEAM:
		{
			LadderTeamParent *pLadderTeam = GetMyLadderTeam();
			Room  *pRoom  = GetMyRoom();
			
			bool bGuildTeam = false;
			if( pLadderTeam && pLadderTeam->IsGuildTeam() && pLadderTeam->GetGuildIndex() == GetGuildIndex() )
			{
				bGuildTeam = true;
			}

			if( pRoom &&
				( !pRoom->IsNoBattleModeType() && pRoom->GetRoomStyle() != RSTYLE_BATTLEROOM ) )
			{
				iResult = FOLLOW_USER_ERROR_9;
			}
			else if( !pLadderTeam )
			{
				iResult = FOLLOW_USER_ERROR_4;
				iNextUserPos = GetUserPos();
			}
			else if( !bDeveloper && !bGuildTeam && 
				     !g_LevelMatchMgr.IsLadderLevelJoin( pLadderTeam->GetAbilityMatchLevel(), iAbilityLevel, JOIN_CHECK_MIN_LEVEL ) )
			{
				iResult = FOLLOW_USER_ERROR_8;
			}
			else 
			{
				if( pLadderTeam->IsMatchPlay() )
					iResult = FOLLOW_USER_ERROR_9;
				else if( pLadderTeam->IsFull() )
					iResult = FOLLOW_USER_ERROR_5;
				else
				{
					return true;
				}
			}
		}
		break;
	}		

	// 유저 위치가 변경되었으면 즉시 전서버에 동기화
	if( iResult == FOLLOW_USER_ERROR_4 )
		SyncUserPos();

	// 요청 유저에게 결과 전송
	SP2Packet kPacket( STPK_FOLLOW_USER );
	kPacket << iResult << GetPublicID() << iUserPos << iNextUserPos;
	pRequestUser->RelayPacket( kPacket );
	return false;
}

void User::_OnBattleRoomFollow( BattleRoomParent *pBattleRoom, int iNextPos )
{
	if( IsBattleRoom() ) return;
	CheckLeaveBattleRoomIndex();

	int iResult = FOLLOW_USER_OK;
	Room *pRoom = GetMyRoom();
	if( pRoom && ( !pRoom->IsNoBattleModeType() && pRoom->GetRoomStyle() != RSTYLE_BATTLEROOM ) )
	{
		iResult = FOLLOW_USER_ERROR_9;
	}
	else if( !pBattleRoom )
	{
		iResult = FOLLOW_USER_ERROR_4;
	}
	else 
	{
		bool bLevelMatch = true;
		if( IsDeveloper() || pBattleRoom->IsLevelMatchIgnore() )
			bLevelMatch = false;

		if( !IsDeveloper() && pBattleRoom->GetIndex() == m_iLeaveBattleRoomIndex )
			iResult = FOLLOW_USER_ERROR_13;
		else if( pBattleRoom->IsFull() )
			iResult = FOLLOW_USER_ERROR_5;
		else if( pBattleRoom->IsBattleTimeClose() )
			iResult = FOLLOW_USER_ERROR_7;
		else if( pBattleRoom->IsStartRoomEnterX() )
			iResult = FOLLOW_USER_ERROR_12;
		else if( pBattleRoom->IsNoChallenger() )
			iResult = FOLLOW_USER_ERROR_17;
		else if( bLevelMatch && 
				 !g_LevelMatchMgr.IsPartyLevelJoin( pBattleRoom->GetAbilityMatchLevel(), GetKillDeathLevel(), JOIN_CHECK_MIN_LEVEL ) )
		{
			iResult = FOLLOW_USER_ERROR_8;
		}
		else if( pBattleRoom->IsPassword() )
		{
			// 패스워드 입력 필요
			SP2Packet kPacket( STPK_FOLLOW_USER );
			kPacket << FOLLOW_USER_PARTY_PW << GetPublicID() << iNextPos << pBattleRoom->GetIndex() << pBattleRoom->GetRoomLevel() 
					<< pBattleRoom->GetJoinUserCnt() << pBattleRoom->GetPlayUserCnt() << pBattleRoom->GetMaxPlayerBlue()
					<< pBattleRoom->GetMaxPlayerRed() << pBattleRoom->GetName();
			SendMessage( kPacket );
			return;
		}
		else
		{
			m_iSearchBatleRoomIndex = pBattleRoom->GetIndex();
			ExitRoomToBattleRoomJoin( pBattleRoom, false, false, 0 );
		}
	}

	// 유저 위치가 변경되었으면 즉시 전서버에 동기화
	if( iResult == FOLLOW_USER_ERROR_4 )
		SyncUserPos();

	// 요청 유저
	SP2Packet kPacket( STPK_FOLLOW_USER );
	kPacket << iResult << GetPublicID() << iNextPos << iNextPos;
	SendMessage( kPacket );
}

void User::_OnLadderTeamFollow( LadderTeamParent *pLadderTeam, int iNextPos )
{
	if( IsLadderTeam() ) return;

	int iResult = FOLLOW_USER_OK;
	Room *pRoom = GetMyRoom();
	if( pRoom && ( !pRoom->IsNoBattleModeType() && pRoom->GetRoomStyle() != RSTYLE_BATTLEROOM ) )
	{
		iResult = FOLLOW_USER_ERROR_9;
	}
	else if( !pLadderTeam )
	{
		iResult = FOLLOW_USER_ERROR_4;
	}
	else 
	{		
		if( pLadderTeam->IsFull() )
		{
			iResult = FOLLOW_USER_ERROR_5;
		}
		else
		{
			ExitRoomToLadderTeamJoin( pLadderTeam );
		}
	}

	// 유저 위치가 변경되었으면 즉시 전서버에 동기화
	if( iResult == FOLLOW_USER_ERROR_4 )
		SyncUserPos();

	// 요청 유저
	SP2Packet kPacket( STPK_FOLLOW_USER );
	kPacket << iResult << GetPublicID() << iNextPos << iNextPos;
	SendMessage( kPacket );
}

void User::OnFollowUser( SP2Packet &rkPacket )
{
	if( IsReserveServerMoving() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "서버 이동이 예약된 유저가 따라가기 시도 : %s", GetPublicID().c_str() );
		return;
	}

	int iUserPos, iNextUserPos;
	ioHashString szUserName;
	rkPacket >> szUserName >> iUserPos;
	iNextUserPos = iUserPos;
	
	if( IsBattleRoom() || IsReserveBattleRoom() || IsLadderTeam() || IsReserveLadderTeam() )
	{
		SP2Packet kPacket( STPK_FOLLOW_USER );
		kPacket << FOLLOW_USER_ERROR_1 << szUserName << iUserPos << iNextUserPos;
		SendMessage( kPacket );
		return;
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		SP2Packet kPacket( STPK_FOLLOW_USER );
		kPacket << FOLLOW_USER_ERROR_2 << szUserName << iUserPos << iNextUserPos;
		SendMessage( kPacket );
		return;
	}
	else
	{
		UserParent *pUser = g_UserNodeManager.GetGlobalUserNode( szUserName );
		if( !pUser )
		{
			SP2Packet kPacket( STPK_FOLLOW_USER );
			kPacket << FOLLOW_USER_ERROR_3 << szUserName << iUserPos << iNextUserPos;
			SendMessage( kPacket );
		}
		else
		{
			CheckLeaveRoomIndex();      
			CheckLeaveBattleRoomIndex();
			// 현재 접속중인 룸
			int iMyRoomIndex = -1;
			if( m_pMyRoom )
				iMyRoomIndex = m_pMyRoom->GetRoomIndex();
			if( pUser->IsUserOriginal() )
			{		
				User *pUserOriginal = (User*)pUser;
				if( pUserOriginal->_OnFollowUser( (UserParent*)this, iUserPos, iMyRoomIndex, m_iLeaveRoomIndex, m_iLeaveBattleRoomIndex, IsDeveloper(), GetKillDeathLevel() ) )
				{
					switch( iUserPos )
					{
					case UP_TRAINING:
						{
							Room *pUserRoom = pUserOriginal->GetMyRoom();
							if( pUserRoom )
							{
								SP2Packet kPacket( STPK_JOIN_ROOM );
								kPacket << JOIN_ROOM_OK;
								kPacket << pUserRoom->GetModeType();
								kPacket << pUserRoom->GetModeSubNum();
								kPacket << pUserRoom->GetModeMapNum();
								kPacket << pUserRoom->GetRoomNumber();
								kPacket << (int)pUserRoom->GetPlazaModeType();
								SendMessage( kPacket );
								EnterRoom( pUserRoom );
							}							
						}
						break;
					case UP_BATTLE_ROOM:
						{
							BattleRoomParent *pUserBattleRoom = pUserOriginal->GetMyBattleRoom();
							if( pUserBattleRoom  )
								ExitRoomToBattleRoomJoin( pUserBattleRoom, false, false, 0 );
						}
						break;
					case UP_LADDER_TEAM:
						{
							LadderTeamParent *pUserLadderTeam = pUserOriginal->GetMyLadderTeam();
							if( pUserLadderTeam )
								ExitRoomToLadderTeamJoin( pUserLadderTeam );
						}
						break;
					}
				}
			}
			else
			{
				//해당 유저 서버로 전송
				SP2Packet kPacket( SSTPK_FOLLOW_USER );
				kPacket << GetUserIndex() << iUserPos << iMyRoomIndex << m_iLeaveRoomIndex << m_iLeaveBattleRoomIndex << szUserName << IsDeveloper() << GetKillDeathLevel();
				pUser->RelayPacket( kPacket );
			}
		}		
	}		
}

//따라가기 실행 전 유저가 있는 룸에서 강퇴가 되었는지 확인
void User::_OnUserPosIndex( UserParent *pRequestUser, bool bSafetyLevel, int iUserPos, int iPrevBattleIndex )
{
	switch( iUserPos )
	{
	case UP_TRAINING:
		{
			Room *pRoom = GetMyRoom();
			if( pRoom )
			{
				if( pRoom->GetPlazaModeType() == PT_GUILD )
				{
					SP2Packet kPacket( STPK_USER_POS_INDEX );
					PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
					PACKET_GUARD_VOID( kPacket.Write(iUserPos) );
					PACKET_GUARD_VOID( kPacket.Write(0) );
					pRequestUser->RelayPacket( kPacket );
				}
				else
					g_RoomNodeManager.SendPlazaRoomJoinInfo( pRequestUser, pRoom->GetRoomIndex() );
			}
			else        //예외
			{
				SP2Packet kPacket( STPK_USER_POS_INDEX );
				kPacket << GetPublicID() << iUserPos << 0; 
				pRequestUser->RelayPacket( kPacket );
			}
		}
		break;
	case UP_BATTLE_ROOM:
		{
			BattleRoomParent *pBattleRoom = GetMyBattleRoom();
			if( pBattleRoom )
			{
				g_BattleRoomManager.SendBattleRoomJoinInfo( pRequestUser, pBattleRoom->GetIndex(), iPrevBattleIndex );
			}
			else        //예외
			{
				SP2Packet kPacket( STPK_USER_POS_INDEX );
				kPacket << GetPublicID() << iUserPos << 0; 
				pRequestUser->RelayPacket( kPacket );
			}
		}
		break;
	case UP_LADDER_TEAM:
		{
			LadderTeamParent *pLadderTeam = GetMyLadderTeam();
			if( pLadderTeam )
			{
				g_LadderTeamManager.SendLadderTeamJoinInfo( pRequestUser, pLadderTeam->GetIndex() );
			}
			else
			{
				SP2Packet kPacket( STPK_USER_POS_INDEX );
				kPacket << GetPublicID() << iUserPos << 0; 
				pRequestUser->RelayPacket( kPacket );
			}
		}
		break;
	case UP_HEADQUARTERS:
		{
			Room *pRoom = GetMyRoom();
			if( pRoom && pRoom->GetModeType() == MT_HEADQUARTERS )
			{
				SP2Packet kPacket( STPK_HEADQUARTERS_INFO );
				pRoom->FillHeadquartersInfo( GetPublicID(), IsHeadquartersLock(), kPacket );
				pRequestUser->RelayPacket( kPacket );
			}
			else        //예외
			{
				SP2Packet kPacket( STPK_USER_POS_INDEX );
				kPacket << GetPublicID() << iUserPos << 0; 
				pRequestUser->RelayPacket( kPacket );
			}
		}
		break;
	case UP_HOUSE:
		{
			Room *pRoom = GetMyRoom();
			if( pRoom && pRoom->GetModeType() == MT_HOUSE )
			{
				SP2Packet kPacket( STPK_PERSONAL_HQ_INFO );
				pRoom->FillPersonalHQInfo( GetPublicID(), kPacket );
				pRequestUser->RelayPacket( kPacket );
			}
			else        //예외
			{
				SP2Packet kPacket( STPK_USER_POS_INDEX );
				kPacket << GetPublicID() << iUserPos << 0; 
				pRequestUser->RelayPacket( kPacket );
			}
		}
		break;
	}
}

void User::OnUserPosIndex( SP2Packet &rkPacket )
{
	int iUserPos;
	ioHashString szUserName;
	rkPacket >> szUserName >> iUserPos;

	if( IsBattleRoom() || IsLadderTeam() )
	{
		SP2Packet kPacket( STPK_FOLLOW_USER );
		kPacket << FOLLOW_USER_ERROR_1 << szUserName << iUserPos << iUserPos;
		SendMessage( kPacket );
		return;
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		SP2Packet kPacket( STPK_FOLLOW_USER );
		kPacket << FOLLOW_USER_ERROR_2 << szUserName << iUserPos << iUserPos;
		SendMessage( kPacket );
		return;
	}
	else
	{	
		UserParent *pUser = g_UserNodeManager.GetGlobalUserNode( szUserName );
		if( !pUser )
		{
			SP2Packet kPacket( STPK_FOLLOW_USER );
			kPacket << FOLLOW_USER_ERROR_3 << szUserName << iUserPos << iUserPos;
			SendMessage( kPacket );
		}
		else
		{
			CheckLeaveBattleRoomIndex();
			if( pUser->IsUserOriginal() )
			{		
				User *pUserOriginal = (User*)pUser;		
				pUserOriginal->_OnUserPosIndex( (UserParent*)this, IsSafetyLevel(), iUserPos, m_iLeaveBattleRoomIndex );
			}
			else
			{
				//해당 유저 서버로 전송
				SP2Packet kPacket( SSTPK_USER_POS_INDEX );
				kPacket << GetUserIndex() << iUserPos << szUserName << IsSafetyLevel() << m_iLeaveBattleRoomIndex;
				pUser->RelayPacket( kPacket );
			}
		}		
	}		
}

void User::OnDeveloperMacro( SP2Packet &rkPacket )
{
	int iMacro;
	rkPacket >> iMacro;

	if( !IsDeveloper() )
		return;	

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnDeveloperMacro( %s : %d )", GetPublicID().c_str(), iMacro );
	switch( iMacro )
	{
	case DEVELOPER_ROOM_INFO:
		{
			if( m_pMyRoom )
			{
				SP2Packet kPacket( STPK_DEVELOPER_MACRO );
				kPacket << DEVELOPER_ROOM_INFO;
				m_pMyRoom->FillRoomAndUserInfo( kPacket );
				kPacket << 0 << 0;
				SendMessage( kPacket );
			}			
		}
		break;
	case DEVELOPER_ROOM_ENTER:
		{
		}
		break;
	case DEVELOPER_GUILDMARK_BLOCK:
		{
			ioHashString szGuildName;
			rkPacket >> szGuildName;

			// 메인 서버가 처리
			SP2Packet kPacket( MSTPK_GUILD_MARK_BLOCK_INFO );
			kPacket << GetPublicID() << szGuildName;
			g_MainServer.SendMessage( kPacket );
		}
		break;
	case DEVELOPER_EVENT_TEST:
		{
			// 매일매일 골드 아이템~♬ 초기화
			OneDayGoldItemEvent *pEventNode = static_cast<OneDayGoldItemEvent*> ( m_EventUserMgr.GetEventUserNode( EVT_ONE_DAY_GOLD_ITEM ) );
			if( pEventNode )
			{
				pEventNode->SetValue( VA_GOLD_ITEM_RECV_DATE, 0 );
				pEventNode->CheckGoldItemDate( this );
			}
		}
		break;
	case DEVELOPER_QUEST_ATTAIN:
		{
			OnQuestAttain( rkPacket );
		}
		break;
	case DEVELOPER_EXTRAITEM_GROWTH_CATALYST_INFO:
		{
			DWORD dwItemCode;
			rkPacket >> dwItemCode;

			// 메인 서버가 처리
			SP2Packet kPacket( MSTPK_EXTRAITEM_GROWTH_CATALYST_INFO );
			kPacket << GetUserIndex() << dwItemCode;
			g_MainServer.SendMessage( kPacket );
		}
		break;
	case DEVELOPER_SPAWN_NPC:
		{
			int nNpc;
			rkPacket >> nNpc;

			SP2Packet kPacket( MSTPK_EVENT_NPC_CLOSE );
			kPacket << nNpc;
			g_MainServer.SendMessage( kPacket );
		}
		break;

	case DEVELOPER_PLAZA_NPC_SPAWN:
		OnSpawnNpcInPlaza(rkPacket);
		break;
		
	case DEVELOPER_BINGO_PRESENT:
		{
			// Declare)
			vector< stRewardData > tempData;


			// Get
			g_BingoMgr.GetRegisterRewardPresentInfo( tempData );
			g_BingoMgr.GetRegisterAllBingoPresentInfo( tempData );

			vector< stRewardData >::iterator	iter	= tempData.begin();
			vector< stRewardData >::iterator	iterEnd	= tempData.end();

			CTimeSpan cPresentGapTime( g_BingoMgr.GetPeriod(), 0, 0, 0 );
			CTime kPresentTime = CTime::GetCurrentTime() + cPresentGapTime;

			// 선물지급.
			while( iter != iterEnd )
			{
				// To Memory
				AddPresentMemory( g_BingoMgr.GetSendID(), (*iter).type, (*iter).value1, (*iter).value2, 0, 0,
								g_BingoMgr.GetMent(), kPresentTime, g_BingoMgr.GetState() );

				++iter;
			}

			SendPresentMemory();
		}
		break;
	case DEVELOPER_SUPERGASHAPON_GET_ALL:
		{
			OnSuperGashaponGetAll( rkPacket );
		}
		break;
	case DEVELOPER_SUPERGASHAPON_GET:
		{
			OnSuperGashaponGet( rkPacket );
		}
		break;
	case DEVELOPER_SUPERGASHAPON_LIMIT_INFO_GET:
		{
			OnSuperGashaponInfoGet( rkPacket );
		}
		break;
	case DEVELOPER_SUPERGASHAPON_LIMIT_INFO_RESET:
		{
			OnSuperGashaponInfoReset( rkPacket );
		}
		break;
	case DEVELOPER_ATTENDANCE_WND_SHOW:
		{
			m_UserAttendance.OnMacroShowAttendanceWnd();
		}
		break;
	case DEVELOPER_ATTENDANCE_ADD_DAY:
		{
			OnMacroAttendanceAddDay( rkPacket );
		}
		break;
	case DEVELOPER_ATTENDANCE_ADD_PREV_MONTH:
		{
			OnMacroAttendancePrevMonth( rkPacket );
		}
		break;
	case DEVELOPER_ATTENDANCE_RESET:
		{
			m_UserAttendance.OnMacroShowAttendanceReset();
		}
		break;
	case DEVELOPER_ATTENDANCE_SET_DATE:
		{
			OnMacroAttendanceDateModify( rkPacket );
		}
		break;
	case DEVELOPER_AWAKE_SET_DATE:
		{
			OnTestAwakeTimeSet( rkPacket );
		}
		break;
	case DEVELOPER_MISSION_SET_DATE:
		{
			OnTestMissionSetDate( rkPacket );
		}
		break;
	case DEVELOPER_MISSION_SET_VALUE:
		{
			OnTestMissionSetValue( rkPacket );
		}
		break;
	case DEVELOPER_ROOLBOOK_PROGRESS:
		{
			OnTestRollBookProgress( rkPacket );
		}
		break;
	case DEVELOPER_HOUSING_TEST:
		{
			OnTestCheckHousingInfo( rkPacket );
		}
		break;
	case DEVELOPER_TOURNAMENT_MACRO:
		{
			OnTestTournamentMacro( rkPacket );
		}
		break;
#if defined( SRC_OVERSEAS )
	// 일반 가챠 패키지 전부 보내기		JCLEE 140718
	case DEVELOPER_GASHAPON_GET_ALL:
		{
			OnGetGashaAll( rkPacket );
		}
		break;
#endif

	}	
}

void User::OnSpawnNpcInPlaza(SP2Packet &rkPacket)
{
	if( GetPlayingMode() == MT_TRAINING )
	{
		ioHashString szSpawn;
		rkPacket >> szSpawn;

		if( szSpawn == "출근" )
			m_pMyRoom->SetInstantSpawnNpc(true);
		else if( szSpawn == "퇴근" )
			m_pMyRoom->SetInstantSpawnNpc(false);
	}
}

void User::OnSuperGashaponGetAll( SP2Packet &rkPacket )
{
	DWORD dwEtcItemCode;
	rkPacket >>dwEtcItemCode;
		
	g_SuperGashaponMgr.SendSuperGashaponAllPackage( this, dwEtcItemCode );
	SendPresentMemory();
}

void User::OnSuperGashaponGet( SP2Packet &rkPacket )
{
	int iPackageIndex;
	DWORD dwEtcItemCode;
	rkPacket >>dwEtcItemCode >> iPackageIndex;

	g_SuperGashaponMgr.SendSuperGashaponPackage( this, dwEtcItemCode, iPackageIndex );
	SendPresentMemory();
}

void User::OnSuperGashaponInfoGet( SP2Packet &rkPacket )
{
	DWORD dwEtcItemCode;
	rkPacket >>dwEtcItemCode;

	if( g_SuperGashaponMgr.IsLimitGashapon( dwEtcItemCode ) )
	{
		SP2Packet kPacket( MSTPK_SUPER_GASHPON_LIMIT_INFO );
		kPacket << GetUserIndex() << dwEtcItemCode;
		g_MainServer.SendMessage( kPacket );
	}
	else
	{
		SP2Packet kPacket( STPK_DEVELOPER_MACRO );
		kPacket << DEVELOPER_SUPERGASHAPON_LIMIT_INFO_GET;
		kPacket << dwEtcItemCode << 0 << 0;
		SendMessage( kPacket );
	}
}

void User::OnSuperGashaponInfoReset(SP2Packet &rkPacket)
{
	DWORD dwEtcItemCode;
	rkPacket >>dwEtcItemCode;

	if( g_SuperGashaponMgr.IsLimitGashapon( dwEtcItemCode ) )
	{
		SP2Packet kPacket( MSTPK_SUPER_GASHPON_LIMIT_RESET );
		kPacket << GetUserIndex() << dwEtcItemCode;
		g_MainServer.SendMessage( kPacket );
	}
}

void User::OnMacroAttendanceAddDay(SP2Packet &rkPacket)
{	
	int iDayCount = 0;		
	PACKET_GUARD_VOID( rkPacket.Read( iDayCount ) );

	if( 0 < iDayCount )
	{
		m_UserAttendance.OnMacroAttendanceAddDay( iDayCount );
	}
}

void User::OnMacroAttendancePrevMonth(SP2Packet &rkPacket)
{
	int iDayCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read( iDayCount ) );

	if( 0 < iDayCount )
	{
		m_UserAttendance.OnMacroAttendancePrevMonth( iDayCount );
	}
}

void User::OnMacroAttendanceDateModify(SP2Packet &rkPacket)
{
	int iYear  = 0;
	int iMonth = 0;
	int iDay   = 0;

	PACKET_GUARD_VOID( rkPacket.Read( iYear ) );
	PACKET_GUARD_VOID( rkPacket.Read( iMonth ) );
	PACKET_GUARD_VOID( rkPacket.Read( iDay ) );	

	m_UserAttendance.OnMacroAttendanceDateModify( iYear, iMonth, iDay );
}

void User::OnPresentTestSend( SP2Packet &rkPacket )
{//MOLPHIN
	if(    g_App.GetPublicIP() != "172.20.20.76" 
		&& g_App.GetPublicIP() != "172.20.20.75" 
		&& g_App.GetPublicIP() != "172.20.20.134"
		&& g_App.GetPublicIP() != "172.20.20.177"
		&& g_App.GetPublicIP() != "172.20.20.182"
		&& g_App.GetPublicIP() != "172.20.20.193"	// INDO
		&& g_App.GetPublicIP() != "172.20.20.194"   // japan
		&& g_App.GetPublicIP() != "172.20.20.195"	// THai
		&& g_App.GetPublicIP() != "172.20.20.196"	// TW
		&& g_App.GetPublicIP() != "172.20.20.198"	// US
		//&& g_App.GetPublicIP() != "210.118.58.239"   // japan 개발존
		//&& g_App.GetPublicIP() != "210.118.58.229"   // taiwan 개발존
		//&& g_App.GetPublicIP() != "210.118.58.230"   // thai 개발존
		//&& g_App.GetPublicIP() != "210.118.58.227" ) // 영어 개발존
		)
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnPresentTestSend : 여기서 나올 수 없는 패킷이다!! : %s - %s:%s", g_App.GetPublicIP().c_str(), GetPublicID().c_str(), GetPublicIP() );
		return;
	}

	if( g_App.GetPublicIP() != "172.20.20.76" && g_App.GetPublicIP() != "172.20.20.75" && g_App.GetPublicIP() != "172.20.20.78" && g_App.GetPublicIP() != "172.20.20.134" &&
		
		g_App.GetPublicIP() != "172.20.20.141" && g_App.GetPublicIP() != "172.20.20.34" && g_App.GetPublicIP() != "172.20.20.22" && g_App.GetPublicIP() != "172.20.20.40" )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnPresentTestSend : 여기서 나올 수 없는 패킷이다!! : %s - %s:%s", g_App.GetPublicIP().c_str(), GetPublicID().c_str(), GetPublicIP() );
		return;
	}
	
	short iPresentType;
	int iPresentValue1, iPresentValue2;
	rkPacket >> iPresentType >> iPresentValue1 >> iPresentValue2;

	CTimeSpan cPresentGapTime( 30, 0, 0, 0 );
	CTime kPresentTime = CTime::GetCurrentTime() + cPresentGapTime;
	g_DBClient.OnInsertPresentData( GetUserDBAgentID(), GetAgentThreadID(), "DeveloperK", GetPublicID(), iPresentType, iPresentValue1, iPresentValue2, 0, 0, 
									1, kPresentTime, 1 );
	g_LogDBClient.OnInsertPresent( 0, "DeveloperK", g_App.GetPublicIP().c_str(), GetUserIndex(), iPresentType, iPresentValue1, iPresentValue2, 0, 0, LogDBClient::PST_RECIEVE, "사내테스트" );	
	_OnSelectPresent( 30 );     // 받지 않은 선물 최대 30개 요청
}

//UDP
void User::OnUDPConnect( SP2Packet &rkPacket )
{
	SP2Packet kReturn(SUPK_CONNECT);
	g_UDPNode.SendMessage( GetPublicIP(), GetUDP_port(), kReturn );

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( !pLocal )
		return;

	//HRYOON 20150109 태국 - 주석 처리 두번getcash 요청
	if( pLocal->IsGetCashAfterPublicIP() )
	{
		SP2Packet kBillingPacket;
		OnWebGetCash( kBillingPacket );
	}

	if( !pLocal->IsIPBonus() )
		return;

	if( GetPrivateID().IsEmpty() )
		return;

	if( strcmp( GetPublicIP(), "" ) == 0  )
		return;

	if( m_bSendCheckPCRoom )
		return;

	SP2Packet kBillingPacket( BSTPK_IPBONUS );
	kBillingPacket << GetPrivateID();
	kBillingPacket << GetPublicIP();
	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send Fail : %s:%s", __FUNCTION__, GetPrivateID().c_str(), GetPublicIP() );
	}
	else
	{
		m_bSendCheckPCRoom = true;
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Send : %s:%s", __FUNCTION__, GetPrivateID().c_str(), GetPublicIP() );
	}
}

#ifdef _ITEST
#define PING_MS_VALUE   60
#define SYNC_TIME_GAP	900000
#else
#define PING_MS_VALUE   60
#define SYNC_TIME_GAP	9000
#endif

void User::_OnCheckPingStep( DWORD dwClientTime )
{
	if( m_first_heart_beat || dwClientTime == 0 )
	{
		m_dwPingStep = 0;
	}
	else
	{
		int iGapTime = abs( (int)TIMEGETTIME() - (int)dwClientTime );
		m_dwPingStep = iGapTime / PING_MS_VALUE;
	}	
}

void User::OnSyncTime( SP2Packet &rkPacket )
{
	DWORD client_time = 0;
	rkPacket >> client_time;

	int send_total_index = -1;
	rkPacket >> send_total_index;

	bool bNowWorkPing = false;
	rkPacket >> bNowWorkPing;

	DWORD current_time = TIMEGETTIME();
	DWORD gap_time = current_time - m_sync_time;
	
	_OnCheckPingStep( client_time );

	if( send_total_index > 0 )
	{
		if( m_ping_total_send_index == send_total_index )
		{
			HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ERROR : %s ping duplicated(%d:%d:%d)",
										GetPublicID().c_str(),
										m_ping_total_send_index,
										send_total_index,
										gap_time );
			return;
		}
		else if( m_ping_total_send_index > send_total_index )
		{
			HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ERROR : %s ping out of ordering(%d:%d:%d)",
										GetPublicID().c_str(),
										m_ping_total_send_index,
										send_total_index,
										gap_time );
			return;
		}
	}

	// 여기에 패킷 추가 금지
	SP2Packet kPacket(SUPK_SYNCTIME);
	kPacket << Help::IsWholeChatOn() << current_time;
	g_UDPNode.SendMessage( GetPublicIP(), GetUDP_port(), kPacket );

	if( !m_first_heart_beat )
	{
		if( m_pMyRoom && m_dwSpeedHackQuizLimitTime == 0 )
		{
			// 스피드핵 점검
			if( gap_time < 200 )
			{
				HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ERROR : %s Ping Gap(%d) too small, (%d/%d)",
											GetPublicID().c_str(),
											gap_time,
											m_ping_total_send_index,
											send_total_index );
			}
			else if( gap_time < HackCheck::SH_LessCheckTime() )
			{
				if( m_prev_over_ping_time > 0 )
				{
					DWORD dwDoubleGapTime = ( m_prev_over_ping_time + SYNC_TIME_GAP + gap_time ) / 2;

					if( dwDoubleGapTime < HackCheck::SH_LessCheckTime() )
					{
						m_ping_less_error_count++;
						m_total_ping_error_count++;
					}
				}
				else
				{
					m_ping_less_error_count++;
					m_total_ping_error_count++;
				}
			}
			else if( gap_time > HackCheck::SH_OverCheckTime() )
			{
				// 중간에 핑이 소실되지 않았다.
				if( m_ping_total_send_index + 1 == send_total_index  && !bNowWorkPing )
				{
					m_ping_over_error_count++;
					m_total_ping_error_count++;
				}
				else
				{
					// 중간 핑소실로 인한 것이라서 봐준다..
				}
			}
			else	// 정상 범위
			{
				m_ping_less_error_count = 0;
				m_ping_over_error_count = 0;
			}			
		}

		if( m_pMyRoom || IsBattleRoom() || IsLadderTeam() )
			m_dwSyncCheckTime = 90000;        //고스트 소켓 체크 시간을 1분 30초로 감소
#ifdef _ITEST
		m_dwSyncCheckTime = 90000000;
#endif
	}
	else	// 접속이후 최초 PingMessage..
	{
		m_ping_less_error_count = 0;
		m_ping_over_error_count = 0;
		m_prev_over_ping_time = 0;
		m_first_heart_beat = false;
	}

	m_sync_time = current_time;
	m_ping_total_send_index = send_total_index;

	if( gap_time > SYNC_TIME_GAP )
		m_prev_over_ping_time = gap_time - SYNC_TIME_GAP;
	else
		m_prev_over_ping_time = 0;

	if( m_pMyRoom && m_dwSpeedHackQuizLimitTime == 0 )
	{
#if !defined(_DEBUG) 
		if( CheckHackCount( gap_time ) )
		{
			// 태국 버전 스피드핵 체크 해제
			if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
			{
				m_dwSpeedHackQuizLimitTime	= 0;
				m_iCurSpeedHackAnswerChance = 0;
				m_ping_less_error_count		= 0;
				m_ping_over_error_count		= 0;
				m_total_ping_error_count	= 0;
			}
			else
			{
				m_SpeedHackQuiz = HackCheck::GenerateProblem( HackCheck::HT_SPEED );
				m_dwSpeedHackQuizLimitTime  = TIMEGETTIME() + HackCheck::ServerAnswerTime( HackCheck::HT_SPEED );
				m_iCurSpeedHackAnswerChance = 0;

				SP2Packet kPacket( STPK_HACK_ANNOUNCE );
				kPacket << (int)HackCheck::HT_SPEED;
				kPacket << HackCheck::MaxAnswerChance( HackCheck::HT_SPEED );
				kPacket << HackCheck::ClientAnswerTime( HackCheck::HT_SPEED );
				kPacket << m_SpeedHackQuiz.m_iFirstOperand;
				kPacket << m_SpeedHackQuiz.m_iSecondOperand;
				kPacket << (int)m_SpeedHackQuiz.m_Operator;
				SendMessage( kPacket );

				m_ping_less_error_count  = 0;
				m_ping_over_error_count  = 0;
				m_total_ping_error_count = 0;
			}			
		}
#endif
	}
}

void User::OnCheckKingUserPing( SP2Packet &rkPacket )
{
	// 모드 체크
	if( !m_pMyRoom || ( m_pMyRoom->GetModeType() != MT_KING && m_pMyRoom->GetModeType() != MT_DOBULE_CROWN ) )
	{
		m_iCurCheckKingIndex  = 0;
		m_iCurRecvKingPingCnt = 0;
		return;
	}
	//

	DWORD client_time = 0;
	rkPacket >> client_time;

	int iCheckKingIndex;
	rkPacket >> iCheckKingIndex;

	// 오래된 핑은 버린다
	if( iCheckKingIndex <= m_iCurCheckKingIndex )
		return;

	/*
	DWORD current_time = TIMEGETTIME();
	DWORD gap_time = 0;
	
	if( current_time > client_time )
		gap_time = current_time - client_time;

	// KING_PING_LIMITE 이상 차이나는 핑은 무시한다
	if( gap_time > KING_PING_LIMITE )
		return;
	*/

	m_iCurCheckKingIndex = iCheckKingIndex;
	m_iCurRecvKingPingCnt++;
}

void User::ClearKingPingCnt()
{
	m_iCurRecvKingPingCnt = 0;
}

void User::OnReserveRoomJoin( SP2Packet &rkPacket )
{
	if( m_pMyRoom )
	{
		//에러
		SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
		kPacket << RESERVE_ROOM_JOIN_ERROR_1;
		SendMessage( kPacket );
		return;
	}

	int iRoomIndex;
	rkPacket >> iRoomIndex;

	if( iRoomIndex == -1 )
	{
		// 채널 이동 ( 본부에서 다른 서버의 본부로 이동 )
		SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
		kPacket << RESERVE_ROOM_MYROON_JOIN_OK;
		SendMessage( kPacket );
		return;
	}

	Room *pRoom = g_RoomNodeManager.GetRoomNode( iRoomIndex );
	if( !pRoom )
	{
		//에러
		SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
		kPacket << RESERVE_ROOM_JOIN_ERROR_2;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnReserveRoomJoin Not Room : %s - %d", GetPublicID().c_str(), iRoomIndex );
		return;
	}

	if( pRoom->GetPlazaModeType() != PT_GUILD)
	{
		if( pRoom->IsRoomEmpty() )
		{
			//에러
			SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
			kPacket << RESERVE_ROOM_JOIN_ERROR_3;
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnReserveRoomJoin Empty Room : %s - %d", GetPublicID().c_str(), iRoomIndex );
			return;
		}
	}

	if( !pRoom->IsReserveUser( GetUserIndex() ) )
	{
		//에러
		SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
		kPacket << RESERVE_ROOM_JOIN_ERROR_4;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnReserveRoomJoin Not Reserve Room : %s - %d", GetPublicID().c_str(), iRoomIndex );

		//전투방 유저면
		if( pRoom->GetRoomStyle() == RSTYLE_BATTLEROOM )
		{
			if( IsBattleRoom() )
			{
				LeaveBattleRoom();
				SP2Packet kPacket( STPK_BATTLEROOM_LEAVE );
				kPacket << GetPublicID();
				SendMessage( kPacket );
			}
		}    //셔플룸 유저면
		else if(  pRoom->GetRoomStyle() == RSTYLE_SHUFFLEROOM )
		{
			if( IsShuffleRoom() )
			{
				LeaveShuffleRoom();
				SP2Packet kPacket( STPK_SHUFFLEROOM_LEAVE );
				kPacket << GetPublicID();
				SendMessage( kPacket );
			}
		}    //진영팀 유저면
		else if( pRoom->GetRoomStyle() == RSTYLE_LADDERBATTLE )  
		{
			if( IsLadderTeam() )
			{
				SP2Packet kPacket( STPK_LADDERTEAM_LEAVE );

				PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

				SendMessage( kPacket );
				LeaveLadderTeam();
			}
		}
		return;
	}

	// 전투방이나 진영팀에서 서버 이동으로 룸에 입장하기 전에 팀을 이탈했다면 룸에 입장시키지않고 본부로 보낸다.
	switch( pRoom->GetRoomStyle() )
	{
	case RSTYLE_BATTLEROOM:
		if( !IsBattleRoom() )
		{
			pRoom->LeaveReserveUser( GetUserIndex() );
			SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
			kPacket << RESERVE_ROOM_JOIN_ERROR_4;
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnReserveRoomJoin Prev BattleRoom Leave : %s - %d", GetPublicID().c_str(), iRoomIndex );
			return;
		}
		break;
	case RSTYLE_SHUFFLEROOM:
		if( !IsShuffleRoom() )
		{
			pRoom->LeaveReserveUser( GetUserIndex() );
			SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
			kPacket << RESERVE_ROOM_JOIN_ERROR_4;
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnReserveRoomJoin Prev ShuffleRoom Leave : %s - %d", GetPublicID().c_str(), iRoomIndex );
			return;
		}
		break;
	case RSTYLE_LADDERBATTLE:
		if( !IsLadderTeam() )
		{
			pRoom->LeaveReserveUser( GetUserIndex() );
			SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
			kPacket << RESERVE_ROOM_JOIN_ERROR_4;
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnReserveRoomJoin Prev LadderTeam Leave : %s - %d", GetPublicID().c_str(), iRoomIndex );
			return;
		}
		break;
	}

	EnterRoom( pRoom );

	SP2Packet kPacket( STPK_RESERVE_ROOM_JOIN );
	kPacket << RESERVE_ROOM_JOIN_OK;
	SendMessage( kPacket );	
}

bool User::CheckHackCount( DWORD dwCurGap )
{
#ifdef _ITEST
	return false;
#endif

	if( HackCheck::SH_LessCount() > 0 )
	{
		if( m_ping_less_error_count >= HackCheck::SH_LessCount() )
		{
			PrintHackLog( dwCurGap );
			return true;
		}
	}

	if( HackCheck::SH_OverCount() > 0 )
	{
		if( m_ping_over_error_count >= HackCheck::SH_OverCount() )
		{
			PrintHackLog( dwCurGap );
			return true;
		}
	}

	if( HackCheck::SH_LessOverCount() > 0 )
	{
		if( m_ping_less_error_count + m_ping_over_error_count >= HackCheck::SH_LessOverCount() )
		{
			PrintHackLog( dwCurGap );
			return true;
		}
	}

	if( HackCheck::SH_TotalCount() > 0 )
	{
		if( m_total_ping_error_count >= HackCheck::SH_TotalCount() )
		{
			PrintHackLog( dwCurGap );
			return true;
		}
	}

	return false;
}

void User::PrintHackLog( DWORD dwCurGap )
{
	HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "HACK : %s(%d) Less:%d, Over:%d, Total:%d", 
								GetPublicID().c_str(),
								dwCurGap,
								m_ping_less_error_count,
								m_ping_over_error_count,
								m_total_ping_error_count );
}

void User::OnHackQuiz( SP2Packet &rkPacket )
{
	int iType;
	rkPacket >> iType;

	if( m_dwSpeedHackQuizLimitTime == 0 )
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnHackQuiz - %s Not Quiz User(%d)", GetPublicID().c_str(), iType );
		return;
	}

	if( iType == ID_QUIZ_ANSWER )
	{
		int iRecvAnswer = -999999;
		rkPacket >> iRecvAnswer;

		if( TIMEGETTIME() > m_dwSpeedHackQuizLimitTime )
		{
			m_dwSpeedHackQuizLimitTime  = 0;
			m_iCurSpeedHackAnswerChance = 0;
			HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "HACK : %s Server TimeOver", GetPublicID().c_str() );

			SP2Packet kPacket( STPK_HACK_QUIZ );
			kPacket << ID_QUIZ_SERVER_TIMEOVER;
			SendMessage( kPacket );
		}
		else
		{
			int iServerAnswer = HackCheck::SolveProblem( m_SpeedHackQuiz );
			if( iRecvAnswer == iServerAnswer )
			{
				m_dwSpeedHackQuizLimitTime  = 0;
				m_iCurSpeedHackAnswerChance = 0;
				HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "HACK : %s Answer OK", GetPublicID().c_str() );

				SP2Packet kReturn( STPK_HACK_QUIZ );
				kReturn << ID_QUIZ_OK;
				SendMessage( kReturn );
			}
			else
			{
				if( m_iCurSpeedHackAnswerChance + 1 >= HackCheck::MaxAnswerChance( HackCheck::HT_SPEED ) )
				{
					m_dwSpeedHackQuizLimitTime  = 0;
					m_iCurSpeedHackAnswerChance = 0;
					HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "HACK : %s Kicked", GetPublicID().c_str() );

					SP2Packet kReturn( STPK_HACK_QUIZ );
					kReturn << ID_QUIZ_KICK;
					kReturn << iRecvAnswer;
					SendMessage( kReturn );
				}
				else
				{
					m_iCurSpeedHackAnswerChance++;
					HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "HACK : %s Retry(%d)", GetPublicID().c_str(), m_iCurSpeedHackAnswerChance );

					SP2Packet kReturn( STPK_HACK_QUIZ );
					kReturn << ID_QUIZ_RETRY;
					kReturn << iRecvAnswer;
					kReturn << m_iCurSpeedHackAnswerChance;

					m_SpeedHackQuiz = HackCheck::GenerateProblem( HackCheck::HT_SPEED );
					kReturn << m_SpeedHackQuiz.m_iFirstOperand;
					kReturn << m_SpeedHackQuiz.m_iSecondOperand;
					kReturn << m_SpeedHackQuiz.m_Operator;
					SendMessage( kReturn );
				}
			}
		}
	}
	else if( iType == ID_QUIZ_TIMEOVER )
	{
		m_dwSpeedHackQuizLimitTime  = 0;
		m_iCurSpeedHackAnswerChance = 0;
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "HACK : %s Client Answer Time Over", GetPublicID().c_str() );
	}
	else
	{
		m_dwSpeedHackQuizLimitTime  = 0;
		m_iCurSpeedHackAnswerChance = 0;
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnHackQuiz - %s Unknown Type(%d)", GetPublicID().c_str(), iType );
	}
}

void User::OnExerciseCharCreate( SP2Packet &packet )
{
	// 상점 블럭.
	if( IsCharCreating() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate block", GetPublicID().c_str() );
		// 레벨업 보상 지급중이다 완료시까지 용병 구매 불가.
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_FAIL_WORKING ) );
		SendMessage( kReturn );
		return;
	}

	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate Billing Wait %s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_BILLING_WAIT ) );
		SendMessage( kReturn );
		return;
	}

 	int iExerciseStyle, iClassType;
	bool bWait;
	bool bOneChar;
	bool bCharDelete;
	packet >> iExerciseStyle >> iClassType ;
	packet >> bWait;
	packet >> bOneChar;
	packet >> bCharDelete;

	if( !IsBuyExerciseChar( iExerciseStyle ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate Wrong Mode %d", GetPublicID().c_str() , GetPlayingMode() );
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	if( iExerciseStyle != EXERCISE_EVENT ) // EXERCISE_GENERAL 이타입은 현재 사용하지 않으므로 에러로 간주
	{
		// 잘못된 체험 스타일
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate 잘못된 체험 스타일 = %d", GetPublicID().c_str(), iExerciseStyle );
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	DWORD dwSetItemCode = iClassType + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !pSetInfo )
	{
		// 잘못된 세트 값.
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate 잘못된 세트 값을 보냈다 = %d", GetPublicID().c_str(), iClassType );
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	// 고용중인 용병이면 체험 용병 불가 - 대여 용병은 PC방 용병과 별개
	if( IsBuyActiveChar( iClassType ) || IsClassTypeExerciseStyle( iClassType, EXERCISE_RENTAL ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate 이미 보유하고 있는 용병 구매 요청 = %d", GetPublicID().c_str(), iClassType );
		//
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	// 체험 용병을 넣을 슬롯이 없으면 안됨
	if( GetCharCount() - GetExerciseCharCount( EXERCISE_EVENT ) >= m_iCurMaxCharSlot )
	{
		// 선택한 용병이 재고용 상태가 아닌데 슬롯 풀!!
		if( !bCharDelete )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate 빈 슬롯이 없음 = %d", GetPublicID().c_str(), iClassType );
			//
			SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
			PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
			SendMessage( kReturn );
			return;
		}	
	}

	if( g_ItemPriceMgr.IsCashOnly( iClassType ) ) 
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate 캐쉬로만 판매하는 용병 요청 = %d", GetPublicID().c_str(), iClassType );
		//
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	// EventType eEventType = EVT_CHILDRENDAY;
	EventType eEventType = EVT_EXERCISESOLDIER;
	if( eEventType == EVT_CHILDRENDAY )
	{
		if( g_EventMgr.GetValue( EVT_CHILDRENDAY, EA_CHILDRENDAY_IS_LIMIT ) == 1 )
		{
			if( !IsCanBuyItem( pSetInfo ) )
			{
				SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
				PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_NEED_LEVEL ) );
				SendMessage( kReturn );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnExerciseCharCreate need level %s:%d", GetPublicID().c_str() , GetGradeLevel() );
				return;
			}
		}
	}
	else if( eEventType == EVT_EXERCISESOLDIER )
	{
		if( m_pMyRoom && m_pMyRoom->GetModeType() != MT_HEADQUARTERS )
		{
			SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
			PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnExerciseCharCreate Not HeadQuarter %s:%d|%d", GetPublicID().c_str() , GetUserIndex(), (int) eEventType );
			return;
		}
	}

	// 이벤트 기간이 종료되었는지 확인
	if( !g_EventMgr.IsAlive( eEventType, GetChannelingType() ) )
	{
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EVENT_END ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnExerciseCharCreate Event End %s", GetPublicID().c_str() );
		return;
	}
	

	if( !g_ExerciseCharIndexMgr.IsHave() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnExerciseCharCreate Don't have index", GetPublicID().c_str() );
		SP2Packet kReturn( STPK_EXERCISE_EVENT_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_FAIL_MAKE_INDEX ) );
		SendMessage( kReturn );
		return;
	}

	DeleteExerciseChar( EXERCISE_GENERAL );	
	DeleteExerciseChar( EXERCISE_EVENT );
	FixSelectChar();

	// 체험 용병과 동일한 타입의 용병이 재고용 상태이면 용병을 해고.
	DWORD dwCharDeleteIndex = 0;
	if( bCharDelete )
	{
		for(int i = 0;i < GetCharCount();i++)
		{
			if( m_CharList[i]->IsActive() ) continue;

			const CHARACTER rkChar = m_CharList[i]->GetCharInfo();
			if( rkChar.m_class_type == iClassType )
			{
				dwCharDeleteIndex = m_CharList[i]->GetCharIndex();		
				_OnCharDelete( i );
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnExerciseCharCreate :: CharDelete( %s ) : %d", GetPublicID().c_str(), iClassType );
				break;
			}
		}
	}	
	//
	ioCharacter *pCharacter = AddCharDataToPointer();
	//char data
	CHARACTER kCharInfo;
	kCharInfo.m_class_type = iClassType;	//클래스타입
	
	// 착용중인 아이템이 있으면 아이템 적용
	m_Inventory.GetEquipItemCode( kCharInfo );	
	// 착용한 아이템이 없다면 Default 지급
	if( kCharInfo.m_face == -1)
		kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
	if( kCharInfo.m_hair == -1 )
		kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
	if( kCharInfo.m_skin_color == -1 )
		kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
	if( kCharInfo.m_hair_color == -1 )
		kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
	if( kCharInfo.m_underwear == -1 )
		kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	

	kCharInfo.m_chExerciseStyle = iExerciseStyle; 

	//Item
	memset( kCharInfo.m_extra_item, 0, sizeof( kCharInfo.m_extra_item ) );

	//캐릭터 기간
	enum { LIMITE_HOUR_EXERCISE_CHAR = 604800, };	
	kCharInfo.m_iLimitSecond = LIMITE_HOUR_EXERCISE_CHAR;

	//용병 슬롯 위치
	kCharInfo.m_iSlotIndex = -1;	
	pCharacter->SetCharInfo( g_ExerciseCharIndexMgr.Pop() , kCharInfo, this );
	pCharacter->BackUp();
	CheckCharSlot( pCharacter );
	int iCharArray = GetCharCount() - 1;	

	g_LogDBClient.OnInsertChar( this, iClassType, 0, 0, "", LogDBClient::CT_PCROOM );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s %d)%s %d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iClassType );

	SP2Packet kPacket( STPK_EXERCISE_EVENT_CHAR_CREATE );
	PACKET_GUARD_VOID( kPacket.Write( EXERCISE_CHAR_CREATE_OK ) );
	PACKET_GUARD_VOID( kPacket.Write( dwCharDeleteIndex ) );
	PACKET_GUARD_VOID( kPacket.Write( iCharArray ) );
	PACKET_GUARD_VOID( kPacket.Write( pCharacter->GetCharIndex() ) );
	PACKET_GUARD_VOID( kPacket.Write( (CHARACTER)pCharacter->GetCharInfo() ) );
	SendMessage( kPacket );

	if( m_pMyRoom )
	{
		m_pMyRoom->OnModeCharInsert( this, pCharacter );
		if( m_pMyRoom->GetModeType() != MT_FIGHT_CLUB )          // 챔피언 모드에서는 선택한 피씨방 용병으로 교체를하지 않는다.
			SetChangeChar( iCharArray, bWait, m_select_char, MAX_INT_VALUE );
	}
	else if( bOneChar ) 
		SetChangeChar( iCharArray, bWait, -1, MAX_INT_VALUE );
}

void User::OnBankruptcyPeso( SP2Packet &rkPacket )
{
	// 파산 캐릭터 지급.( 파산 페소 블럭 )
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Error 0 %s : %s(%d) : %I64d",  __FUNCTION__, GetPublicID().c_str(), GetUserIndex() , GetMoney() );
	return; //-----------------------------------------------------------------------------

	// 파산 페소 지급
	int iCharCnt = 0;
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) )
			continue;
		if( !m_CharList[i]->IsActive() )
			continue;

		iCharCnt++;
	}

	if( iCharCnt > 0 )
	{
		SP2Packet kReturn( STPK_BANKRUPTCY_PESO );
		kReturn << GetMoney();
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Error 1 %s : %s : %I64d",  __FUNCTION__, GetPublicID().c_str() , GetMoney() );
		return;
	}

	if( g_ItemPriceMgr.GetBankruptcyPeso() <= GetMoney() )
	{
		SP2Packet kReturn( STPK_BANKRUPTCY_PESO );
		kReturn << GetMoney();
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Error 2 %s : %s : %I64d",  __FUNCTION__, GetPublicID().c_str() , GetMoney() );
		return;
	}
	
	int iAddMoney = g_ItemPriceMgr.GetBankruptcyPeso() - GetMoney();
	if( COMPARE( iAddMoney, 1, g_ItemPriceMgr.GetBankruptcyPeso() + 1) )
	{
		AddMoney( iAddMoney );
		g_LogDBClient.OnInsertPeso( this, iAddMoney, LogDBClient::PT_BANKRUPT );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_BANKRUPT, 0, 0, iAddMoney, NULL);

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Add bankrupt peso : %d)%s %d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iAddMoney );
	}

	SP2Packet kReturn( STPK_BANKRUPTCY_PESO );
	kReturn << GetMoney();
	SendMessage( kReturn );
}

void User::OnGuildRankList( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_GUILD_RANK_LIST );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnGuildInfo( SP2Packet &rkPacket )
{
	bool bMyGuildOnlyInfo;
	DWORD dwGuildIndex, dwGuildJoinUser;
	rkPacket >> dwGuildIndex >> dwGuildJoinUser >> bMyGuildOnlyInfo;

	if( dwGuildIndex == m_UserGuild.GetGuildIndex() && !bMyGuildOnlyInfo )
		g_DBClient.OnSelectGuildMemberListEx( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwGuildIndex, dwGuildJoinUser, true );

	bool bLoginInfo = false;
	SP2Packet kPacket( MSTPK_GUILD_INFO );
	PACKET_GUARD_VOID( kPacket.Write(bLoginInfo) );
	PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( kPacket.Write(dwGuildIndex) );

	g_MainServer.SendMessage( kPacket );
}

void User::OnGuildUserList( SP2Packet &rkPacket )
{
	DWORD dwGuildIndex, dwGuildJoinUser;
	rkPacket >> dwGuildIndex >> dwGuildJoinUser;

	if( dwGuildIndex == m_UserGuild.GetGuildIndex() )
		g_DBClient.OnSelectGuildMemberListEx( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwGuildIndex, dwGuildJoinUser, true );
	else
		g_DBClient.OnSelectGuildMemberList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwGuildIndex, dwGuildJoinUser );
}

void User::OnGuildJoinerChange( SP2Packet &rkPacket )
{
	DWORD dwGuildIndex, dwGuildMaxUser;
	rkPacket >> dwGuildIndex >> dwGuildMaxUser;

	if( !IsGuild() || dwGuildIndex == 0 )
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "가입된 길드가 없는데 길드 인원 변경 신호를 보냈음!!1 : %s", GetPublicID().c_str() );
	else if( m_UserGuild.GetGuildIndex() != dwGuildIndex )
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "자신의 길드가 아닌데 길드 인원 변경 신호를 보냈음!!2 : %s", GetPublicID().c_str() );
	else if( !m_UserGuild.IsGuildMaster() )
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "길드장이 아닌데 길드 인원 변경 신호를 보냈음!!3 : %s", GetPublicID().c_str() );
	else
	{
		SP2Packet kMainPacket( MSTPK_GUILD_JOINER_CHANGE );
		kMainPacket << GetUserIndex() << dwGuildIndex << dwGuildMaxUser;
		g_MainServer.SendMessage( kMainPacket );
	}	
}

void User::OnGuildEntryApp( SP2Packet &rkPacket )
{
	if( GetEntryType() == ET_TERMINATION )
	{
		SP2Packet kPacket( STPK_GUILD_ENTRY_APP );
		kPacket << ENTRY_GUILD_APP_NONE_FORMALITY;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnGuildEntryApp : 임시가입만료 유저가 길드가입신청 :%s / %d",GetPublicID().c_str(), GetEntryType() );
		return;
	}
	DWORD dwGuildIndex, dwMasterIndex, dwSecondMasterIndex;
	rkPacket >> dwGuildIndex >> dwMasterIndex >> dwSecondMasterIndex;
	if( dwMasterIndex != 0 || dwSecondMasterIndex != 0 )
		g_DBClient.OnSelectGuildEntryApp( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwGuildIndex, dwMasterIndex, dwSecondMasterIndex );
	else
	{
		// 길드장과 부길드장의 인덱스를 요청하고 EnterApp한다.
		//
		g_DBClient.OnSelectGuildEntryAppMasterGet( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwGuildIndex );
	}
}

void User::OnGuildEntryCancel( SP2Packet &rkPacket )
{
	DWORD dwGuildIndex;
	rkPacket >> dwGuildIndex;
	g_DBClient.OnDeleteGuildEntryCancel( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwGuildIndex );
}


void User::OnGuildEntryDelayMember( SP2Packet &rkPacket )
{
	if( IsGuild() )
		g_DBClient.OnSelectGuildEntryDelayMember( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_UserGuild.GetGuildIndex() );
}

void User::OnGuildEntryAgree( SP2Packet &rkPacket )
{
	DWORD dwGuildIndex	= 0, dwEntryUserIndex = 0;
	PACKET_GUARD_VOID(rkPacket.Read(dwGuildIndex));
	PACKET_GUARD_VOID(rkPacket.Read(dwEntryUserIndex));
	
	if( m_UserGuild.GetGuildIndex() != dwGuildIndex ||
		( !m_UserGuild.IsGuildMaster() && !m_UserGuild.IsGuildSecondMaster() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][guild]Incorrect  authority : [%d] [%d] [%d] [%d]", dwGuildIndex,
			m_UserGuild.GetGuildIndex(), (int)m_UserGuild.IsGuildMaster(), (int)m_UserGuild.IsGuildSecondMaster() );

		return;
	}

	SP2Packet kMainPacket( MSTPK_GUILD_ENTRY_AGREE );
	PACKET_GUARD_VOID(kMainPacket.Write(dwGuildIndex));
	PACKET_GUARD_VOID(kMainPacket.Write(GetUserIndex()));
	PACKET_GUARD_VOID(kMainPacket.Write(dwEntryUserIndex));
	g_MainServer.SendMessage(kMainPacket);
	//g_DBClient.OnSelectGuildEntryAgree( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwUserIndex, dwGuildIndex );
}

void User::OnGuildEntryRefuse( SP2Packet &rkPacket )
{
	DWORD dwGuildIndex, dwTableIndex, dwUserIndex;
	rkPacket >> dwGuildIndex >> dwTableIndex >> dwUserIndex;
	if( m_UserGuild.GetGuildIndex() != dwGuildIndex ||
		( !m_UserGuild.IsGuildMaster() && !m_UserGuild.IsGuildSecondMaster() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGuildEntryRefuse 권한이 없는 유저 : %s[%d - %d - %d - %d]", GetPublicID().c_str(), dwGuildIndex,
			                    m_UserGuild.GetGuildIndex(), (int)m_UserGuild.IsGuildMaster(), (int)m_UserGuild.IsGuildSecondMaster() );
		return;
	}
	g_DBClient.OnDeleteGuildEntryRefuse( GetUserDBAgentID(), GetAgentThreadID(), dwTableIndex );

	// 거절 당한 유저에게 전송하여 대기중인 길드 인덱스 제거함
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( dwUserIndex );
	if( pUserParent )
	{
		SP2Packet kPacket( STPK_ENTRY_DELAY_GUILD_DELETE );
		kPacket << dwGuildIndex;
		pUserParent->RelayPacket( kPacket );
	}
}

void User::_OnGuildInvitation( UserParent *pSendUser, DWORD dwGuildIndex, int iGuildMark, const ioHashString szGuildName )
{
	if( !pSendUser ) return;

	if( IsGuild() )
	{
		// 이미 길드 유저 알림
		SP2Packet kPacket( STPK_GUILD_INVITATION );
		kPacket << GUILD_INVITATION_GUILD_USER << GetPublicID();
		pSendUser->RelayPacket( kPacket );
	}
	else
	{
		// 메시지 전송 성공 알림
		SP2Packet kPacket( STPK_GUILD_INVITATION );
		kPacket << GUILD_INVITATION_OK << GetPublicID();
		pSendUser->RelayPacket( kPacket );

		// 유저에게 길드 권유 전송
		SP2Packet kPacket2( STPK_GUILD_INVITED );
		kPacket2 << pSendUser->GetPublicID() << pSendUser->GetGradeLevel() << dwGuildIndex << iGuildMark << szGuildName;
		SendMessage( kPacket2 );
	}
}

void User::OnGuildInvitation( SP2Packet &rkPacket )
{
	if( !IsGuild() )
	{
		// 길드원 아님
		SP2Packet kPacket( STPK_GUILD_INVITATION );
		kPacket << GUILD_INVITATION_EXCEPTION;
		SendMessage( kPacket );
		return;
	}

	ioHashString szUserID;
	rkPacket >> szUserID;
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szUserID );
	if( pUserParent )
	{
		if( pUserParent->IsUserOriginal() )
		{
			User *pUser = (User*)pUserParent;
			pUser->_OnGuildInvitation( this, m_UserGuild.GetGuildIndex(), m_UserGuild.GetGuildMark(), m_UserGuild.GetGuildName() );			
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserParent;

			// 유저가 있는 서버로 전송
			SP2Packet kPacket( SSTPK_GUILD_INVITATION );
			kPacket << GetUserIndex() << pUser->GetUserIndex() << szUserID << m_UserGuild.GetGuildIndex() << m_UserGuild.GetGuildMark() << m_UserGuild.GetGuildName();
			pUser->SendMessage( kPacket );
		}
	}
	else
	{
		// 오프 유저임을 알림
		SP2Packet kPacket( STPK_GUILD_INVITATION );
		kPacket << GUILD_INVITATION_OFFLINE << szUserID;
		SendMessage( kPacket );
	}
}

void User::OnGuildLeave( SP2Packet &rkPacket )
{
	if( !IsGuild() )
	{
		SP2Packet kPacket( STPK_GUILD_LEAVE );
		kPacket << GUILD_LEAVE_NOT_GUILD;
		SendMessage( kPacket );
	}
	else
	{		
		if( m_UserGuild.IsGuildMaster() && m_UserGuild.GetGuildMemberCount() > 1 )
		{
			SP2Packet kPacket( STPK_GUILD_LEAVE );
			kPacket << GUILD_LEAVE_MASTER_USER;
			SendMessage( kPacket );
			return;
		}

		int iLeavePeso;
		rkPacket >> iLeavePeso;
		if( iLeavePeso < 0 )
		{
			HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s PenaltyPeso Hack :%d:%s:%s:%d->10000", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetPrivateID().c_str(), iLeavePeso );
			iLeavePeso = 10000; // 임의의 큰 수
		}
		__int64 iPrevMoney = GetMoney();
		RemoveMoney( iLeavePeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_GUILD_LEAVE, 0, 0, iLeavePeso, NULL);

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnGuildLeave( %s ) : %d - %s - %d: %I64d - > %I64d ", 
								GetPublicID().c_str(), m_UserGuild.GetGuildIndex(), m_UserGuild.GetGuildName().c_str(), iLeavePeso,
								iPrevMoney, GetMoney() );
		SP2Packet kPacket( STPK_GUILD_LEAVE );
		kPacket << GUILD_LEAVE_OK << m_UserGuild.GetGuildIndex() << GetPublicID() << GetMoney();
		SendMessage( kPacket );

		//DB 쿼리 실행
		g_DBClient.OnDeleteGuildLeaveUser( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_UserGuild.GetGuildIndex() );
		
		//메인 서버에 알림
		SP2Packet kMainPacket( MSTPK_GUILD_LEAVE );
		kMainPacket << m_UserGuild.GetGuildIndex();
		g_MainServer.SendMessage( kMainPacket );
		
		//접속중인 길드원에게 알림
		if( m_UserGuild.GetGuildMemberCount() > 1 )
			m_UserGuild.LeaveGuildUserSync();
		m_UserGuild.LeaveGuildInitInfo( true );
	}
}

void User::OnGuildTitleChange( SP2Packet &rkPacket )
{
	if( !IsGuild() || !m_UserGuild.IsGuildMaster() )
		return;

	ioHashString szGuildTitle;
	rkPacket >> szGuildTitle;
	g_DBClient.OnUpdateGuildTitle( GetUserDBAgentID(), GetAgentThreadID(), m_UserGuild.GetGuildIndex(), szGuildTitle );

	SP2Packet kPacket( MSTPK_GUILD_TITLE_CHANGE );
	kPacket << m_UserGuild.GetGuildIndex() << szGuildTitle;
	g_MainServer.SendMessage( kPacket );
}

void User::OnGuildMasterChange( SP2Packet &rkPacket )
{
	if( !IsGuild() || !m_UserGuild.IsGuildMaster() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGuildMasterChange 권한 없음 : %s - %d - %d", GetPublicID().c_str(), m_UserGuild.GetGuildIndex(), (int)m_UserGuild.IsGuildMaster() ); 

		SP2Packet kPacket( STPK_GUILD_MASTER_CHANGE );
		kPacket << GUILD_MASTER_CHANGE_EXCEPTION;
		SendMessage( kPacket );
		return;
	}
	DWORD dwTargetIndex;
	rkPacket >> dwTargetIndex;

	// 타겟 유저가 접속중이면 즉시 처리한다.
	UserParent *pTargetParent = g_UserNodeManager.GetGlobalUserNode( dwTargetIndex );
	if( pTargetParent )
	{
		if( pTargetParent->IsUserOriginal() )
		{
			User *pUser = (User*)pTargetParent;
			ioUserGuild *pUserGuild = pUser->GetUserGuild();
			if( pUserGuild )			
			{
				if( pUserGuild->GetGuildIndex() == m_UserGuild.GetGuildIndex() )        //아직 같은 길드면 길드장 변경
				{
					ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
					if( pLocal )
						pUserGuild->SetGuildPosition( pLocal->GetGuildMasterPostion() );	
					g_DBClient.OnUpdateGuildMasterChange( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTargetIndex, m_UserGuild.GetGuildIndex() );
				}		
				else            //이미 탈퇴한 유저 알림
				{
					SP2Packet kPacket( STPK_GUILD_MASTER_CHANGE );
					kPacket << GUILD_MASTER_CHANGE_LEAVEUSER;
					SendMessage( kPacket );
					return;
				}
			}						
		}
		else                    //타서버 유저면 타서버 유저에게 확인
		{
			UserCopyNode *pUser = (UserCopyNode*)pTargetParent;
			SP2Packet kServerPacket( SSTPK_GUILD_MASTER_CHANGE );
			kServerPacket << GetUserIndex() << pUser->GetUserIndex() << m_UserGuild.GetGuildIndex();
			pUser->SendMessage( kServerPacket );
		}
	}		
	else
	{
		// 접속중이지 않은 유저면 일단 DB 실행 후 확인
		g_DBClient.OnUpdateGuildMasterChange( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTargetIndex, m_UserGuild.GetGuildIndex() );
	}
}

void User::OnGuildPositionChange( SP2Packet &rkPacket )
{
	if( !IsGuild() || !m_UserGuild.IsGuildMaster() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGuildPositionChange 권한 없음 : %s - %d - %d", GetPublicID().c_str(), m_UserGuild.GetGuildIndex(), (int)m_UserGuild.IsGuildMaster() ); 

		SP2Packet kPacket( STPK_GUILD_POSITION_CHANGE );
		kPacket << GUILD_POSITION_CHANGE_EXCEPTION;
		SendMessage( kPacket );
		return;
	}

	ioHashString szTargetID, szGuildPosition;
	DWORD dwTargetIndex;
	rkPacket >> dwTargetIndex >> szTargetID >> szGuildPosition;
	g_DBClient.OnUpdateGuildPositionChange( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTargetIndex, m_UserGuild.GetGuildIndex(), szTargetID, szGuildPosition );
}

void User::OnGuildKickOut( SP2Packet &rkPacket )
{
	if( !IsGuild() || !m_UserGuild.IsGuildMaster() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGuildPositionChange 권한 없음 : %s - %d - %d - %d", GetPublicID().c_str(), m_UserGuild.GetGuildIndex(), (int)m_UserGuild.IsGuildMaster(), (int)m_UserGuild.IsGuildSecondMaster() ); 

		SP2Packet kPacket( STPK_GUILD_KICK_OUT );
		kPacket << GUILD_KICK_OUT_EXCEPTION;
		SendMessage( kPacket );
		return;
	}

	int iKickOutPeso;
	DWORD dwTableIndex, dwUserIndex;
	ioHashString szTargetID;
	rkPacket >> dwTableIndex >> dwUserIndex >> szTargetID >> iKickOutPeso;
	if( iKickOutPeso < 0 )
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s PenaltyPeso Hack :%d:%s:%s:%d->10000", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetPrivateID().c_str(), iKickOutPeso );
		iKickOutPeso = 10000; // 임의의 큰 수
	}

	// 타겟 유저가 접속중이면 타겟 유저가 처리한다.
	UserParent *pTargetParent = g_UserNodeManager.GetGlobalUserNode( szTargetID );
	if( pTargetParent )
	{
		if( pTargetParent->IsUserOriginal() )
		{
			User *pUser = (User*)pTargetParent;
			ioUserGuild *pUserGuild = pUser->GetUserGuild();
			if( pUserGuild )			
			{
				if( pUserGuild->GetGuildIndex() == m_UserGuild.GetGuildIndex() )        //아직 같은 길드면 길드장 변경
				{
					// DB 실행 강제 탈퇴가 아닌 탈퇴 쿼리 실행
					g_DBClient.OnDeleteGuildLeaveUser( GetUserDBAgentID(), GetAgentThreadID(), pUser->GetUserIndex(), pUserGuild->GetGuildIndex() );

					// 메인 서버에 알림
					SP2Packet kMainPacket( MSTPK_GUILD_LEAVE );
					kMainPacket << m_UserGuild.GetGuildIndex();
					g_MainServer.SendMessage( kMainPacket );

					SP2Packet kPacket( STPK_GUILD_KICK_OUT );
					kPacket << GUILD_KICK_OUT_OK << m_UserGuild.GetGuildIndex() << szTargetID << false;
					pUser->SendMessage( kPacket );

					// 길드 정보 초기화
					pUserGuild->LeaveGuildInitInfo( true );
				}		
				else            
				{
					SP2Packet kPacket( STPK_GUILD_KICK_OUT );
					kPacket << GUILD_KICK_OUT_LEAVEUSER;
					SendMessage( kPacket );
					return;
				}
			}						
		}
		else                    //타서버 유저면 타서버 유저에게 확인
		{
			UserCopyNode *pUser = (UserCopyNode*)pTargetParent;
			SP2Packet kServerPacket( SSTPK_GUILD_KICK_OUT );
			kServerPacket << pUser->GetUserIndex() << GetUserIndex() << m_UserGuild.GetGuildIndex();
			pUser->SendMessage( kServerPacket );
		}

		__int64 iPrevMoney = GetMoney();
		RemoveMoney( iKickOutPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_GUILD_KICKOUT, 0, 0, iKickOutPeso, NULL);

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnGuildKickOut( %s ) : %s - %d: %I64d - > %I64d ", 
								GetPublicID().c_str(), szTargetID.c_str(), iKickOutPeso, iPrevMoney, GetMoney() );

		SP2Packet kPacket( STPK_GUILD_KICK_OUT );
		kPacket << GUILD_KICK_OUT_OK << m_UserGuild.GetGuildIndex() << szTargetID << true << GetMoney();
		SendMessage( kPacket );

		m_UserGuild.DeleteGuildUser( szTargetID );
		m_UserGuild.KickOutGuildUserSync( szTargetID );
	}
	else // 로그 아웃 상태면 DB에 직접 강퇴
	{
		// DB 실행
		g_DBClient.OnDeleteGuildKickOut( GetUserDBAgentID(), GetAgentThreadID(), dwTableIndex, m_UserGuild.GetGuildIndex() );

		//메인 서버에 알림
		SP2Packet kMainPacket( MSTPK_GUILD_LEAVE );
		kMainPacket << m_UserGuild.GetGuildIndex();
		g_MainServer.SendMessage( kMainPacket );

		__int64 iPrevMoney = GetMoney();
		RemoveMoney( iKickOutPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_GUILD_KICKOUT, 0, 0, iKickOutPeso, NULL);

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnGuildKickOut( %s ) : %s - %d: %I64d - > %I64d ", 
								GetPublicID().c_str(), szTargetID.c_str(), iKickOutPeso, iPrevMoney, GetMoney() );

		//유저에게 알림
		SP2Packet kPacket( STPK_GUILD_KICK_OUT );
		kPacket << GUILD_KICK_OUT_OK << m_UserGuild.GetGuildIndex() << szTargetID << true << GetMoney();
		SendMessage( kPacket );

		m_UserGuild.DeleteGuildUser( szTargetID );
		m_UserGuild.KickOutGuildUserSync( szTargetID );
	}
}

void User::_OnGuildMarkChange( DWORD dwGuildIndex, DWORD dwGuildMark, bool bBlock )
{
	if( m_UserGuild.GetGuildIndex() != dwGuildIndex ) return;

	m_UserGuild.SetGuildMark( dwGuildMark );

	SP2Packet kPacket( STPK_GUILD_MARK_CHANGE );
	kPacket << GUILD_MARK_CHANGE_OK << m_UserGuild.GetGuildIndex() << m_UserGuild.GetGuildMark() << GetMoney() << bBlock;
	SendMessage( kPacket );
	SyncUserGuild();                           // 타 서버에 길드 마크 변경 알림

	// 길드 마크가 변경되면 래더팀에 알림
	LadderTeamMyInfo();
}

void User::OnGuildChat( SP2Packet &rkPacket )
{
	ioHashString szChat;
	DWORD dwGuildIndex;
	rkPacket >> dwGuildIndex >> szChat;

	if( m_UserGuild.GetGuildIndex() == dwGuildIndex )
	{
		SP2Packet kPacket( STPK_GUILD_CHAT );
		kPacket << dwGuildIndex << GetPublicID() << szChat;
		m_UserGuild.SendRelayPacketTcp( kPacket );
	}
}

void User::OnGuildMarkChangeKeyValue( SP2Packet &rkPacket )
{
	DeleteGuildMarkChangeKeyValue();

	if( !IsGuild() )
	{
		SP2Packet kPacket( STPK_GUILD_MARK_CHANGE );
		kPacket << GUILD_MARK_CHANGE_NOT_GUILD;
		SendMessage( kPacket );
		return;
	}
	else if( !m_UserGuild.IsGuildMaster() && !m_UserGuild.IsGuildSecondMaster() )
	{
		SP2Packet kPacket( STPK_GUILD_MARK_CHANGE );
		kPacket << GUILD_MARK_CHANGE_NOT_MASTER;
		SendMessage( kPacket );
		return;
	}
	
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_GUILD_MARK_CHANGE, kSlot );
	if( kSlot.m_iType <= 0 || kSlot.m_iValue1 <= 0 )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		kReturn << ETCITEM_USE_DONT_HAVE;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGuildMarkChangeKeyValue Fail - %s) %d don't have value.",  GetPublicID().c_str(), ioEtcItem::EIT_ETC_GUILD_MARK_CHANGE );
		return;
	}

	DWORD dwNewGuildMark;
	rkPacket >> dwNewGuildMark;
	g_DBClient.OnInsertGuildMarkChangeKeyValue( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_UserGuild.GetGuildIndex(), GetMoney(), Help::GetChangeGuildMarkPeso(), m_UserGuild.GetGuildMark(), dwNewGuildMark );
}

void User::OnGuildMarkChangeKeyValueDelete( SP2Packet &rkPacket )
{
	DeleteGuildMarkChangeKeyValue();
}

void User::OnGuildTitleSync( SP2Packet &rkPacket )
{
	DWORD dwGuildIndex;
	rkPacket >> dwGuildIndex;
	
	if( dwGuildIndex == 0 ) return;

	SP2Packet kPacket( MSTPK_GUILD_TITLE_SYNC );
	kPacket << GetUserIndex() << dwGuildIndex;
	g_MainServer.SendMessage( kPacket );
}

void User::OnGuildExist( SP2Packet &rkPacket )
{
	ioHashString szGuildName;
	rkPacket >> szGuildName;

	if( !g_App.IsRightID( szGuildName.c_str() ) )
	{
		SP2Packet kPacket( STPK_GUILD_EXIST );
		kPacket << false;
		SendMessage( kPacket );
		return;
	}

	SP2Packet kPacket( MSTPK_GUILD_EXIST );
	kPacket << GetUserIndex() << szGuildName;
	g_MainServer.SendMessage( kPacket );
}

void User::OnUserEntryRefresh( SP2Packet &rkPacket )
{
	CRASH_GUARD();
	ioHashString szID;
	rkPacket >> szID;

	if( GetPublicID() == szID )
		g_DBClient.OnSelectUserEntry( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), szID , GetUserIndex() );
}

void User::OnFirstChangeID( SP2Packet &rkPacket )
{
	ioHashString szNewPublicID;
	rkPacket >> szNewPublicID;

	if( m_bFirstChangeID )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		kPacket << FIRST_CHANGE_ID_NOW_WORKING;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] Now working", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	char szTempPublicID[ID_NUM_PLUS_ONE]="";
	StringCbPrintf( szTempPublicID , sizeof( szTempPublicID ), "_%s#", GetPrivateID().c_str() );

	if( GetPublicID() != szTempPublicID )
	{
		StringCbPrintf( szTempPublicID , sizeof( szTempPublicID ), "%s#", GetPrivateID().c_str() );
		if( GetPublicID() != szTempPublicID )
		{
			SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
			kPacket << FIRST_CHANGE_ID_EXCEPTION;
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] wrong temp public id",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
			return;
		}		
	}

	if( m_user_data.m_user_state != 0 )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		kPacket << FIRST_CHANGE_ID_EXCEPTION;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] wrong user state :%d",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), m_user_data.m_user_state );
		return;
	}

	if( szNewPublicID.IsEmpty() )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		kPacket << FIRST_CHANGE_ID_EXCEPTION;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] Empty ID",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	if( !g_WordFilter.CheckSpecialLetters(szNewPublicID.c_str(), szNewPublicID.Length()) )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		PACKET_GUARD_VOID( kPacket.Write(FIRST_CHANGE_ID_WRONG_ID) );
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] Wrong ID 1 (%s)",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), szNewPublicID.c_str() );
		return;
	}

	if( !g_App.IsRightFirstID( szNewPublicID.c_str() ) )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		kPacket << FIRST_CHANGE_ID_WRONG_ID;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] Wrong ID 1 (%s)",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), szNewPublicID.c_str() );
		return;
	}

	if( g_App.IsNotMakeID( szNewPublicID.c_str() ) )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		kPacket << FIRST_CHANGE_ID_WRONG_ID;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] Wrong ID 2 (%s)",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), szNewPublicID.c_str() );
		return;
	}

	if( g_UserNodeManager.IsDeveloper( szNewPublicID.c_str() ) )
	{
		SP2Packet kPacket( STPK_FIRST_CHANGE_ID );
		kPacket << FIRST_CHANGE_ID_WRONG_ID;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error [%d:%s] Wrong ID 3 (%s)",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), szNewPublicID.c_str() );
		return;
	}

	m_bFirstChangeID = true;
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s First Public ID Success - 1 [%d:%s]",  __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
	g_DBClient.OnSelectFirstPublicIDExist( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetGUID(), szNewPublicID );
}


ioItem* User::ReleaseItem( int iSlot )
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ReleaseItem( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return NULL;
	}
	return m_CharList[m_select_char]->ReleaseItem( iSlot );
}

bool User::IsSlotEquiped( int iSlot ) const
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::IsSlotEquiped( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return false;
	}
	return m_CharList[m_select_char]->IsSlotEquiped( iSlot );
}

bool User::IsEquipedItem()
{
	for( int i=0; i < 4; i++ )
	{
		if( IsSlotEquiped( i ) )
			return true;
	}

	return false;
}

const ioItem* User::GetItem( int iSlot ) const
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::GetItem( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return NULL;
	}

	return m_CharList[m_select_char]->GetItem( iSlot );
}

const int User::GetEquipItemCount()
{
	int iReturn = 0;
	for(int i = 0;i < MAX_CHAR_DBITEM_SLOT;i++)
	{
		if( GetItem( i ) )
			iReturn++;
	}
	return iReturn;
}

void User::InitCharDie()
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		m_CharList[i]->SetCharDie( false );
	}
}

void User::SetCharDie( bool bCharDie )
{
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::SetCharDie( %s ) : %d >= %d", GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	m_CharList[m_select_char]->SetCharDie( bCharDie );
}

ioHashString * User::GetEncLoginKey() const
{
	if(m_pEncLoginKey)
		return m_pEncLoginKey;
	else
		return NULL;
}

void User::ClearEncLoginKey()
{
	SAFEDELETE(m_pEncLoginKey);
}

void User::SetStartTimeLog( DWORD dwStartTimeLog )
{
	m_dwStartTimeLog = dwStartTimeLog;
}

DWORD User::GetStartTimeLog()
{
	return m_dwStartTimeLog;
}

bool User::CheckPreRoomNum( ModeType eModeType )
{
	if( m_pMyRoom && m_pMyRoom->GetModeType() == MT_TRAINING )
	{
		if( eModeType != MT_TRAINING )
		{
			m_PreRoomNum = m_pMyRoom->GetRoomNumber();
		}
		return true;
	}

	return false;
}

void User::ClearPreRoomNum()
{
	m_PreRoomNum = -1;
}

void User::OnAbuseQuizStart( SP2Packet &rkPacket )
{
#ifdef _LSWC
	return; //대회 퀴즈 스킵
#endif
	if( g_UserNodeManager.IsDeveloper( GetPublicID().c_str() )) //개발자 계정은 퀴즈 스킵
		return;

	if( m_pMyRoom && m_dwAbuseQuizLimitTime == 0 )
	{
		int iAbuseType;
		rkPacket >> iAbuseType;

		m_AbuseQuiz = HackCheck::GenerateProblem( HackCheck::HT_ABUSE );
		m_dwAbuseQuizLimitTime  = TIMEGETTIME() + HackCheck::ServerAnswerTime( HackCheck::HT_ABUSE );
		m_iCurAbuseAnswerChance = 0;

		SP2Packet kPacket( STPK_ABUSE_ANNOUNCE );
		kPacket << iAbuseType;
		kPacket << HackCheck::MaxAnswerChance( HackCheck::HT_ABUSE );
		kPacket << HackCheck::ClientAnswerTime( HackCheck::HT_ABUSE );
		kPacket << m_AbuseQuiz.m_iFirstOperand;
		kPacket << m_AbuseQuiz.m_iSecondOperand;
		kPacket << (int)m_AbuseQuiz.m_Operator;
		SendMessage( kPacket );
	}
}

void User::OnAbuseQuiz( SP2Packet &rkPacket )
{
	if( m_dwAbuseQuizLimitTime == 0 )
	{
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAbuseQuiz - %s Not Quiz User", GetPublicID().c_str() );
		return;
	}

	int iType;
	rkPacket >> iType;

	if( iType == ID_QUIZ_ANSWER )
	{
		int iRecvAnswer = -999999;
		rkPacket >> iRecvAnswer;

		int iServerAnswer = HackCheck::SolveProblem( m_AbuseQuiz );
		if( iRecvAnswer == iServerAnswer )
		{
			m_dwAbuseQuizLimitTime  = 0;
			m_iCurAbuseAnswerChance = 0;
			HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ABUSE : %s Answer OK", GetPublicID().c_str() );

			SP2Packet kReturn( STPK_ABUSE_QUIZ );
			kReturn << ID_QUIZ_OK;
			SendMessage( kReturn );
		}
		else
		{
			if( m_iCurAbuseAnswerChance + 1 >= HackCheck::MaxAnswerChance( HackCheck::HT_ABUSE ) )
			{
				m_dwAbuseQuizLimitTime  = 0;
				m_iCurAbuseAnswerChance = 0;
				HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ABUSE : %s Kicked", GetPublicID().c_str() );

				SP2Packet kReturn( STPK_ABUSE_QUIZ );
				kReturn << ID_QUIZ_KICK;
				kReturn << iRecvAnswer;
				SendMessage( kReturn );
			}
			else
			{
				m_iCurAbuseAnswerChance++;
				HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ABUSE : %s Retry(%d)", GetPublicID().c_str(), m_iCurAbuseAnswerChance );

				SP2Packet kReturn( STPK_ABUSE_QUIZ );
				kReturn << ID_QUIZ_RETRY;
				kReturn << iRecvAnswer;

				kReturn << m_iCurAbuseAnswerChance;

				m_AbuseQuiz = HackCheck::GenerateProblem( HackCheck::HT_ABUSE );
				kReturn << m_AbuseQuiz.m_iFirstOperand;
				kReturn << m_AbuseQuiz.m_iSecondOperand;
				kReturn << m_AbuseQuiz.m_Operator;
				SendMessage( kReturn );
			}
		}
	}
	else if( iType == ID_QUIZ_TIMEOVER )
	{
		m_dwAbuseQuizLimitTime  = 0;
		m_iCurAbuseAnswerChance = 0;
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "ABUSE : %s Client Answer Time Over", GetPublicID().c_str() );
	}
	else
	{
		m_dwAbuseQuizLimitTime  = 0;
		m_iCurAbuseAnswerChance = 0;
		HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAbuseQuiz - %s Unknown Type(%d)", GetPublicID().c_str(), iType );
	}
}

bool User::SetChangeChar( int iCharArray, bool bWait, int iSelectCharArray, DWORD dwCharChangeIndex )
{
	if( !m_pMyRoom ) return false;

	if( !m_pMyRoom->IsEnableState( this ) )
		return false;
	
	if( m_pMyRoom->OnModeChangeChar( this, iCharArray, bWait, iSelectCharArray, dwCharChangeIndex ) )
		return true;

	
	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ChangeChar - %s Char Overflow(%d)", GetPublicID().c_str(), iCharArray );
		return false;
	}

	if( bWait || m_pMyRoom )
		EquipDBItemToAllChar();

	m_select_char = iCharArray;
	
	//캐릭터 정보 전송.
	SP2Packet kPacket( STPK_CHANGE_CHAR );
	PACKET_GUARD_bool( kPacket.Write(GetPublicID()) );

	if( m_pMyRoom && m_pMyRoom->IsRoundEndState() )
	{
		PACKET_GUARD_bool( kPacket.Write(CHANGE_CHAR_FAIL) );
	}
	else
	{
		PACKET_GUARD_bool( kPacket.Write(CHANGE_CHAR_OK) );
		PACKET_GUARD_bool( kPacket.Write(GetCountRSoldier()) );
		PACKET_GUARD_bool( kPacket.Write(GetCountOfSpecialSoldier(SST_GFRIEND)) );
		PACKET_GUARD_bool( kPacket.Write(bWait) );
		PACKET_GUARD_bool( kPacket.Write(dwCharChangeIndex) );

		FillChangeCharData( kPacket );
		FillEquipMedalItem( kPacket );
		FillGrowthLevelData( kPacket );
		
		//장착 중인 칭호 정보 GET
		if( !FillEquipTitleData(kPacket) )
		{
			PACKET_GUARD_bool( kPacket.Write(GetPublicID()) );
			PACKET_GUARD_bool( kPacket.Write(0) );
			PACKET_GUARD_bool( kPacket.Write((BYTE)0) );
			PACKET_GUARD_bool( kPacket.Write(0) );
		}

		int iClassType = 0;
		ioCharacter *rkChar = m_CharList[m_select_char];
		if( rkChar )
		{	
			iClassType = rkChar->GetCharInfo().m_class_type;
#ifdef SRC_NA
			if( 0 < Help::GetLimitHeroNumber() && Help::GetLimitHeroNumber() < iClassType )
			{
				LOG.PrintTimeAndLog( 0 , "%s - ID : %s, LimitHerUse: %d", __FUNCTION__, GetPublicID().c_str(), iClassType );
				g_LogDBClient.OnInsertGameLogInfo( 40001, this, 0, iClassType, LogDBClient::OVS_CAHNGE_CHAR, 0, 0, 0, 0, NULL );
			}
#endif
		}
		FillExMedalSlotByClassType( iClassType, kPacket );

		if( !bWait && m_pMyRoom->GetPlazaModeType() == PT_COMMUNITY )
		{
			m_pMyRoom->SetChatModeState( GetPublicID(), true );
		}
	}


	if( m_pMyRoom )
	{
		// 이전에 선택한 용병이 없으면
		int iPrevCharType = GetCharClassType( iSelectCharArray );
		if( iPrevCharType == 0 )
			iPrevCharType = GetCharClassType( m_select_char );
		m_pMyRoom->NotifyChangeCharToMode( this, iCharArray, iPrevCharType );

		m_pMyRoom->RoomSendPacketTcpSenderLast( kPacket, this );

		//팻 정보 전송
		/*SP2Packet kJoinUserPetPk( STPK_PET_EQUIP_INFO );
		if( FillEquipPetData( kJoinUserPetPk ) )
		{
			m_pMyRoom->RoomSendPacketTcp( kJoinUserPetPk );
		}*/
	}
	else
	{
		SendMessage( kPacket );
	}

	return true;
}

int User::_OnEtcItemMaxCheck( ioEtcItem* pEtcItem, ioUserEtcItem::ETCITEMSLOT &kEtcItemSlot, int iServerValue, bool bMortmain )
{
	if( !pEtcItem )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck None Item - %s(%d)",GetPublicID().c_str(), GetUserIndex() );
		return ETCITEM_BUY_EXCEPTION;
	}

	int iReturnValue = ETCITEM_BUY_OK;
	// max check
	if( pEtcItem->GetMaxUse() != 0 ) // 특별한 max 체크 
	{
		if( !pEtcItem->IsBuyCondition( kEtcItemSlot.GetUse() ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess max use - Not Zero - %s(%d) : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType() );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
	}
	else if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_ITEM_TIME_GASHAPON1, ioEtcItem::EIT_ETC_ITEM_TIME_GASHAPON100 + 1 ) ||
			 COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_ITEM_TIME_GASHAPON101, ioEtcItem::EIT_ETC_ITEM_TIME_GASHAPON300 + 1 ) || 
			 COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_ITEM_TIME_GASHAPON301, ioEtcItem::EIT_ETC_ITEM_TIME_GASHAPON600 + 1 ) ||
		     COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_ADD_CASH001, ioEtcItem::EIT_ETC_ADD_CASH100 + 1 ) )
	{
		if( pEtcItem->GetType() == kEtcItemSlot.m_iType )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess Already Item - %s(%d) : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType() );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_CHAR_SLOT_EXTEND ) // 용병슬롯 over 체크
	{
		int iNewCnt = m_iCurMaxCharSlot + iServerValue;
		if( iNewCnt > m_iLimiteMaxCharSlot )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess over use - %s(%d) : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType() );
			iReturnValue = ETCITEM_BUY_EXCESS_OVER;
		}
	}
	else if( pEtcItem->GetUseType() == ioEtcItem::UT_COUNT )
	{
		int iBuyValue1 = kEtcItemSlot.m_iValue1 + iServerValue;
		if( iBuyValue1 > ioEtcItem::MAX_COUNT )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess max - ioEtcItem::UT_COUNT - %s(%d) : %d : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType(), iBuyValue1 );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
	}
	else if( pEtcItem->GetUseType() == ioEtcItem::UT_TIME )
	{
		int iBuyValue1 = kEtcItemSlot.m_iValue1 + iServerValue;
		if( iBuyValue1 > ioEtcItem::MAX_TIME )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess max - ioEtcItem::UT_TIME - %s(%d) : %d : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType(), iBuyValue1 );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
	}
	else if( pEtcItem->GetUseType() == ioEtcItem::UT_ONCE      || 
			 pEtcItem->GetUseType() == ioEtcItem::UT_ETERNITY )
	{
		if( kEtcItemSlot.m_iValue1 != 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess max - ioEtcItem::UT_ONCE - %s(%d) : %d : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType(), kEtcItemSlot.m_iValue1 );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
	}
	else if( pEtcItem->GetUseType() == ioEtcItem::UT_DATE )
	{
		if( kEtcItemSlot.m_iType == ioEtcItem::EIT_ETC_SOLDIER_EXP_BONUS )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess EIT_ETC_SOLDIER_EXP_BONUS - %s(%d) : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType() );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
		else if( bMortmain )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess mortain - %s(%d) : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType() );
			iReturnValue = ETCITEM_BUY_EXCESS_MAX;
		}
		else
		{
			CTime kLimiteTime( Help::GetSafeValueForCTimeConstructor( kEtcItemSlot.GetYear(), kEtcItemSlot.GetMonth(), kEtcItemSlot.GetDay(), kEtcItemSlot.GetHour(), kEtcItemSlot.GetMinute(), 0 ) );
			CTimeSpan	kAddTime(iServerValue, 0, 0, 0);
			kLimiteTime += kAddTime;

			if( kLimiteTime.GetDay() >= ioEtcItem::MAX_DAY )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Excess max - ioEtcItem::MAX_DAY - %s(%d) : %d : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType(), kLimiteTime.GetDay() );
				iReturnValue = ETCITEM_BUY_EXCESS_MAX;
			}
		}
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnEtcItemMaxCheck Error UseType - %s(%d) : %d",GetPublicID().c_str(), GetUserIndex(), pEtcItem->GetType() );
		iReturnValue = ETCITEM_BUY_EXCEPTION;
	}

	return iReturnValue;
}

DWORD User::_OnEtcItemSetting( ioEtcItem* pEtcItem, ioUserEtcItem::ETCITEMSLOT &kEtcItemSlot, int iServerValue, bool bMortmain )
{
	if( !pEtcItem )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s _OnEtcItemSetting Item None", GetPublicID().c_str() );
		return 0;
	}

	DWORD dwCompensation = 0;

	kEtcItemSlot.m_iType = pEtcItem->GetType();  
	// data add
	if( kEtcItemSlot.GetUseType() == ioEtcItem::UT_COUNT ||
		kEtcItemSlot.GetUseType() == ioEtcItem::UT_TIME  ||
		kEtcItemSlot.GetUseType() == ioEtcItem::UT_ONCE  ||
		kEtcItemSlot.GetUseType() == ioEtcItem::UT_ETERNITY )
	{
		kEtcItemSlot.AddUse( iServerValue );
	}
	else if( kEtcItemSlot.GetUseType() == ioEtcItem::UT_DATE )
	{
		if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_TIME_CASH )
		{
			//한달 지급. 캐쉬 박스.
			if( kEtcItemSlot.m_iValue1 == 0 && kEtcItemSlot.m_iValue2 == 0 ) // NEW
			{
				CTime kLimitTime = CTime::GetCurrentTime();

				DWORD dwStandardTime = g_TimeCashMgr.GetStandardDate(kLimitTime.GetTime());
				CTime kStandarTime(dwStandardTime);

				CTimeSpan	kAddTime( iServerValue, 0, 0, 0 );
				kStandarTime += kAddTime;
				kEtcItemSlot.SetDate( kStandarTime.GetYear(), kStandarTime.GetMonth(), kStandarTime.GetDay(), kStandarTime.GetHour(), kStandarTime.GetMinute() );
			}
		}
		else if( bMortmain )
		{
			if( kEtcItemSlot.m_iValue1 != 0 && kEtcItemSlot.m_iValue2 != 0 ) // Exist
			{
				CTime kLimiteTime( Help::GetSafeValueForCTimeConstructor( kEtcItemSlot.GetYear(), kEtcItemSlot.GetMonth(), kEtcItemSlot.GetDay(), kEtcItemSlot.GetHour(), kEtcItemSlot.GetMinute(), 0 ) );
				CTimeSpan   kRemainTime = kLimiteTime - CTime::GetCurrentTime();

				if( kRemainTime.GetTotalMinutes() > 0 )
				{
					int iSellPeso = pEtcItem->GetSellPeso();
					float fMinSellPeso = (float)iSellPeso / 1440;

					dwCompensation = (DWORD)(fMinSellPeso * kRemainTime.GetTotalMinutes() );
				}
			}

			kEtcItemSlot.m_iValue1 = 0;
			kEtcItemSlot.m_iValue2 = 0;
		}
		else
		{
			if( kEtcItemSlot.m_iValue1 == 0 && kEtcItemSlot.m_iValue2 == 0 ) // NEW
			{
				CTime kLimiteTime = CTime::GetCurrentTime();
				CTimeSpan	kAddTime( iServerValue, 0, 0, 0 );
				kLimiteTime += kAddTime;
				kEtcItemSlot.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );
			}
			else
			{
				CTime kLimiteTime( Help::GetSafeValueForCTimeConstructor( kEtcItemSlot.GetYear(), kEtcItemSlot.GetMonth(), kEtcItemSlot.GetDay(), kEtcItemSlot.GetHour(), kEtcItemSlot.GetMinute(), 0 ) );
				CTimeSpan   kRemainTime = kLimiteTime - CTime::GetCurrentTime();
				if( kRemainTime.GetTotalMinutes() <= 0 )
					kLimiteTime = CTime::GetCurrentTime();
				CTimeSpan	kAddTime( iServerValue, 0, 0, 0 );
				kLimiteTime += kAddTime;
				kEtcItemSlot.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );
			}
		}
	}
	// each type setting
	pEtcItem->OnBuy( this, kEtcItemSlot );

	return dwCompensation;
}

void User::OnEtcItemBuy( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnEtcItemBuy Billing Wait %s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_BILLING_WAIT) );
		SendMessage( kReturn );
		return;
	}


	DWORD dwType	= 0;
	int   iArray	= 0;
	bool  bCash		= true;
	bool bBonusCash = false;
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	PACKET_GUARD_VOID( rkPacket.Read(dwType) );
	PACKET_GUARD_VOID( rkPacket.Read(iArray) );
	PACKET_GUARD_VOID( rkPacket.Read(bCash) );

	if( !g_SaleMgr.IsSelling( ioSaleManager::IT_ETC, dwType, iArray) )
	{
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_ITEM_DATE_CLOSE) ); //구매 가능기간이 지난 상품입니다.

		SendMessage( kReturn );
		LOG.PrintTimeAndLog( 0, "%s - Is not possible selling date. | ItemCode(%d) SubType(%d)", __FUNCTION__, dwType, iArray );

#ifdef ANTIHACK
		CheatUser.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Etcitem buy Cheating User :%d:%s:%s", 
			GetUserIndex(), GetPublicID().c_str(), GetPrivateID().c_str() );
#endif
		return;
	}

	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem(dwType);
	if(!pEtcItem)
	{
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Fail - NULL -%s : %d", GetPublicID().c_str(), dwType );
		return;
	}

	if( !g_EtcItemMgr.IsRightClass( dwType ) )
	{
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Error Class Type %s : %d",  GetPublicID().c_str(), dwType );
		return;
	}

	int iServerValue = pEtcItem->GetValue( iArray );
	if( !g_EtcItemMgr.IsBlockEtcItem( dwType ) && iServerValue <= 0 ) // block 아이템은 값이 0일때 영구
	{
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Value Wrong %s(%d) : %d",  GetPublicID().c_str(), GetUserIndex(), iArray );
		return;
	}

	// max check

	// 이미 존재하는 아이템이면 시간 갱신
	if( dwType != 0 )
		UpdateEtcItemTime(  __FUNCTION__ , dwType );
	
	ioUserEtcItem::ETCITEMSLOT kEtcItemSlot;
	bool bExist = m_UserEtcItem.GetEtcItem( dwType, kEtcItemSlot );

	bool bExistMortmain = false;
	if( bExist &&
		g_EtcItemMgr.IsBlockEtcItem( dwType ) &&
		kEtcItemSlot.m_iValue1 == 0 &&
		kEtcItemSlot.m_iValue2 == 0 )
	{
		bExistMortmain = true;
	}

	int iMaxCheckResult = _OnEtcItemMaxCheck( pEtcItem, kEtcItemSlot, iServerValue, bExistMortmain );
	if( iMaxCheckResult != ETCITEM_BUY_OK )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(iMaxCheckResult) );
		SendMessage( kPacket );	
		return;
	}	

	if( bExist && pEtcItem->GetType() == ioEtcItem::EIT_ETC_TIME_CASH )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCESS_MAX) );
		SendMessage( kPacket );	
		return;
	}

	if( pEtcItem->IsSpecialGoods() )
	{
		//특별물품 구매는 수량, 유저별 한도가 있어서 메인서버를 통한 후 골드 처리.
		SpecialGoodsBuy(dwType);
		return;
	}

	if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_1000 + 1 ) )
	{
		if( !IsGuild() )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_NOT_GUILD_USER) );
			SendMessage( kPacket );	
			return;
		}

		if( !m_UserGuild.IsActiveGuildRoom() )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_GUILD_ROOM_DISABLE) );
			SendMessage( kPacket );	
			return;
		}

		DWORD dwBlockCode	= pEtcItem->GetProperty();
		
		if( !g_BlockPropertyMgr.IsValidItemCode(dwBlockCode) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][block]block item buy fail, Invalid block itemcode : [%d] [%d]", GetUserIndex(), dwBlockCode);
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			return;
		}
	}
	else if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_HOUSING_BLOCK_1000 + 1 ) )
	{
		// 개인 본부 오픈 etc 아이템 있는지 확인.
		if( !m_UserEtcItem.HaveAThisItem(ioEtcItem::EIT_ETC_CREATE_HOME) )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_PERSONAL_HQ_DISABLE) );
			SendMessage( kPacket );	
			return;
		}

		DWORD dwBlockCode	= pEtcItem->GetProperty();
		
		if( !g_BlockPropertyMgr.IsValidItemCode(dwBlockCode) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][block]block item buy fail, Invalid block itemcode : [%d] [%d]", GetUserIndex(), dwBlockCode);
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			return;
		}
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_TIME_CASH )
	{
		//아이오 유저만 가능.
		if( GetChannelingType() != CNT_WEMADEBUY )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_PERSONAL_HQ_DISABLE) );
			SendMessage( kPacket );
			return;
		}
	}

	// 캐쉬 처리
	int iBuyCash = 0;
	if( bCash )
	{
		//HRYOON BONUS CASH 사용 가능 여부 파악
		//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		if( GetEntryType() == ET_TERMINATION )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Cash Entry Type Error - %s : %d",GetPublicID().c_str(), GetEntryType() );
			return;
		}

		iBuyCash = pEtcItem->GetCash( iArray );
		if( iBuyCash <= 0 )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Cash Price Error - %s(%d) : %d : %d : %d", GetPublicID().c_str(), GetUserIndex(), iBuyCash, dwType, iArray );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy pNode == NULL. : %d:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_BILLING_FAIL) );
			SendMessage( kReturn );
			return;
		}

		int iItemPrice	= iBuyCash;

		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_ETCITEM_BUY, ETCITEM_BUY_BILLING_WANT_OF_CASH, dwType, vConsumeInfo ) )
			return;

		int iSize	= vConsumeInfo.size();

		int iSpendBonusCash	= 0;
		for( int i = 0; i < iSize; i++ )
			iSpendBonusCash += vConsumeInfo[i].value2;

		//보너스 캐쉬로 구매 가능 
		if( iSpendBonusCash >= iItemPrice )
			bBonusCash = true;

		if( iItemPrice != iSpendBonusCash )
		{
			
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;
			SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
			kBillingPacket << (int) GetChannelingType();
			kBillingPacket << m_szBillingGUID;
			kBillingPacket << iItemPrice;
			kBillingPacket << GetUserIndex();
			kBillingPacket << GetPublicID();
			kBillingPacket << GetPrivateID();
			kBillingPacket << GetPublicIP();
			kBillingPacket << iBuyCash;

			PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
			for( int i = 0; i < iSize; i++ )
			{
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
			}

			kBillingPacket << OUTPUT_CASH_ETC;
			kBillingPacket << dwType;
			kBillingPacket << iArray;

			if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_ETCITEM_BUY, ETCITEM_BUY_BILLING_FAIL, NULL, NULL ) )
				return;

			ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
			if( pLocal )
				pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

			if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Cash Send Fail : %s(%d):%s:%d", GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
				SP2Packet kReturn( STPK_ETCITEM_BUY );
				PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_BILLING_DISCONNECT) );
				SendMessage( kReturn );
				m_szBillingGUID.Clear();
			}
			else
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemBuy Cash Send : %s(%d):%s:%d", GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			return;
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnEtcItemBuy Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]User::OnEtcItemBuy Cash Send : %s(%d):%s:%d", GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
		}
		return;
	}

	int iPeso = pEtcItem->GetPeso( iArray );

	
	if( !bBonusCash )
	{
		if( iPeso <= 0 )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Peso price Error - %s(%d) :%d",GetPublicID().c_str(), GetUserIndex(), iPeso );
			return;
		}

		if( GetMoney() < iPeso )
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_OUT_OF_MONEY) );
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy out of money - %s(%d) %I64d:%d",GetPublicID().c_str(), GetUserIndex(), GetMoney(), iPeso );
			return;
		}
	}
	
	

	if( !bCash && !bBonusCash  )
	{
		
		RemoveMoney( iPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_ETCITEM, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, iPeso, NULL);
	}
	else if( bCash && bBonusCash )
	{
		if(m_szBillingGUID.IsEmpty())
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;
		}
		
		for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
		{
			//보너스 캐쉬 사용.
			if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_ETC_ITEM, dwType, iArray) )
				{
					SP2Packet kPacket( STPK_ETCITEM_BUY );
					PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_BILLING_FAIL) );
					SendMessage( kPacket );	
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Spend Bonus Cash Error-guid:%s,publicID:%s(userIndex:%d) Index:%d:money:%d %d %d",GetBillingGUID().c_str(),GetPublicID().c_str(), GetUserIndex(), vConsumeInfo[i].value1, vConsumeInfo[i].value2, dwType, iArray );

					ClearBillingGUID();
					return ;
			}
		}
		ClearBillingGUID();

		int iBonusPeso = pEtcItem->GetBonusPeso( iArray );
		if( iBonusPeso > 0 )
		{
			AddMoney( iBonusPeso );
			g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, iBonusPeso, NULL);
		}


		//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);

	}
	else if ( bCash && !bBonusCash )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_OUT_OF_MONEY) );
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy BonusCash Shortage - %s(%d) %I64d:%d",GetPublicID().c_str(), GetUserIndex(), GetMoney(), iPeso );

		ClearBillingGUID();
		return;
	}

	
	// 아래 구문이 수정되면 _OnBillingOutputCashEtc() 함수도 수정해야 함.
	bool bNewMortmain = false;
	if( g_EtcItemMgr.IsBlockEtcItem( dwType ) && iServerValue == 0 )
	{
		if( pEtcItem->IsCanMortmain( iArray ) )
			bNewMortmain = true;
	}
	
	DWORD dwCompensation = _OnEtcItemSetting( pEtcItem, kEtcItemSlot, iServerValue, bNewMortmain );
	
	// compensation
	AddMoney( dwCompensation );
	g_LogDBClient.OnInsertPeso( this, dwCompensation, LogDBClient::PT_SELL_ETCITEM );
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_ETCITEM, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, dwCompensation, NULL);

	

	// set my item
	DWORD dwIndex        = 0;
	int   iArrayInIndex  = 0;
	BOOL  bGuildBlockItem	= FALSE;

	if( COMPARE( kEtcItemSlot.m_iType, ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_1000 + 1 ) )
	{
		DWORD dwBlockCode	= pEtcItem->GetProperty();

		for( int i = 0; i < iServerValue; i++ )
			g_DBClient.OnAddGuildBlockItem(GetUserIndex(), GetGuildIndex(),  dwBlockCode, GBA_ITEM_BUY );

		bGuildBlockItem	= TRUE;
	}
	else if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_HOUSING_BLOCK_1000 + 1 ) )
	{
		DWORD dwBlockCode	= pEtcItem->GetProperty();
		BOOL bEnd	= FALSE;

		for( int i = 0; i < iServerValue; i++ )
		{
			if( (iServerValue - 1 ) == i )
				bEnd	= TRUE;

			g_DBClient.OnAddPersonalHQBlockItem(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwBlockCode, iServerValue, bEnd);
		}

		bGuildBlockItem	= TRUE;
	}
	else if( !m_UserEtcItem.AddEtcItem( kEtcItemSlot, false, iPeso, dwIndex, iArrayInIndex ) )	
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Error AddEtcItem - %s(%d) %d:%d", GetPublicID().c_str(), GetUserIndex(), dwType, iServerValue );
		return;
	}

	if( dwIndex != 0 )
	{
	
		if( !bBonusCash )
		{
	
			char szItemIndex[MAX_PATH]="";
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayInIndex+1 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertEtc( this, dwType, iServerValue, iPeso, szItemIndex, LogDBClient::ET_BUY );
		}
		
		StartEtcItemTime(  __FUNCTION__ , dwType );
	}

	
	
	SP2Packet kPacket( STPK_ETCITEM_BUY );

	if( bGuildBlockItem )
	{
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_BLOCK) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iType) );
		PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );
		PACKET_GUARD_VOID( kPacket.Write(GetCash()) );
		PACKET_GUARD_VOID( kPacket.Write(GetChannelingCash()) );
		PACKET_GUARD_VOID( kPacket.Write(0) );
	}
	else
	{
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_OK) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iType) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iValue1) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iValue2) );
		PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );
		PACKET_GUARD_VOID( kPacket.Write(GetCash()) );
		PACKET_GUARD_VOID( kPacket.Write(GetChannelingCash()) );
		PACKET_GUARD_VOID( kPacket.Write(0) );						// 보너스 페소
		PACKET_GUARD_VOID( kPacket.Write(true) );					//구매 알림 팝업
		PACKET_GUARD_VOID( kPacket.Write(dwCompensation) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)EBRT_BUY) );
	}

	SendMessage( kPacket );

	SaveEtcItem();
	SaveUserData();

	if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_CHAR_SLOT_EXTEND )
	{
		CheckCurMaxCharSlot();
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_FISHING_SLOT_EXTEND )
	{
		m_UserFishingItem.CheckCurMaxInventory();
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_EXTRAITEM_SLOT_EXTEND )
	{
		m_UserExtraItem.SetMaxPossessionCount();
	}

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, true, ioPresentHelper::BT_ETC, dwType, iServerValue, iBuyCash );
	}
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN ||
		ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND &&
		g_App.GetUseBuyItemEvent() == 1 )
	{
		//가레나 이벤트 HRYOON 페소 구매
		if( g_App.GetEventItemValue2() == dwType )
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";

			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			SetBillingGUID( szTempGUID );

			ioHashString szRecvPublicID;
			ioHashString szRecvPrivateID;

			SP2Packet kBillingPacket( BSTPK_GA_WEB_EVENT );
			int dwType = 3;

			kBillingPacket<< GetBillingGUID() ;
			kBillingPacket<< dwType;
			kBillingPacket<< GetPrivateID();
			kBillingPacket<< GetPublicID();
			kBillingPacket<< "" ;
			kBillingPacket<< GetUserIndex();
			kBillingPacket<< BSTPK_GA_WEB_EVENT_RESULT;

			if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Garena Web Event Send Fail : recvUserIndex:%d, sendUserID:%s",
					__FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
			}
			else
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GARENA_EVENT]%s Garena Web Event Send recvUserIndex:%d, sendUserID:%s", 
					__FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
			}
		}
	}

	//구매 미션 체크
	static DWORDVec vValues;
	vValues.clear();
	vValues.push_back(PRESENT_ETC_ITEM);
	vValues.push_back(kEtcItemSlot.m_iType);
	vValues.push_back(iServerValue);

	g_MissionMgr.DoTrigger(MISSION_CLASS_ITEM_BUY, this, vValues);

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemBuy Ok %s(%d) %d - %d - %d - %d",GetPublicID().c_str(), GetUserIndex(),  dwType, iServerValue, iPeso, kEtcItemSlot.m_iValue1 );
}

void User::OnEtcItemUse( SP2Packet &rkPacket )
{
	int iType   = 0;
	PACKET_GUARD_VOID( rkPacket.Read( iType ) );
	//rkPacket >> iType;

	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( iType, kSlot );

#ifdef _LSWC
	if( iType == 1000009 && kSlot.m_iType == 0 ) //육성 복구권 무제한
	{
		kSlot.m_iValue1 += 1;
		kSlot.m_iType = 1000009;
	}
#endif
	if( kSlot.m_iType <= 0 || kSlot.m_iValue1 <= 0 )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_DONT_HAVE ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemUse Fail - %s) %d don't have value.",  GetPublicID().c_str(), iType );
		return;
	}

	ioEtcItem *pEtcItem = g_EtcItemMgr.FindEtcItem( iType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_EXCEPTION ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemUse Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), iType );
		return;
	}

	pEtcItem->OnUse( rkPacket, this, GetUserEtcItem(), kSlot );
}

void User::OnEtcItemMotionOption( SP2Packet &rkPacket )
{
	int iType   = 0;
	rkPacket >> iType;

	ioUserEtcItem::ETCITEMSLOT kSlot;
	if( !m_UserEtcItem.GetEtcItem( iType, kSlot ) )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		kReturn << ETCITEM_USE_DONT_HAVE;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemMotionOption Fail - %s) %d don't have value.",  GetPublicID().c_str(), iType );
		return;
	}

	if( !COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION1,  ioEtcItem::EIT_ETC_MOTION100 + 1 ) && 
		!COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION101,  ioEtcItem::EIT_ETC_MOTION400 + 1 ) )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		kReturn << ETCITEM_USE_EXCEPTION;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemMotionOption Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), iType );
		return;
	}

	// Use 값을 클라이언트에서 전송한 값으로 변경한다.
	int iMotionType;
	rkPacket >> iMotionType;

	// 오직 1개의 모션만 가능한 모션 아이템
	bool bOnlyOneMotion;
	rkPacket >> bOnlyOneMotion;

	int iPrevMotionType = kSlot.m_iValue1;
	kSlot.m_iValue1 = iMotionType;
	m_UserEtcItem.SetEtcItem( kSlot );
	SP2Packet kReturn( STPK_ETCITEM_USE );
	kReturn << ETCITEM_USE_OK;
	kReturn << kSlot.m_iType;
	kReturn << kSlot.m_iValue1;
	kReturn << kSlot.m_iValue2;
	SendMessage( kReturn );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemMotionOption Ok %s) %d.%d",  GetPublicID().c_str(), iType, kSlot.m_iValue1 );
	if( bOnlyOneMotion )
	{
		int iOnlyOneCount = 0;
		int iCurrentEtcSlot = m_UserEtcItem.GetEtcItemCurrentSlot();
		for(int i = 0;i < iCurrentEtcSlot;i++)
		{
			ioUserEtcItem::ETCITEMSLOT kSlot;
			if( m_UserEtcItem.GetEtcItemByArray( i, kSlot ) )
			{
				if( kSlot.m_iType == iType ) continue;
			
				if( COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION1, ioEtcItem::EIT_ETC_MOTION100 + 1 ) ||
					COMPARE( kSlot.m_iType, ioEtcItem::EIT_ETC_MOTION101, ioEtcItem::EIT_ETC_MOTION400 + 1 ) )
				{
					if( kSlot.m_iValue1 == iMotionType )
					{
						kSlot.m_iValue1 = 0;
						m_UserEtcItem.SetEtcItem( kSlot );

						iOnlyOneCount++;
					}
				}
			}
		}
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemMotionOption Ok %s) %d.%d OnlyOneMotion",  GetPublicID().c_str(), iType, iOnlyOneCount );
	}	

	// 진열 용병 모션
	if( m_pMyRoom && iMotionType > ioEtcItemMotion::MOTION_OPTION_100 )
	{
		if( iMotionType > ioEtcItemMotion::MOTION_OPTION_100 )
		{
			m_pMyRoom->OnModeChangeDisplayMotion( this, iType, iMotionType - ioEtcItemMotion::MOTION_OPTION_100 );
		}
		else if( iPrevMotionType > ioEtcItemMotion::MOTION_OPTION_100 )
		{
			m_pMyRoom->OnModeChangeDisplayMotion( this, 0, iPrevMotionType - ioEtcItemMotion::MOTION_OPTION_100 );
		}
	}
}

void User::OnEtcItemSell( SP2Packet &rkPacket )
{
	int iType   = 0;
	rkPacket >> iType;

	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( iType, kSlot );
	if( kSlot.m_iType <= 0 || kSlot.m_iValue1 <= 0 )
	{
		SP2Packet kReturn( STPK_ETCITEM_SELL );
		kReturn << ETCITEM_SELL_DONT_HAVE;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemSell Fail - %s) %d don't have value.",  GetPublicID().c_str(), iType );
		return;
	}

	ioEtcItem *pEtcItem = g_EtcItemMgr.FindEtcItem( iType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_ETCITEM_SELL );
		kReturn << ETCITEM_SELL_EXCEPTION;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemSell Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), iType );
		return;
	}

	pEtcItem->OnSell( rkPacket, this, GetUserEtcItem(), kSlot );

	SaveEtcItem();
	SaveUserData();
}

int User::_OnEtcItemPackageDecoInsert( SP2Packet &rkPacket, DWORD dwEtcItemType,  bool bSoldierPackage )
{
	// 기본 치장 추가.
	int iDefaultDeco;
	PACKET_GUARD_INT( rkPacket.Read(iDefaultDeco) );

	for(int i = 0;i < iDefaultDeco;i++)
	{
		ITEMSLOT kSlot;
		PACKET_GUARD_INT( rkPacket.Read(kSlot.m_item_type) );
		PACKET_GUARD_INT( rkPacket.Read(kSlot.m_item_code) );

		if( !m_Inventory.IsSlotItem( kSlot ) )
		{
			if( dwEtcItemType != ioEtcItem::EIT_ETC_SOLDIER_PACKAGE &&
				dwEtcItemType != ioEtcItem::EIT_ETC_SOLDIER_PACKAGE2 &&
				!COMPARE( dwEtcItemType, ioEtcItem::EIT_ETC_SOLDIER_PACKAGE3, ioEtcItem::EIT_ETC_SOLDIER_PACKAGE10 + 1 ) &&
				dwEtcItemType != ioEtcItem::EIT_ETC_PREMIUM_SOLDIER_PACKAGE &&
				dwEtcItemType != ioEtcItem::EIT_ETC_DECORATION_PACKAGE )
				continue;

			DWORD dwIndex = 0;
			int   iArray  = 0;



			if( m_Inventory.IsFull() && !bSoldierPackage )
			{
				return -1;
			}

			m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_DEFAULT, dwIndex, iArray);


			if( dwIndex != 0 && dwIndex != ioInventory::NEW_INDEX )
			{
				char szItemIndex[MAX_PATH]="";
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, 0, szItemIndex, LogDBClient::DT_DEFAULT );
			}
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnEtcItemPackageDecoInsert 기본 치장 추가 %s - %d : %d", GetPublicID().c_str(), kSlot.m_item_type, kSlot.m_item_code );

			// 치장 착용 ( 여기서 기본 치장을 착용하고 아래에서 선택 치장을 다시 착용한다 - 남자 캐릭터 치장을 착용 상태로 유지하기 위해서 (남,여캐릭터 치장은 다른 아이템으로 구분되어 각각 착용하고 있다) - )
			m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code );
		}
	}
	
	
	int iReturnPeso = 0;	
	{   // 선택 치장 적용
		int iSelectDeco;
		PACKET_GUARD_INT( rkPacket.Read(iSelectDeco) );

		for (int i = 0; i < iSelectDeco ; i++)
		{
			ITEMSLOT kSlot;
			PACKET_GUARD_INT( rkPacket.Read(kSlot.m_item_type) );
			PACKET_GUARD_INT( rkPacket.Read(kSlot.m_item_code) );

			int iDecoType = kSlot.m_item_type%1000;
			if( dwEtcItemType == ioEtcItem::EIT_ETC_DECO_UNDERWEAR_PACKAGE &&  iDecoType != UID_UNDERWEAR )
				continue;

			if( !m_Inventory.IsSlotItem( kSlot ) )                // IsSlotItem 내부에서 인간 남자는 보유로 판단한다.
			{
				DWORD dwIndex = 0;
				int   iArray  = 0;

				if( m_Inventory.IsFull() )
				{
					return -1;
				}

				m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_PACKAGE, dwIndex, iArray );
				

				if( dwIndex != 0 && dwIndex != ioInventory::NEW_INDEX )
				{
					char szItemIndex[MAX_PATH]="";
					StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
					g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, 0, szItemIndex, LogDBClient::DT_PACKAGE );
				}

				m_UserGrowthLevel.AddCharGrowthPointByDecoWoman( kSlot.m_item_type, kSlot.m_item_code );

				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnEtcItemPackageDecoInsert 선택 치장 추가 %s - %d : %d", GetPublicID().c_str(), kSlot.m_item_type, kSlot.m_item_code );
			}
			else 
			{
				// 보유중인 치장이라면 페소로 반환
				int iResellPeso = g_DecorationPrice.GetDecoPackageKeepPeso( kSlot.m_item_type );
				iReturnPeso += iResellPeso;
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnEtcItemPackageDecoInsert 보유 치장 보상 %s - %d : %d : %d", GetPublicID().c_str(), kSlot.m_item_type, kSlot.m_item_code, iResellPeso );
			}

			// 치장 착용
			int iEquipItemCode = m_Inventory.GetEquipItemCode( kSlot.m_item_type );
			if( iEquipItemCode != kSlot.m_item_code )
			{
				m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code );
			}
		}
	}

	SaveInventory();
	return iReturnPeso;
}

void User::OnEtcItemSoldierPackage( SP2Packet &rkPacket, DWORD dwEtcItemType, int iClassType, int eActiveFilter )
{
	SP2Packet kReturn( STPK_ETCITEM_USE );

	// 이미 영구 용병이 있는지 확인
	int iExtendCharArray = -1;
	for( int i = 0; i < GetCharCount(); i++ )
	{
		const CHARACTER &rkCharInfo = m_CharList[i]->GetCharInfo();
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) )
			continue;
		
		if( rkCharInfo.m_class_type == iClassType )
		{
			if( rkCharInfo.m_ePeriodType == CPT_MORTMAIN )       // 영구 용병
			{
				kReturn << ETCITEM_USE_ALREADY_CHAR;
				SendMessage( kReturn );
				return;			
			}
			iExtendCharArray = i;
			break;
		}
	}

	// check active
	DWORD dwSetItemCode = iClassType + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !pSetInfo )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s %s %d [%d] pSetInfo == NULL [%d]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iClassType, dwEtcItemType );
		return;
	}

	bool bError = false;
	if( dwEtcItemType == ioEtcItem::EIT_ETC_SOLDIER_PACKAGE || dwEtcItemType == ioEtcItem::EIT_ETC_SOLDIER_PACKAGE2 || COMPARE( dwEtcItemType, ioEtcItem::EIT_ETC_SOLDIER_PACKAGE3, ioEtcItem::EIT_ETC_SOLDIER_PACKAGE10 + 1 ) )
	{
		ioEtcItemSoldierPackage *pSoldierPackage = static_cast< ioEtcItemSoldierPackage * >( g_EtcItemMgr.FindEtcItem( dwEtcItemType ) );
		if( pSoldierPackage )
		{
			int iLimitClassNum = pSoldierPackage->GetLimitClassTypeNum();
			if( iLimitClassNum < iClassType )
				bError = true;

			if( !pSoldierPackage->IsRightSoldierCode( iClassType ) )
				bError = true;
		}
	}
	else if( dwEtcItemType == ioEtcItem::EIT_ETC_PREMIUM_SOLDIER_PACKAGE )
	{
		ioEtcItemSoldierPackage *pSoldierPackage = static_cast< ioEtcItemSoldierPackage * >( g_EtcItemMgr.FindEtcItem( dwEtcItemType ) );
		if( pSoldierPackage )
		{
			int iLimitClassNum = pSoldierPackage->GetLimitClassTypeNum();
			if( iLimitClassNum < iClassType )
				bError = true;

			if( !pSoldierPackage->IsRightSoldierCode( iClassType ) )
				bError = true;
		}

		if( pSetInfo->GetPackageType() != ioSetItemInfo::PT_PREMIUM ) 
		{
			bError = true;
		}
	}

	switch( eActiveFilter )
	{
	case ioEtcItemSoldierPackage::AF_ACTIVE:
		{
			if( !g_ItemPriceMgr.IsActive( iClassType ) )
				bError = true;
		}
		break;
	}

	if( bError )
	{
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_EXCEPTION) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s %s %d [%d]inactive package soldier[%d]-[%d][%d]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iClassType, dwEtcItemType, eActiveFilter );
		return;
	}
	//

	// 동일한 용병을 DB에서 가져 오는 중인지 확인
	for( int i = 0; i < (int)m_vLevelUpAndPresentCreateClass.size(); i++ )
	{
		if( (int)m_vLevelUpAndPresentCreateClass[i] == iClassType )
		{
			PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_CHAR_BEGINNING) );
			SendMessage( kReturn );
			return;			
		}
	}
	
	if( iExtendCharArray != -1 )        // 시간제 용병을 영구 용병으로 변경
	{
		ioCharacter *pExtendChar = m_CharList[iExtendCharArray];
		
		const CHARACTER &rkCharInfo = pExtendChar->GetCharInfo();	
		// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->UpdateLimitTimer();
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemSoldierPackage Change Mortmain - UpdateLimitTimer %s - %d : %d", GetPublicID().c_str(), pExtendChar->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
		}	

		int iResellLimitDate = pExtendChar->GetCharLimitDate();

		bool bResell = true;

		if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN)
		{
			CTime cCharTime = Help::ConvertNumberToCTime(iResellLimitDate);
			CTime kCurTime = CTime::GetCurrentTime();

			if(kCurTime < cCharTime)
			{
				CTimeSpan cRemainTime = cCharTime - kCurTime;
				iResellLimitDate = cRemainTime.GetTotalMinutes();
			}
			else
			{
				bResell = false;
				iResellLimitDate = 1;
			}
		}

		int iResellPeso      = g_ItemPriceMgr.GetTimeCharResellPeso( rkCharInfo.m_class_type, iResellLimitDate  );

		if(!bResell)
			iResellPeso = 0;

		if( iResellPeso > 0 )
		{
			AddMoney( iResellPeso );
			g_LogDBClient.OnInsertPeso( this, iResellPeso, LogDBClient::PT_DEL_CHAR );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_DEL_CHAR, PRESENT_SOLDIER, rkCharInfo.m_class_type, iResellPeso, NULL);
		}

		pExtendChar->SetPeriodType( CPT_MORTMAIN );
		pExtendChar->SetCharLimitDate( 0 );
		pExtendChar->SetActive( true );

		{
			SP2Packet kPacket( STPK_CHAR_EXTEND );
			PACKET_GUARD_VOID( kPacket.Write(CHAR_EXTEND_OK) );
			PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );
			PACKET_GUARD_VOID( kPacket.Write(GetCash()) );
			PACKET_GUARD_VOID( kPacket.Write(GetChannelingCash()) );
			PACKET_GUARD_VOID( kPacket.Write(iExtendCharArray) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(pExtendChar->IsActive()) );
			PACKET_GUARD_VOID( kPacket.Write(pExtendChar->GetCharLimitDate()) );
			PACKET_GUARD_VOID( kPacket.Write(pExtendChar->GetLimitCheckSecond()) );

			SendMessage( kPacket );	
		}		

		// Decoration 
		int iDecoKeepPeso = _OnEtcItemPackageDecoInsert( rkPacket, dwEtcItemType, true );		
		if( iDecoKeepPeso >= 0 )
		{
			AddMoney( iDecoKeepPeso );
			g_LogDBClient.OnInsertPeso( this, iDecoKeepPeso, LogDBClient::PT_PACKAGE_DECO );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_PACKAGE_DECO, PRESENT_DECORATION, dwEtcItemType, iDecoKeepPeso, NULL);
		}
		else
		{
			PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_EXCEPTION ) );
			SendMessage( kReturn );
			return;	
		}

		// 캐릭터에 모든 치장 적용
		pExtendChar->SetCharAllDecoration( m_Inventory );

		// 변경된 정보 저장
		SaveCharacter();  
		SaveUserData();

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemSoldierPackage Change Mortmain %s - %d + %d = %I64d", GetPublicID().c_str(), iResellPeso, iDecoKeepPeso, GetMoney() );
		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", pExtendChar->GetCharIndex() );
		g_LogDBClient.OnInsertChar( this, rkCharInfo.m_class_type, pExtendChar->GetCharLimitDate(), 0, szItemIndex, LogDBClient::CT_PACKAGE );

		// 권한 아이템 삭제
		m_UserEtcItem.DeleteEtcItem( dwEtcItemType, LogDBClient::ET_DEL );

		//
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_OK) );
		PACKET_GUARD_VOID( kReturn.Write(dwEtcItemType) );
		PACKET_GUARD_VOID( kReturn.Write((CHARACTER)pExtendChar->GetCharInfo()) );
		PACKET_GUARD_VOID( kReturn.Write(iResellPeso + iDecoKeepPeso) );
		PACKET_GUARD_VOID( kReturn.Write(GetMoney()) );

		SendMessage( kReturn );

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharDecoUpdate( this, pExtendChar );
		}
	}
	else             // 영구 용병 생성
	{
		if( IsClassTypeExerciseStyle( iClassType, EXERCISE_RENTAL ) == false ) 
		{
			if( ( (int)m_vLevelUpAndPresentCreateClass.size() + GetCharCount() ) >= m_iCurMaxCharSlot )
			{
				PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_CHAR_SLOT_FULL) );
				SendMessage( kReturn );
				return;			
			}
		}

		// 신규 용병 추가.
		CHARACTER kCharInfo;
		kCharInfo.m_class_type   = iClassType;
		kCharInfo.m_iLimitSecond = 0;
		kCharInfo.m_ePeriodType  = CPT_MORTMAIN;       

		// Decoration 
		int iDecoKeepPeso = _OnEtcItemPackageDecoInsert( rkPacket, dwEtcItemType, true );
		if( iDecoKeepPeso >= 0 )
		{
			AddMoney( iDecoKeepPeso );
			g_LogDBClient.OnInsertPeso( this, iDecoKeepPeso, LogDBClient::PT_PACKAGE_DECO );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_PACKAGE_DECO, PRESENT_DECORATION, dwEtcItemType, iDecoKeepPeso, NULL);
		}
		else
		{
			PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_EXCEPTION ) );
			SendMessage( kReturn );
			return;	
		}
		
		// 캐릭터에 모든 치장 적용
		m_Inventory.GetEquipItemCode( kCharInfo );

		// 변경된 정보 저장
		SaveUserData();

		//캐릭터 생성.
		m_iCreateCharCount++;		
		g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
		g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK_PACKAGE, 1, LogDBClient::CT_PACKAGE );
		m_vLevelUpAndPresentCreateClass.push_back( iClassType );

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemSoldierPackage Create %s - %d = %I64d", GetPublicID().c_str(), iDecoKeepPeso, GetMoney() );
		// 권한 아이템 삭제
		m_UserEtcItem.DeleteEtcItem( dwEtcItemType, LogDBClient::ET_DEL );

		//
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_OK) );
		PACKET_GUARD_VOID( kReturn.Write(dwEtcItemType) );
		PACKET_GUARD_VOID( kReturn.Write(kCharInfo) );
		PACKET_GUARD_VOID( kReturn.Write(iDecoKeepPeso) );
		PACKET_GUARD_VOID( kReturn.Write(GetMoney()) );

		SendMessage( kReturn );
	}	
}

void User::OnEtcItemDecorationPackage( SP2Packet &rkPacket, DWORD dwEtcItemType )
{
	SP2Packet kReturn( STPK_ETCITEM_USE );
	// 용병을 보유하고있는지 확인
	int iClassType;
	PACKET_GUARD_VOID( rkPacket.Read(iClassType) );
	int iExtendCharArray = -1;
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		const CHARACTER &rkCharInfo = m_CharList[i]->GetCharInfo();
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;

		if( rkCharInfo.m_class_type == iClassType )
		{
			iExtendCharArray = i;
			break;
		}
	}

	// 용병 없음.
	if( iExtendCharArray == -1 || m_CharList[iExtendCharArray] == NULL )
	{
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_CHAR_NONE) );
		SendMessage( kReturn );
		return;
	}
	ioCharacter *pExtendChar = m_CharList[iExtendCharArray];

	// Decoration 
	int iDecoKeepPeso = _OnEtcItemPackageDecoInsert( rkPacket, dwEtcItemType );
	if( iDecoKeepPeso >= 0 )
	{
		AddMoney( iDecoKeepPeso );
		g_LogDBClient.OnInsertPeso( this, iDecoKeepPeso, LogDBClient::PT_PACKAGE_DECO );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_PACKAGE_DECO, PRESENT_DECORATION, dwEtcItemType, iDecoKeepPeso, NULL);
	}
	else
	{
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_DECO_SLOT_FULL ) );
		SendMessage( kReturn );
		return;	
	}

	// 캐릭터에 모든 치장 적용
	pExtendChar->SetCharAllDecoration( m_Inventory );

	// 변경된 정보 저장
	SaveUserData();

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemDecorationPackage  %s - %d = %I64d", GetPublicID().c_str(), iDecoKeepPeso, GetMoney() );

	// 권한 아이템 삭제
	m_UserEtcItem.DeleteEtcItem( dwEtcItemType, LogDBClient::ET_DEL );

	//
	PACKET_GUARD_VOID( kReturn.Write(ETCITEM_USE_OK) );
	PACKET_GUARD_VOID( kReturn.Write((int)dwEtcItemType) );
	PACKET_GUARD_VOID( kReturn.Write((CHARACTER) pExtendChar->GetCharInfo()) );
	PACKET_GUARD_VOID( kReturn.Write(iDecoKeepPeso) );
	PACKET_GUARD_VOID( kReturn.Write(GetMoney()) );

	SendMessage( kReturn );

	if( m_pMyRoom )
	{
		m_pMyRoom->OnModeCharDecoUpdate( this, pExtendChar );
	}
}

void User::OnBuySelectExtraGashapon( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s OnEtcItemBuy Billing Wait %s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kReturn << BUY_SELECT_EXTRA_GASHAPON_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	ClearSelectExtraItemCodes();

	int ioEtcItemType = 0;
	int iArray = 0;
	rkPacket >> ioEtcItemType;
	rkPacket >> iArray;
	for (int i = 0; i < MAX_SELECT_EXTRA_ITEM_CODE; i++)
	{
		rkPacket >> m_iSelectExtraItemCodes[i];
	}

	IntVec vCheck;
	GetSelectExtraItemCodes( vCheck );

	// 체크
	if( vCheck.empty() )
	{
		SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kReturn << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectExtraItemCodes();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - empty -%s", __FUNCTION__ , GetPublicID().c_str() );
		return;
	}

	if( iArray != ( vCheck.size()-1 ) )
	{
		SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kReturn << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectExtraItemCodes();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - iArray -%s %d:%d", __FUNCTION__ , GetPublicID().c_str(), iArray, vCheck.size() );
		return;
	}

	// 중복 체크
	if( !vCheck.empty() )
		std::sort( vCheck.begin(), vCheck.end() );

	int iSize = vCheck.size();
	for (int i = 0; i < iSize-1 ; i++)
	{
		if( vCheck[i] == vCheck[i+1] )
		{
			SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
			kReturn << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
			SendMessage( kReturn );
			ClearSelectExtraItemCodes();
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - Dulicate -%s : %d:%d", __FUNCTION__ , GetPublicID().c_str(), vCheck[i], vCheck[i+1] );
			return;
		}
	}


	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem( ioEtcItemType );
	if(!pEtcItem)
	{
		SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kReturn << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectExtraItemCodes();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - NULL -%s : %d", __FUNCTION__ , GetPublicID().c_str(), ioEtcItemType );
		return;
	}

	if( GetEntryType() == ET_TERMINATION )
	{
		SP2Packet kPacket( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kPacket << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
		SendMessage( kPacket );	
		ClearSelectExtraItemCodes();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Entry Type Error - %s : %d", __FUNCTION__,GetPublicID().c_str(), GetEntryType() );
		return;
	}

	int iBuyCash = pEtcItem->GetCash( iArray );
	if( iBuyCash <= 0 )
	{
		SP2Packet kPacket( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kPacket << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
		SendMessage( kPacket );	
		ClearSelectExtraItemCodes();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error - %s(%d) : %d : %d : %d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, ioEtcItemType, iArray );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
		kReturn << BUY_SELECT_EXTRA_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectExtraItemCodes();
		return;
	}
	//HRYOON BONUS CASH 사용 가능 여부 파악
	//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);

	bool bBonusCash = false;

	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	int iItemPrice = iBuyCash;

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_BUY_SELECT_EXTRA_GASHAPON, BUY_SELECT_EXTRA_GASHAPON_BILLING_WANT_OF_CASH, ioEtcItemType, vConsumeInfo ) )
		return;

	int iSpendBonusCash	= 0;
	int iBonusSize	= vConsumeInfo.size();

	for( int i = 0; i < iBonusSize; i++ )
		iSpendBonusCash += vConsumeInfo[i].value2;
		
	//보너스 캐쉬로 구매 가능 
	if( iSpendBonusCash >= iItemPrice )
		bBonusCash = true;

	if( iItemPrice != iSpendBonusCash )
	{
		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << iItemPrice;
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;

		PACKET_GUARD_VOID( kBillingPacket.Write(iBonusSize) );
		for( int i = 0; i < iBonusSize; i++ )
		{
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		kBillingPacket << OUTPUT_CASH_ETC;
		kBillingPacket << ioEtcItemType;
		kBillingPacket << iArray;

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_BUY_SELECT_EXTRA_GASHAPON, BUY_SELECT_EXTRA_GASHAPON_BILLING_FAIL, NULL, NULL ) )
			return;

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
			kReturn << BUY_SELECT_EXTRA_GASHAPON_BILLING_DISCONNECT;
			SendMessage( kReturn );
			m_szBillingGUID.Clear();
			ClearSelectExtraItemCodes();
		}
		else
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );	
		
		return;
	}

	else if( bBonusCash )
	{

		if(m_szBillingGUID.IsEmpty())
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;
		}

		for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
		{

			//보너스 캐쉬 사용.
			
			if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_ETC_ITEM, ioEtcItemType, 0) )
			{
				SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
				PACKET_GUARD_VOID( kReturn.Write(BUY_SELECT_EXTRA_GASHAPON_EXCEPTION) );
				SendMessage( kReturn );

				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error-guid:%s,publicID:%s(userIndex:%d)guid:%s, index:%d,money:%d", __FUNCTION__, GetBillingGUID().c_str(), GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2 );
				ClearBillingGUID();

				return;

			}
		}
		pEtcItem->OnAfterBuy( this, rkPacket, iArray, 0 );
		ClearSelectExtraItemCodes();
		ClearBillingGUID();

		int iBonusPeso = pEtcItem->GetBonusPeso( iArray );
		if( iBonusPeso > 0 )
		{
			AddMoney( iBonusPeso );
			g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_ETC_ITEM, ioEtcItemType, iBonusPeso, NULL);
		}
		//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);
	}
	else
	{
		//[HRYOON구매] 유저 구매 중인 상태로 변경함
		SetOutputStatus( true );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnBuySelectExtraGashapon Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );	
	}
}

void User::ClearSelectExtraItemCodes()
{
	for(int i = 0; i < MAX_SELECT_EXTRA_ITEM_CODE; i++)
	{
		m_iSelectExtraItemCodes[i] = 0;	
	}
}

void User::GetSelectExtraItemCodes( IntVec &rvInt )
{
	rvInt.clear();
	for(int i = 0; i < MAX_SELECT_EXTRA_ITEM_CODE; i++)
	{
		if( m_iSelectExtraItemCodes[i] <= 0 )
			continue;
		rvInt.push_back( m_iSelectExtraItemCodes[i] );
	}
}

void User::DeleteCharData( int iCharArray )
{
	if( COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		// 추가장비 정보는 제거
		for( int j=0; j < MAX_CHAR_DBITEM_SLOT; ++j )
		{
			TakeoffExtraItem(iCharArray, j);
			//kChar.m_extra_item[j] = 0;
		}

		const CHARACTER &charInfo = m_CharList[iCharArray]->GetCharInfo();
		CHARACTER kChar = charInfo;

		//장착 코스튬 제거
		for( int j = 0; j < MAX_CHAR_COSTUME_SLOT; j++ )
		{
			DWORD dwCostumeIndex = kChar.m_costume_item[j].m_iCostumeIndex;
			if( dwCostumeIndex != 0 )
				m_UserCostume.ReleaseCostumeWithCostumeIndex(dwCostumeIndex);
		}

		for( int j = 0; j < MAX_CHAR_ACCESSORY_SLOT; j++ )
		{
			DWORD dwAccessoryIndex = kChar.m_accessory_item[j].m_iAccessoryIndex;
			if( dwAccessoryIndex != 0 )
				m_UserAccessory.ReleaseAccessoryWithAccessoryIndex(dwAccessoryIndex);
		}

		m_CharList[iCharArray]->SetCharInfo( m_CharList[iCharArray]->GetCharIndex(), kChar, this );

		// 장착메달 해제
		m_UserMedalItem.ReleaseEquipMedal( kChar.m_class_type );

		//
		if( m_pMyRoom )
			m_pMyRoom->OnModeCharDelete( this, m_CharList[iCharArray]->GetCharIndex() );

		SAFEDELETE( m_CharList[iCharArray] );
		m_CharList.erase( m_CharList.begin() + iCharArray );
	}
}

bool User::DeleteExerciseChar( byte chExerciseStyle )
{
	bool bDlete = false;
	for(int i = 0;i < GetCharCount(); )
	{
		if( m_CharList[i]->HasExerciseStyle( chExerciseStyle ) )
		{
			if( m_pMyRoom )
			{
				m_pMyRoom->CheckCreateCrown( this );
			}

			if( chExerciseStyle == EXERCISE_RENTAL )
			{
				// 대여 용병 반납 프로세스
				// 주인에게 전송
				DeleteExerciseRentalChar( i, true );
			}
			else
			{
				g_ExerciseCharIndexMgr.Add( m_CharList[i]->GetCharIndex() );
				DeleteCharData( i );
			}
			bDlete = true;
		}
		else
			i++;
	}			

	return bDlete;
}

bool User::DeleteExercisePCRoomChar( DWORD dwCharIdx )
{
	int iArray = GetCharArray( dwCharIdx );
	if( iArray == -1 )
		return false;

	ioCharacter* pChar  = m_CharList[iArray];
	if( !pChar )
		return false;

	if( !pChar->HasExerciseStyle( EXERCISE_PCROOM ) )
		return false;

	if( m_pMyRoom )
		m_pMyRoom->CheckCreateCrown( this );

	if( dwCharIdx == pChar->GetCharIndex() )
	{
		g_ExerciseCharIndexMgr.Add( dwCharIdx );
		DeleteCharData( iArray );
		return true;
	}

	return false;
}

void User::DeleteExerciseRentalChar( int iCharArray, bool bReturnPacket )
{
	ioCharacter *pCharacter = GetCharacter( iCharArray );
	if( pCharacter == NULL ) 
		return;

	RentalData &rkRentalData = m_CharRentalData.GetRentalData( pCharacter->GetCharIndex() );
	if( rkRentalData.m_dwCharIndex == pCharacter->GetCharIndex() )
	{
		if( bReturnPacket )
		{
			UserParent *pOnwerParent = g_UserNodeManager.GetGlobalUserNode( rkRentalData.m_szOwnerName );
			if( pOnwerParent )
			{
				SP2Packet kPacket( STPK_USER_CHAR_RENTAL_RETURN );

				PACKET_GUARD_VOID( kPacket.Write(pCharacter->GetCharIndex()) );
				PACKET_GUARD_VOID( kPacket.Write(pCharacter->GetCharInfo().m_class_type) );

				pOnwerParent->RelayPacket( kPacket );
			}
		}
		g_DBClient.OnUpdateCharRentalTime( GetUserDBAgentID(), GetAgentThreadID(), pCharacter->GetCharIndex(), 0 );
		m_CharRentalData.DeleteRentalData( pCharacter->GetCharIndex() );
	}

	DeleteCharData( iCharArray );
}

void User::DeleteExerciseRentalCharAll()
{
	for(int i = 0;i < GetCharCount();i++ )
	{
		if( m_CharList[i]->HasExerciseStyle( EXERCISE_RENTAL ) )
		{
			DeleteExerciseRentalChar( i, false );
		}
	}			
}

void User::CheckExerciseRentalCharDeleteTime()
{
	for(int i = 0;i < GetCharCount();i++ )
	{
		ioCharacter *pCharacter = m_CharList[i];
		if( pCharacter->HasExerciseStyle( EXERCISE_RENTAL ) )
		{
			pCharacter->CheckRentalLimitTime();
			if( pCharacter->GetRentalLimitTime() == 0 )  // 대여 만료
			{
				if( m_select_char > i )
					m_select_char = max( 0, m_select_char - 1 );
				else if( m_select_char == i )
				{
					//
					m_select_char = 0;
					for(int k = 0;k < GetCharCount();k++)
					{
						if( pCharacter == m_CharList[k] ) continue;

						if( m_CharList[k]->IsActive() )
						{
							m_select_char = k;
							break;
						}
					}			
				}	

				SP2Packet kPacket( STPK_CHAR_DELETE );
				kPacket << DELETE_CHAR_OK << pCharacter->GetCharIndex() << 0 << GetMoney();
				SendMessage( kPacket );

				DeleteExerciseRentalChar( i, true );			
			}
		}
	}			
}

void User::BuyRentalCharacterProcess( ioCharacter *pCharacter )
{
	if( pCharacter == NULL ) 
		return;

	RentalData &rkRentalData = m_CharRentalData.GetRentalData( pCharacter->GetCharIndex() );
	if( rkRentalData.m_dwCharIndex == pCharacter->GetCharIndex() )
	{
		UserParent *pOnwerParent = g_UserNodeManager.GetGlobalUserNode( rkRentalData.m_szOwnerName );
		if( pOnwerParent )
		{
			SP2Packet kPacket( STPK_USER_CHAR_RENTAL_RETURN );
			
			PACKET_GUARD_VOID( kPacket.Write(pCharacter->GetCharIndex()) );
			PACKET_GUARD_VOID( kPacket.Write(pCharacter->GetCharInfo().m_class_type) );
			
			pOnwerParent->RelayPacket( kPacket );
		}
		g_DBClient.OnUpdateCharRentalTime( GetUserDBAgentID(), GetAgentThreadID(), pCharacter->GetCharIndex(), 0 );
		m_CharRentalData.DeleteRentalData( pCharacter->GetCharIndex() );
	}
}

void User::FixSelectChar()
{
	if( COMPARE( m_select_char, 0, GetCharCount() ) )
		return;

	m_select_char = 0;
	for(int i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->IsActive() )
		{
			m_select_char = i;
			break;
		}
	}
}

void User::EnterRoomSelectChar()
{
	// 기간이 지난 용병을 선택중이라면 기간이 지나지 않은 용병을 가리킨다.
	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
		m_select_char = 0;
	else
	{
		if( !m_CharList[m_select_char]->IsActive() )
		{
			int i = 0;
			for(i = 0;i < GetCharCount();i++)
			{
				if( m_CharList[i]->IsActive() )
				{
					m_select_char = i;
					return;
				}
			}	
		}		
	}
}

bool User::IsDeleteExerciseChar( Room *pRoom, byte chExerciseType )
{
	if( !pRoom ) return true;

	if( chExerciseType == EXERCISE_GENERAL  )
	{
		if( pRoom->GetModeType() == MT_TRAINING ) return false;
	}
	else if( chExerciseType == EXERCISE_PCROOM )
	{
		return false;
	}
	else if( chExerciseType == EXERCISE_RENTAL )
	{
		return false;
	}
	else if( chExerciseType == EXERCISE_EVENT ) // ExerciseSoldierEvent
	{
		return true;
	}

	return true;
}

void User::OnChannelCreate( SP2Packet &rkPacket )
{
	ioHashString szManToManID;
	rkPacket >> szManToManID;

	if( GetJoinChannelSize() >= MAX_JOIN_CHANNEL )
	{
		// 채널 없음 에러
		SP2Packet kPacket( STPK_CHANNEL_CREATE );
		kPacket << CHANNEL_MY_CHANNEL_FULL << szManToManID;
		SendMessage( kPacket );
	}
	else
	{		
		// 채널 생성
		ChannelNode *pNode = g_ChannelNodeManager.CreateNewNode();
		if( pNode )
		{
			pNode->SetManToManID( szManToManID );
			EnterChannel( pNode );

			SP2Packet kPacket( STPK_CHANNEL_CREATE );
			kPacket << CHANNEL_CREATE_OK << pNode->GetIndex() << szManToManID;
			SendMessage( kPacket );
		}		
		else
		{
			// 채널 없음 에러
			SP2Packet kPacket( STPK_CHANNEL_CREATE );
			kPacket << CHANNEL_MY_CHANNEL_FULL << szManToManID;
			SendMessage( kPacket );
		}		
	}
}

int User::_OnChannelInviteException( int iIndex )
{
	int iResult = CHANNEL_INVITE_OK;
	if( GetJoinChannelSize() >= MAX_JOIN_CHANNEL )
	{
		// 초대 받는 유저 채널 없음 에러
		iResult = CHANNEL_INVITE_USER_NOT_CHANNEL;
	}
	else if( FindChannel( iIndex ) )
	{
		// 이미 채널에 있는 유저 에러
		iResult = CHANNEL_INVITE_USER_ALREADY_CHANNEL;
	}
	return iResult;
}

void User::OnChannelInvite( SP2Packet &rkPacket )
{
	ioHashString szInvitedID;
	DWORD dwChannelIndex;
	rkPacket >> dwChannelIndex >> szInvitedID;
	ChannelParent *pChannelParent = FindChannel( dwChannelIndex );
	if( pChannelParent )
	{
		if( pChannelParent->IsChannelOriginal() )
		{
			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szInvitedID );
			if( !pUserParent )   // 유저 없음
			{
				SP2Packet kPacket( STPK_CHANNEL_INVITE );
				kPacket << CHANNEL_INVITE_NOT_USER << dwChannelIndex << szInvitedID;
				SendMessage( kPacket );
			}
			else if( pUserParent->IsUserOriginal() )
			{
				User *pUser = (User*)pUserParent;
				int iResult = pUser->_OnChannelInviteException( dwChannelIndex );
				if( iResult != CHANNEL_INVITE_OK )
				{
					SP2Packet kPacket( STPK_CHANNEL_INVITE );
					kPacket << iResult << dwChannelIndex << szInvitedID;
					SendMessage( kPacket );

					ChannelNode *pNode = (ChannelNode*)pChannelParent;
					CRASH_GUARD();
					if( pNode->GetManToManID() == szInvitedID )
						pNode->SetManToManID( "" );
				}
				else
				{
					User *pUser = (User*)pUserParent;
					pUser->EnterChannel( pChannelParent );
					SP2Packet kPacket( STPK_CHANNEL_INVITE );
					kPacket << CHANNEL_INVITE_OK << pChannelParent->GetIndex() << GetPublicID() << pUser->GetPublicID();
					pChannelParent->SendPacketTcp( kPacket );			
				}
			}
			else       // 복사본 유저 처리
			{
				UserCopyNode *pCopyUser = (UserCopyNode*)pUserParent;
				SP2Packet kPacket( SSTPK_CHANNEL_INVITE );
				kPacket << INVITE_CHANNEL_USER_TRANSFER << dwChannelIndex << szInvitedID << GetUserIndex();
				pCopyUser->SendMessage( kPacket );
			}
		}
		else
		{
			ChannelCopyNode *pCopyNode = (ChannelCopyNode*)pChannelParent;
			SP2Packet kPacket( SSTPK_CHANNEL_INVITE );
			kPacket << INVITE_CHANNEL_TRANSFER << dwChannelIndex << szInvitedID << GetUserIndex();
			pCopyNode->SendMessage( kPacket );
		}
	}
	else
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChannelInvite 없는 채널에서 초대 : %s", GetPublicID().c_str() );
}

void User::OnChannelLeave( SP2Packet &rkPacket )
{
	DWORD dwIndex;
	rkPacket >> dwIndex;
	ChannelParent *pNode = FindChannel( dwIndex );
	if( pNode )
		LeaveChannel( pNode );
}

void User::OnChannelChat( SP2Packet &rkPacket )
{
	ioHashString szChat;
	DWORD dwIndex;
	rkPacket >> dwIndex >> szChat;

	ChannelParent *pChannelParent = FindChannel( dwIndex );
	if( pChannelParent )
	{
		if( pChannelParent->IsChannelOriginal() )
		{
			ChannelNode *pChannel = (ChannelNode*)pChannelParent;
			if( pChannel->GetManToManID().IsEmpty() )
			{
				SP2Packet kPacket( STPK_CHANNEL_CHAT );
				kPacket << dwIndex << GetPublicID() << szChat;
				pChannelParent->SendPacketTcp( kPacket, GetUserIndex() );	
			}	
			else
			{
				// 맨투맨 유저를 먼저 입장 시킨후 채팅 발사
				UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( pChannel->GetManToManID() );
				if( !pUserParent )     //유저 없다
				{
					SP2Packet kPacket( STPK_CHANNEL_INVITE );
					kPacket << CHANNEL_INVITE_NOT_USER << dwIndex << pChannel->GetManToManID();
					SendMessage( kPacket );
					pChannel->SetManToManID( "" );
				}
				else if( pUserParent->IsUserOriginal() )
				{
					User *pUser = (User*)pUserParent;
					int iResult = pUser->_OnChannelInviteException( dwIndex );
					if( iResult != CHANNEL_INVITE_OK )
					{
						SP2Packet kPacket( STPK_CHANNEL_INVITE );
						kPacket << iResult << dwIndex << pChannel->GetManToManID();
						SendMessage( kPacket );
						pChannel->SetManToManID( "" );
					}
					else
					{
						pUser->EnterChannel( pChannelParent );
					}

					// 채팅 전송
					SP2Packet kPacket( STPK_CHANNEL_CHAT );
					kPacket << dwIndex << GetPublicID() << szChat;
					pChannelParent->SendPacketTcp( kPacket, GetUserIndex() );	
				}
				else    //원본 유저에게 보낸 후 처리
				{
					UserCopyNode *pCopyNode = (UserCopyNode*)pUserParent;
					SP2Packet kPacket( SSTPK_CHANNEL_CHAT );
					kPacket << CHAT_CHANNEL_MANTOMAN_TRANSFER << dwIndex << pCopyNode->GetUserIndex() << GetPublicID() << szChat << GetUserIndex();
					pCopyNode->SendMessage( kPacket );			
				}
			}
		}		
		else
		{
			// 원본 채널로 먼저 보낸다.
			ChannelCopyNode *pCopyNode = (ChannelCopyNode*)pChannelParent;
			SP2Packet kPacket( SSTPK_CHANNEL_CHAT );
			kPacket << CHAT_CHANNEL_TRANSFER << dwIndex << GetPublicID() << szChat << GetUserIndex();
			pCopyNode->SendMessage( kPacket );			
		}
	}
	else
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnChannelChat 없는 채널에 채팅 보냄 %d", dwIndex );
}

void User::OnUserInfoRefresh( SP2Packet &rkPacket )
{
	ioHashString szUserID;
	rkPacket >> szUserID;
	
	UserParent *pUserInfo = g_UserNodeManager.GetGlobalUserNode( szUserID );
	if( pUserInfo )
	{
		if( pUserInfo->IsUserOriginal() )
		{
			User *pUser = (User*)pUserInfo;
			
			// 툴팁 정보
			SP2Packet kPacket( STPK_USER_INFO_REFRESH );
			pUser->FillToolTipInfo( kPacket );
			SendMessage( kPacket );			
			
			// 길드 정보
			ioUserGuild *pUserGuild = pUser->GetUserGuild();
			if( pUserGuild )
			{
				// 유저에게 전송
				SP2Packet kPacket( STPK_GUILD_SIMPLE_DATA );
				kPacket << szUserID << pUserGuild->GetGuildIndex() << pUserGuild->GetGuildName() << pUserGuild->GetGuildMark();
				SendMessage( kPacket );
			}			
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserInfo;
			SP2Packet kPacket( SSTPK_USER_INFO_REFRESH );
			kPacket << pUser->GetUserIndex() << GetUserIndex();
			pUser->SendMessage( kPacket );
		}
	}
	else        //오프라인 유저면 길드 인덱스를 가져온다.
	{
		g_DBClient.OnSelectGuildSimpleData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), szUserID );
	}
}

void User::OnSimpleUserInfoRefresh( SP2Packet &rkPacket )
{
	ioHashString szUserID;
	//rkPacket >> szUserID;
	PACKET_GUARD_VOID( rkPacket.Read( szUserID ) );

	UserParent *pUserInfo = g_UserNodeManager.GetGlobalUserNode( szUserID );
	if( !pUserInfo )
	{
		// 미접속 유저 
		SP2Packet kPacket( STPK_SIMPLE_USER_INFO_REFRESH );
		//kPacket << szUserID;
		PACKET_GUARD_VOID( rkPacket.Write( szUserID ) );
		SendMessage( kPacket );			
		return;
	}
	
	if( pUserInfo->IsUserOriginal() )
	{
		User *pUser = (User*)pUserInfo;
		
		SP2Packet kPacket( STPK_SIMPLE_USER_INFO_REFRESH );
		pUser->FillSimpleToolTipInfo( kPacket );
		SendMessage( kPacket );			
	}
	else
	{
		UserCopyNode *pUser = (UserCopyNode*)pUserInfo;
		SP2Packet kPacket( SSTPK_SIMPLE_USER_INFO_REFRESH );
		kPacket << pUser->GetUserIndex() << GetUserIndex();
		pUser->SendMessage( kPacket );
	}
}

void User::OnUserCharInfoRefresh( SP2Packet &rkPacket )
{
	ioHashString kTargetID;
	PACKET_GUARD_VOID( rkPacket.Read(kTargetID) );
	
	UserParent *pUserInfo = g_UserNodeManager.GetGlobalUserNode( kTargetID );
	if( pUserInfo )
	{
		int iStartArray = 0, iSyncCount = 0;
		PACKET_GUARD_VOID( rkPacket.Read(iStartArray) );
		PACKET_GUARD_VOID( rkPacket.Read(iSyncCount) );
		MAX_GUARD(iStartArray, 300);
		MAX_GUARD(iSyncCount, 50);

		if( pUserInfo->IsUserOriginal() )
		{
			User *pUser = (User*)pUserInfo;
			SP2Packet kPacket( STPK_USER_CHAR_INFO_REFRESH );
			pUser->FillUserCharListInfo( kPacket, iStartArray, iSyncCount );
			SendMessage( kPacket );
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserInfo;
			SP2Packet kPacket( SSTPK_USER_CHAR_INFO_REFRESH );
			PACKET_GUARD_VOID( kPacket.Write(pUser->GetUserIndex()) );
			PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
			PACKET_GUARD_VOID( kPacket.Write(iStartArray) );
			PACKET_GUARD_VOID( kPacket.Write(iSyncCount) );
			pUser->SendMessage( kPacket );
		}
	}
}

void User::OnUserCharSubInfoRefresh( SP2Packet &rkPacket )
{
	ioHashString kTargetID;
	rkPacket >> kTargetID;

	UserParent *pUserInfo = g_UserNodeManager.GetGlobalUserNode( kTargetID );
	if( pUserInfo )
	{
		int iClassType;
		rkPacket >> iClassType;

		if( pUserInfo->IsUserOriginal() )
		{
			User *pUser = (User*)pUserInfo;
			SP2Packet kPacket( STPK_USER_CHAR_SUB_INFO_REFRESH );
			pUser->FillUserCharSubInfo( kPacket, iClassType );
			SendMessage( kPacket );
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserInfo;
			SP2Packet kPacket( SSTPK_USER_CHAR_SUB_INFO_REFRESH );
			kPacket << pUser->GetUserIndex() << GetUserIndex() << iClassType;
			pUser->SendMessage( kPacket );
		}
	}
}

void User::_OnUserCharRentalAgree( UserParent *pOwnerParent, const ioHashString &rkOwnerID, DWORD dwOwnerDBAgentID, const CHARACTER &rkCharInfo, RentalData &rkRentalData )
{
	if( GetCharCount() >= m_iCurMaxCharSlot )
	{
		if( pOwnerParent )
		{
			SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
			kPacket << USER_CHAR_RENTAL_AGREE_NONE_SLOT << rkCharInfo.m_class_type;
			pOwnerParent->RelayPacket( kPacket );    
		}
		g_DBClient.OnUpdateCharRentalTime( dwOwnerDBAgentID, rkOwnerID.GetHashCode(), rkRentalData.m_dwCharIndex, 0 );
		return;
	}

	if( IsCharClassType( rkCharInfo.m_class_type ) )
	{
		if( pOwnerParent )
		{
			SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
			kPacket << USER_CHAR_RENTAL_AGREE_CHAR_SAME << rkCharInfo.m_class_type;
			pOwnerParent->RelayPacket( kPacket );    
		}
		g_DBClient.OnUpdateCharRentalTime( dwOwnerDBAgentID, rkOwnerID.GetHashCode(), rkRentalData.m_dwCharIndex, 0 );
		return;
	}

	if( GetExerciseCharCount( EXERCISE_RENTAL ) >= Help::GetCharRentalCount() )
	{
		if( pOwnerParent )
		{
			SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
			kPacket << USER_CHAR_RENTAL_AGREE_ALREADY_LIMIT << rkCharInfo.m_class_type;
			pOwnerParent->RelayPacket( kPacket );    
		}
		g_DBClient.OnUpdateCharRentalTime( dwOwnerDBAgentID, rkOwnerID.GetHashCode(), rkRentalData.m_dwCharIndex, 0 );
		return;
	}

	for(int i = 0;i < (int)m_vLevelUpAndPresentCreateClass.size();i++)
	{
		if( m_vLevelUpAndPresentCreateClass[i] == rkCharInfo.m_class_type )
		{
			if( pOwnerParent )
			{
				SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
				kPacket << USER_CHAR_RENTAL_AGREE_CHAR_SAME << rkCharInfo.m_class_type;
				pOwnerParent->RelayPacket( kPacket );    
			}
			g_DBClient.OnUpdateCharRentalTime( dwOwnerDBAgentID, rkOwnerID.GetHashCode(), rkRentalData.m_dwCharIndex, 0 );
			return;
		}
	}

	SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
	kPacket << USER_CHAR_RENTAL_AGREE_REQUEST_OK << rkOwnerID;

	// 용병 정보
	ioCharacter *pCharacter = AddCharDataToPointer();
	if( pCharacter )
	{	
		m_CharRentalData.InsertRentalData( rkOwnerID, rkRentalData );

		CHARACTER kRentalCharInfo = rkCharInfo;
		kRentalCharInfo.m_iSlotIndex = -1;
		kRentalCharInfo.m_sLeaderType= CLT_GENERAL;
		kRentalCharInfo.m_sRentalType= CRT_GENERAL;
		kRentalCharInfo.m_chExerciseStyle = EXERCISE_RENTAL;
		kRentalCharInfo.m_dwRentalMinute  = Help::GetCharRentalMinute();

		pCharacter->SetCharInfo( rkRentalData.m_dwCharIndex , kRentalCharInfo, this, false );
		pCharacter->BackUp();
		CheckCharSlot( pCharacter );

		kPacket << pCharacter->GetCharIndex();
		kPacket << (CHARACTER)pCharacter->GetCharInfo();
		rkRentalData.FillData( kPacket );
	}
	//
	SendMessage( kPacket );

	if( m_pMyRoom )
		m_pMyRoom->OnModeCharInsert( this, pCharacter );

	g_LogDBClient.OnInsertChar( this, rkCharInfo.m_class_type, 0, 0, "", LogDBClient::CT_RENTAL );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s 로부터 %s가 %d 용병을 대여함", rkOwnerID.c_str(), GetPublicID().c_str(), rkCharInfo.m_class_type );

	if( pOwnerParent )
	{
		g_DBClient.OnInsertCharRentalHistory( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), pOwnerParent->GetUserIndex(), rkCharInfo.m_class_type );
	}
}

void User::OnUserCharRentalAgree( SP2Packet &rkPacket )
{
	ioHashString kTargetID;
	rkPacket >> kTargetID;

	RentalData kRentalData;
	kRentalData.ApplyData( rkPacket );
	ioCharacter *pCharacter = GetCharacter( GetCharArray( kRentalData.m_dwCharIndex ) );
	if( pCharacter == NULL )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
		kPacket << USER_CHAR_RENTAL_AGREE_NONE_CHAR;
		SendMessage( kPacket );
		return;
	}

	if( pCharacter->GetRentalType() != CRT_RENTAL )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
		kPacket << USER_CHAR_RENTAL_AGREE_NONE_RENTAL;
		SendMessage( kPacket );
		return;
	}

	if( pCharacter->GetRentalLimitTime() != 0 )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
		kPacket << USER_CHAR_RENTAL_AGREE_ALREADY_LIMIT;
		SendMessage( kPacket );
		return;
	}

	const CHARACTER &rkCharInfo = pCharacter->GetCharInfo();
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kTargetID );
	if( !pUserParent )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
		kPacket << USER_CHAR_RENTAL_AGREE_NONE_USER << rkCharInfo.m_class_type;
		SendMessage( kPacket );
	}
	else
	{
		// 먼저 대여중 시간 적용 - 상대방이 대여 실패할 경우 반환
		pCharacter->SetRentalLimitTime( Help::GetCharRentalMinute() );
		pCharacter->CheckRentalLimitTime();

		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_AGREE );
		kPacket << USER_CHAR_RENTAL_AGREE_OK << rkCharInfo.m_class_type;
		SendMessage( kPacket );

		if( pUserParent->IsUserOriginal() )
		{
			User *pUser = static_cast< User * >( pUserParent );
			pUser->_OnUserCharRentalAgree( this, GetPublicID(), GetUserDBAgentID(), rkCharInfo, kRentalData );
		}
		else
		{
			CHARACTER kCharInfo = rkCharInfo;
			UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );
			SP2Packet kPacket( SSTPK_USER_CHAR_RENTAL_AGREE );
			kPacket << pUser->GetPublicID() << GetPublicID() << GetUserDBAgentID() << kCharInfo;
			kRentalData.FillData( kPacket );
			pUser->SendMessage( kPacket );
		}
	}
}

void User::OnUserCharRentalTimeEnd( SP2Packet &rkPacket )
{
	DWORD dwCharIndex;
	rkPacket >> dwCharIndex;

	ioCharacter *pCharacter = GetCharacter( GetCharArray( dwCharIndex ) );
	if( pCharacter )
	{
		pCharacter->CheckRentalLimitTime();			
		DWORD dwRentalTime = pCharacter->GetRentalLimitTime();
		pCharacter->SetRentalLimitTime( 0 );

		if( pCharacter->HasExerciseStyle( EXERCISE_RENTAL ) )
		{
			if( m_pMyRoom == NULL )
			{
				// 룸에 없으면 즉시 삭제 
				CheckExerciseRentalCharDeleteTime();
			}
			else
			{
				// 주인에게는 일단 반납
				RentalData &rkRentalData = m_CharRentalData.GetRentalData( pCharacter->GetCharIndex() );
				if( rkRentalData.m_dwCharIndex == pCharacter->GetCharIndex() )
				{
					UserParent *pOnwerParent = g_UserNodeManager.GetGlobalUserNode( rkRentalData.m_szOwnerName );
					if( pOnwerParent )
					{
						SP2Packet kPacket( STPK_USER_CHAR_RENTAL_RETURN );

						PACKET_GUARD_VOID( kPacket.Write(pCharacter->GetCharIndex()) );
						PACKET_GUARD_VOID( kPacket.Write(pCharacter->GetCharInfo().m_class_type) );

						pOnwerParent->RelayPacket( kPacket );
					}
					g_DBClient.OnUpdateCharRentalTime( GetUserDBAgentID(), GetAgentThreadID(), pCharacter->GetCharIndex(), 0 );
				}
			}
		}
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnUserCharRentalTimeEnd : %s - %d - %d", GetPublicID().c_str(), dwCharIndex, dwRentalTime );
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnUserCharRentalTimeEnd None Char : %s - %d", GetPublicID().c_str(), dwCharIndex );
	}	
}

void User::OnUserCharRentalRequest( SP2Packet &rkPacket )
{
	ioHashString kTargetID;
	rkPacket >> kTargetID;

	int iClassType;
	rkPacket >> iClassType;
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kTargetID );
	if( pUserParent == NULL )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_REQUEST );
		kPacket << USER_CHAR_RENTAL_REQUEST_OFFLINE << kTargetID;
		SendMessage( kPacket );      
		return;
	}

	if( pUserParent->IsBestFriend( GetUserIndex() ) == false )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_REQUEST );
		kPacket << USER_CHAR_RENTAL_REQUEST_NONE_BF << kTargetID;
		SendMessage( kPacket );    
		return;
	}

	if( IsCharClassType( iClassType ) )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_REQUEST );
		kPacket << USER_CHAR_RENTAL_REQUEST_CHAR_SAME << kTargetID << iClassType;
		SendMessage( kPacket );    
		return;
	}

	if( GetExerciseCharCount( EXERCISE_RENTAL ) >= Help::GetCharRentalCount() )
	{
		SP2Packet kPacket( STPK_USER_CHAR_RENTAL_REQUEST );
		kPacket << USER_CHAR_RENTAL_REQUEST_ONE_DAY_LIMIT << kTargetID;
		SendMessage( kPacket );    
		return;
	}
	g_DBClient.OnSelectCharRentalHistory( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetUserIndex(), kTargetID, iClassType );
}

void User::OnUserInfoExist( SP2Packet &rkPacket )
{
	ioHashString szFindID;
	rkPacket >> szFindID;
	
	if( !g_App.IsRightID( szFindID.c_str() ) )
	{
		SP2Packet kPacket( STPK_USER_INFO_EXIST );
		kPacket << USER_INFO_EXIST_NO;
		SendMessage( kPacket );
		return;
	}

	UserParent *pUserInfo = g_UserNodeManager.GetGlobalUserNode( szFindID );
	if( pUserInfo )
	{
		SP2Packet kPacket( STPK_USER_INFO_EXIST );
		kPacket << USER_INFO_EXIST_ONLINE;
		SendMessage( kPacket );
	}
	else //오프라인 유저면 존재하는 유저인지 확인.
	{
		g_DBClient.OnSelectUserExist( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), szFindID );
	}
}

void User::OnLadderTeamList( SP2Packet &rkPacket )
{
	bool bHeroMatch = false;
	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	PACKET_GUARD_VOID( rkPacket.Read(bHeroMatch) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_LadderTeamManager.SendCurLadderTeamList( this, iCurPage, iMaxCount, bHeroMatch );
}

void User::OnCreateLadderTeam( SP2Packet &rkPacket )
{
	if( IsReserveBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"타서버에 전투방을 예약 생성한 유저가 래더팀 생성 요청 :%s",GetPublicID().c_str());
		return;
	}
	else if( IsReserveLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"타서버에 래더팀을 예약 생성한 유저가 래더팀 생성 요청 :%s",GetPublicID().c_str());
		return;
	}

	if( GetUserCampPos() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateLadderTeam : 진영이 없는 유저가 래더팀 생성 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
		kPacket << LADDERTEAM_CREATE_NOT;
		SendMessage( kPacket );
		return;
	}
	else if( IsBattleRoom() || IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateLadderTeam : 이미 파티에있는 유저가 래더팀 생성 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
		kPacket << LADDERTEAM_CREATE_NOT;
		SendMessage( kPacket );
		return;
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateLadderTeam : 이미 룸에있는 유저가 래더팀 생성 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
		kPacket << LADDERTEAM_CREATE_NOT;
		SendMessage( kPacket );
		return;
	}
	else if( GetBuyCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnCreateLadderTeam : 구입 용병이 없는 유저가 래더팀 생성 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
		kPacket << LADDERTEAM_CREATE_NOT;
		SendMessage( kPacket );
		return;
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateLadderTeam : 임시가입만료 유저가 래더팀 생성 :%s", GetPublicID().c_str() );
		SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
		kPacket << LADDERTEAM_CREATE_NOT;
		SendMessage( kPacket );
		return;
	}
	else if( !g_LadderTeamManager.IsCampBattlePlay() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateLadderTeam : 진영전 휴식 기간 :%s", GetPublicID().c_str() );
		SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
		kPacket << LADDERTEAM_CREATE_CAMP_END;
		SendMessage( kPacket );
		return;
	}

	DWORD dwJoinGuildIndex;
	int iModeSelectType, iLadderMaxPlayer;
	ioHashString szTeamName, szPassword;
	bool bHeroMatchMode;
	rkPacket >> iModeSelectType >> szTeamName >> szPassword >> iLadderMaxPlayer >> dwJoinGuildIndex >> bHeroMatchMode;

	int iLadderTeamCount = 0;
	if( bHeroMatchMode )
	{
		iLadderTeamCount = g_LadderTeamManager.GetHeroNodeSize();

		if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN )
		{
			//래더전인 경우만 DB에서 select 
			//아래 말고 밑에 함수 거침
			DWORD dwServerIndex = 0;

			bool bResult = g_ServerNodeManager.GetSelectLadderTeamServer( iLadderTeamCount, bHeroMatchMode, dwServerIndex );
			if( bResult )
			{
				m_ladderList.clear(); 		//DB에서 
				g_DBClient.OnGetLadderUserList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), Help::GetLaddeLimitTime(), dwServerIndex, szTeamName, szPassword, iLadderMaxPlayer, dwJoinGuildIndex, iModeSelectType, bHeroMatchMode );		
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCreateLadderTeam() %d Get Ladder User List", GetUserIndex() );
			}
			else
			{
				SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
				kPacket << LADDERTEAM_CREATE_NOT;
				SendMessage( kPacket );
			}
			return;
		}

	}
	else
	{
		iLadderTeamCount = g_LadderTeamManager.GetNodeSize() - g_LadderTeamManager.GetHeroNodeSize();
	}

	DWORD dwServerIndex = 0;
	bool bResult = g_ServerNodeManager.GetSelectLadderTeamServer( iLadderTeamCount, bHeroMatchMode, dwServerIndex );
	if( bResult )
	{
		if( 0 == dwServerIndex )  // 현재 서버에 방을 생성한다
		{
			LadderTeamNode *pLadderTeam = g_LadderTeamManager.CreateNewLadderTeam();
			if( pLadderTeam )
			{	
				pLadderTeam->SetCampType( GetUserCampPos() );
				pLadderTeam->SetTeamName( szTeamName );
				pLadderTeam->SetTeamPW( szPassword );
				pLadderTeam->SetMaxPlayer( iLadderMaxPlayer );
				pLadderTeam->SetJoinGuildIndex( dwJoinGuildIndex );
				pLadderTeam->SelectMode( iModeSelectType );
				pLadderTeam->SetHeroMatchMode( bHeroMatchMode );
				pLadderTeam->SetUserIndex( GetUserIndex() );
				//
				EnterLadderTeam( pLadderTeam );
				return;
			}
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateLadderTeam : Empty :%d", g_LadderTeamManager.GetNodeSize() );
		}
		else
		{
			ServerNode* pSelectServer = g_ServerNodeManager.GetServerNode( dwServerIndex );
			if( pSelectServer )      
			{
				// 타서버에서 길드팀 생성하라
				SP2Packet kPacket( SSTPK_RESERVE_CREATE_LADDERTEAM );
				kPacket << GetUserIndex() << GetUserCampPos() << iModeSelectType << szTeamName << szPassword << iLadderMaxPlayer << dwJoinGuildIndex << bHeroMatchMode;

				if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN )
				{
					int iSize = 0;
					iSize = m_ladderList.size();
					if( bHeroMatchMode == true )
					{
						kPacket << iSize;		//전투했던 유저수
						if( iSize != 0 ) 
						{
							for( int i = 0; i< iSize; i++ )
							{
								kPacket << m_ladderList[i];
							}
						}
					}
				}

				pSelectServer->SendMessage( kPacket );
				ReserveLadderTeam( true );
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCreateLadderTeam Create : %s:%d", pSelectServer->GetServerIP().c_str(), pSelectServer->GetClientPort() );
				return;
			}
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateLadderTeam : Not Found" );
		}
	}
					
	SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
	kPacket << LADDERTEAM_CREATE_NOT;
	SendMessage( kPacket );
}

//HRYOON LADDER 20150623 
//래더전 진입
void User::OnCreateHeroMatchLadderTeam( ioHashString szTeamName, ioHashString szPassword, int iladderMaxPlayer, int ijoinguildIndex, int imodeSelectType, bool mode )
{
	int iLadderTeamCount = 0;
	iLadderTeamCount = g_LadderTeamManager.GetHeroNodeSize();

	DWORD dwServerIndex = 0;
	bool bResult = g_ServerNodeManager.GetSelectLadderTeamServer( iLadderTeamCount, true, dwServerIndex );
	if( bResult )
	{
		if( 0 == dwServerIndex )  // 현재 서버에 방을 생성한다
		{
			LadderTeamNode *pLadderTeam = g_LadderTeamManager.CreateNewLadderTeam();
			if( pLadderTeam )
			{	
				pLadderTeam->SetCampType( GetUserCampPos() );
				pLadderTeam->SetTeamName( szTeamName );
				pLadderTeam->SetTeamPW( szPassword );
				pLadderTeam->SetMaxPlayer( iladderMaxPlayer );
				pLadderTeam->SetJoinGuildIndex( ijoinguildIndex );
				pLadderTeam->SelectMode( imodeSelectType );
				pLadderTeam->SetHeroMatchMode( mode );

				// 진영전 일경우에만 ..
				if( mode == true ) 
				{
					pLadderTeam->SetUserIndex( GetUserIndex() );		//자신의 UserIndex값을 저장
					// 목록 초기화 후 복사 진행
					pLadderTeam->ClearLadderUser();
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"[Ladder User List Clear] userIndex : %d", GetUserIndex() );
					pLadderTeam->ladderUserCopy( m_ladderList );	// 래더전 00 분내에 전투했던 유저인덱스 저장
					pLadderTeam->SetCompetitorIndex(0);
				}
				//

				EnterLadderTeam( pLadderTeam );
				return;
			}
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateLadderTeam : Empty :%d", g_LadderTeamManager.GetNodeSize() );
		}
		else
		{
			ServerNode* pSelectServer = g_ServerNodeManager.GetServerNode( dwServerIndex );
			if( pSelectServer )      
			{
				// 타서버에서 길드팀 생성하라
				int iSize = 0;
				iSize = m_ladderList.size();
				SP2Packet kPacket( SSTPK_RESERVE_CREATE_LADDERTEAM );
				kPacket << GetUserIndex() << GetUserCampPos() << imodeSelectType << szTeamName << szPassword << iladderMaxPlayer << ijoinguildIndex << mode;
				if( mode == true )
				{
					kPacket << iSize;		//전투했던 유저수
					if( iSize != 0 ) 
					{
						for( int i = 0; i< iSize; i++ )
						{
							kPacket << m_ladderList[i];		//DB에서 가져온 유저수만큼 저장
						}
					}
				}

				pSelectServer->SendMessage( kPacket );
				ReserveLadderTeam( true );
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCreateLadderTeam Create : %s:%d", pSelectServer->GetServerIP().c_str(), pSelectServer->GetClientPort() );
				return;
			}
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCreateLadderTeam : Not Found" );
		}
	}

	SP2Packet kPacket( STPK_CREATE_LADDERTEAM );
	kPacket << LADDERTEAM_CREATE_NOT;
	SendMessage( kPacket );
}

void User::OnJoinLadderTeam( SP2Packet &rkPacket )
{
	if( IsReserveBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"타서버에 전투방을 예약 생성한 유저가 길드팀 입장 요청 :%s",GetPublicID().c_str());
		return;
	}
	else if( IsReserveLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"타서버에 길드팀을 예약 생성한 유저가 길드팀 입장 요청 :%s",GetPublicID().c_str());
		return;
	}

	if( GetUserCampPos() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnJoinLadderTeam : 진영이 없는 유저가 래더팀 입장 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
		kPacket << LADDERTEAM_JOIN_NOT_CAMP;
		SendMessage( kPacket );
	}
	else if( IsBattleRoom() || IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnJoinLadderTeam : 이미 파티에있는 유저가 길드팀 입장 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
		kPacket << LADDERTEAM_JOIN_ALREADY_TEAM;
		SendMessage( kPacket );
	}
	else if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnJoinLadderTeam : 이미 룸에있는 유저가 길드팀 입장 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
		kPacket << LADDERTEAM_JOIN_ALREADY_ROOM;
		SendMessage( kPacket );
	}
	else if( GetBuyCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"OnJoinLadderTeam : 구입 용병이 없는 유저가 길드팀 입장 :%s",GetPublicID().c_str());
		SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
		kPacket << LADDERTEAM_JOIN_NOT_CHAR;
		SendMessage( kPacket );
	}
	else if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnJoinLadderTeam : 임시가입만료 유저가 길드팀 입장 :%s", GetPublicID().c_str() );
		SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
		kPacket << LADDERTEAM_JOIN_FORMALITY;
		SendMessage( kPacket );
	}
	else if( !g_LadderTeamManager.IsCampBattlePlay() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnJoinLadderTeam : 진영전 휴식 기간 :%s", GetPublicID().c_str() );
		SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
		kPacket << LADDERTEAM_JOIN_CAMP_END;
		SendMessage( kPacket );
	}
	else
	{
		DWORD dwIndex;
		bool  bInvited;
		ioHashString szPassword;
		rkPacket >> dwIndex >> bInvited >> szPassword;

		LadderTeamParent *pLadderTeam = g_LadderTeamManager.GetGlobalLadderTeamNode( dwIndex ); 
		if( pLadderTeam )
		{
			bool bGuildTeam = false;
			if( pLadderTeam->IsGuildTeam() && pLadderTeam->GetGuildIndex() == GetGuildIndex() )
			{
				bGuildTeam = true;
			}
		
			if( pLadderTeam->IsMatchPlay() )
			{
				//모드 플레이중
				SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
				kPacket << LADDERTEAM_JOIN_MATCH_PLAY;
				SendMessage( kPacket );
			}
			else if( pLadderTeam->IsFull() )
			{
				//인원 초과
				SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
				kPacket << LADDERTEAM_JOIN_FULL;
				SendMessage( kPacket );
			}
			else if( pLadderTeam->GetCampType() != GetUserCampPos() )
			{
				//입장하려는 팀의 진영이 다름
				SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
				kPacket << LADDERTEAM_JOIN_NOT_CAMP;
				SendMessage( kPacket );
			}
//			else if( !bInvited && !IsDeveloper() && !bGuildTeam && !g_LevelMatchMgr.IsLadderLevelJoin( pLadderTeam->GetAbilityMatchLevel(), GetKillDeathLevel(), JOIN_CHECK_MIN_LEVEL ) )
//			{
//				SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
//				kPacket << LADDERTEAM_JOIN_NOT_LEVELMATCH;
//				SendMessage( kPacket );
//			}
			else if( pLadderTeam->GetPW() != szPassword && !IsDeveloper() )
			{
				//비밀번호 다름
				SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
				kPacket << LADDERTEAM_JOIN_MISS_PASSWORD;
				SendMessage( kPacket );
			}
			else
			{
				EnterLadderTeam( pLadderTeam );
			}
		}
		else
		{
			// 없음
			SP2Packet kPacket( STPK_JOIN_LADDERTEAM );
			kPacket << LADDERTEAM_JOIN_NOT_LADDERTEAM;
			SendMessage( kPacket );
		}
	}
}

void User::OnLadderTeamJoinInfo( SP2Packet &rkPacket )
{
	DWORD dwTeamIndex;
	rkPacket >> dwTeamIndex;	
	g_LadderTeamManager.SendLadderTeamJoinInfo( (UserParent*)this, dwTeamIndex );
}

void User::OnLadderTeamLeave( SP2Packet &rkPacket )
{
	LeaveLadderTeam();

	SP2Packet kPacket( STPK_LADDERTEAM_LEAVE );

	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

	SendMessage( kPacket );

	// 서버에서의 룸 입장과 유저의 이탈이 서로 타이밍이 안맞으면 룸에서 이탈시킨다.
	if( m_pMyRoom && m_pMyRoom->GetRoomStyle() == RSTYLE_LADDERBATTLE )
	{
		LeaveRoom();

		SP2Packet kPacket( STPK_EXIT_ROOM );
		kPacket << EXIT_ROOM_OK;
		kPacket << -1;
		kPacket << false;
		SendMessage( kPacket );
	}
}

void User::OnLadderTeamInviteList( SP2Packet &rkPacket )
{
	LadderTeamParent *pLadderTeam = GetMyLadderTeam();
	if( !pLadderTeam ) return;

	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_UserNodeManager.SendLadderTeamInviteList( this, iCurPage, iMaxCount );
}

void User::OnLadderOtherTeamNameChange( SP2Packet &rkPacket )
{
	if( !IsLadderTeam() ) return;

	DWORD dwTeamIndex;
	ioHashString szTeamName;
	rkPacket >> dwTeamIndex >> szTeamName;

	LadderTeamParent *pLadderTeam = g_LadderTeamManager.GetGlobalLadderTeamNode( dwTeamIndex );
	if( pLadderTeam )
	{
		SP2Packet kPacket( STPK_LADDER_OTHER_NAME_CHANGE );
		kPacket << m_dwMyLadderTeam << szTeamName;

		pLadderTeam->SendPacketTcp( kPacket );
	}
}

void User::OnLadderBattleRequestAgree( SP2Packet &rkPacket )
{
	/*래더팀으로 인해 삭제됨*/
}

void User::OnLadderUserHQMove( SP2Packet &rkPacket )
{
	// 본부로 이동시킨다.
	LeaveRoom();

	SP2Packet kPacket( STPK_LADDER_USER_HQ_MOVE );
	SendMessage( kPacket );
}

void User::OnLadderTeamRanking( SP2Packet &rkPacket )
{
	DWORD dwTeamIndex;
	rkPacket >> dwTeamIndex;

	LadderTeamParent *pLadderTeam = g_LadderTeamManager.GetGlobalLadderTeamNode( dwTeamIndex );
	if( pLadderTeam )
	{
		if( pLadderTeam->GetTeamRanking() == -1 )
			g_LadderTeamManager.SortLadderTeamRank( pLadderTeam->IsHeroMatchMode() );   //랭킹 정렬이 되지 않았..

		SP2Packet kPacket( STPK_LADDER_TEAM_RANKING );
		kPacket << pLadderTeam->GetIndex() << pLadderTeam->GetTeamRanking();     
		SendMessage( kPacket );
	}
}

void User::OnLadderTeamRankList( SP2Packet &rkPacket )
{
	bool bHeroMatch = false;
	DWORD dwTeamIndex = 0;
	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(dwTeamIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	PACKET_GUARD_VOID( rkPacket.Read(bHeroMatch) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_LadderTeamManager.SortLadderTeamRank( bHeroMatch, this, dwTeamIndex, iCurPage, iMaxCount );
}

void User::OnMovieControl( SP2Packet &rkPacket )
{
	int iMovieCommand;
	rkPacket >> iMovieCommand;
	switch( iMovieCommand )
	{
	case MOVIE_CAPTURE_START:
		m_bMovieCapturing = true;
		break;
	case MOVIE_CAPTURE_CUT:
		m_bMovieCapturing = false;
		break;
	}

	// 방안 유저들 동기화
	if( m_pMyRoom )
	{
		SP2Packet kPacket( STPK_MOVIE_CONTROL );
		kPacket << iMovieCommand << GetPublicID();
		m_pMyRoom->RoomSendPacketTcp( kPacket, this );
	}
}

void User::_OnSelectPresent( DWORD dwSelectCount )
{
	g_DBClient.OnSelectPresentData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_UserPresent.GetLastPresentDBIndex(), dwSelectCount );
}

void User::OnPresentRequest( SP2Packet &rkPacket )
{
	DWORD dwRequestCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(dwRequestCount) );
	MAX_GUARD(dwRequestCount, 201);

	_OnSelectPresent( dwRequestCount );

	// 기간 지난 선물 삭제
	m_UserPresent.CheckPresentLimitDate();
}

void User::OnPresentRecv( SP2Packet &rkPacket )
{
	SP2Packet kPacket( STPK_PRESENT_RECV );
    if( m_UserPresent.PresentRecv( rkPacket, kPacket ) )
		SendMessage( kPacket );
}

void User::OnPresentSell( SP2Packet &rkPacket )
{
	DWORD dwPresentIndex, dwPresentSlotIndex;
	rkPacket >> dwPresentIndex >> dwPresentSlotIndex;

	SP2Packet kPacket( STPK_PRESENT_SELL );
	m_UserPresent.PresentSell( dwPresentIndex, dwPresentSlotIndex, kPacket );
	SendMessage( kPacket );
}

void User::PresendCashProcess(const int iPresentType, const int iBuyValue1, const int iBuyValue2, ioHashString szReceiverPublicID)
{
	if( szReceiverPublicID.IsEmpty() )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_ERROR_RECEIVERID;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s RecverID Error 1: %s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return;
	}

	if( !g_App.IsRightID( szReceiverPublicID.c_str() ) )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_ERROR_RECEIVERID;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s RecverID Error 2: %s:%d(%s)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szReceiverPublicID.c_str() );
		return;
	}

	if( _stricmp( GetPublicID().c_str(), szReceiverPublicID.c_str() )  == 0 )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_ERROR_RECEIVERID;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s RecverID Error 3: %s:%d(%s)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szReceiverPublicID.c_str() );
		return;
	}

	if( g_UserNodeManager.IsDeveloper( szReceiverPublicID.c_str() ) )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_ERROR_RECEIVERID;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s RecverID Error 4: %s:%d(%s)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szReceiverPublicID.c_str() );
		return;
	}

	//if( PRESENT_ETC_ITEM == iPresentType )
	//{
	//	//특별 상점 아이템 품목 확인
	//	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem(iBuyValue1);
	//	if( pEtcItem )
	//	{
	//		if( pEtcItem->IsSpecialGoods() )
	//		{
	//			SP2Packet kReturn( STPK_PRESENT_BUY );
	//			kReturn << PRESENT_BUY_DISABLE_SEND;
	//			SendMessage( kReturn );
	//			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][specialgoods] special goods is bought to gift" );
	//			return;
	//		}
	//	}
	//	else
	//	{
	//		SP2Packet kReturn( STPK_PRESENT_BUY );
	//		kReturn << PRESENT_BUY_ERROR_RECEIVERID;
	//		SendMessage( kReturn );
	//		return;
	//	}
	//}

	int iBuyCash = g_PresentHelper.GetCash( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBuyCash <= 0 )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error : %s:%d:%d:%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iPresentType, iBuyValue1, iBuyValue2 );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
		return;
	}

	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_PRESENT_BUY, PRESENT_BUY_WANT_OF_CASH, iPresentType, vConsumeInfo ) )
		return;

	g_DBClient.OnSelectUserIndexAndPresentCnt( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetUserIndex(), szReceiverPublicID, iPresentType, iBuyValue1, iBuyValue2 );
	
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, " %s Step 1 [%s:%d][%s:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szReceiverPublicID.c_str(), iPresentType, iBuyValue1, iBuyValue2 );
}

void User::OnPresentBuy( SP2Packet &rkPacket )
{
	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Billing Wait : %s:%d:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	short iPresentType   = 0;
	int   iBuyValue1     = 0;
	int   iBuyValue2     = 0;
	ioHashString szReceiverPublicID;

	PACKET_GUARD_VOID( rkPacket.Read(iPresentType) );
	PACKET_GUARD_VOID( rkPacket.Read(iBuyValue1) );
	PACKET_GUARD_VOID( rkPacket.Read(iBuyValue2) );
	PACKET_GUARD_VOID( rkPacket.Read(szReceiverPublicID) );

	if( PRESENT_ETC_ITEM == iPresentType )
	{
		//특별 상점 아이템 품목 확인
		ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem(iBuyValue1);
		if( pEtcItem )
		{
			if( pEtcItem->IsSpecialGoods() )
			{
				SpecialGoodsPresent(iPresentType, iBuyValue1, iBuyValue2, szReceiverPublicID);
				return;
			}
		}
		else
		{
			SP2Packet kReturn( STPK_PRESENT_BUY );
			PACKET_GUARD_VOID( kReturn.Write(PRESENT_BUY_ERROR_RECEIVERID) );
			SendMessage( kReturn );
			return;
		}
	}

	PresendCashProcess(iPresentType, iBuyValue1, iBuyValue2, szReceiverPublicID);
}

void User::_OnDBPresentBuy( DWORD dwRecvUserIndex, int iRecvPresentCnt, const char *szRecvPrivateID, const char *szRecvPublicID, short iPresentType, int iBuyValue1, int iBuyValue2 )
{
	
	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Billing Wait : %s:%d:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	if( dwRecvUserIndex == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Not ReceiverID : %s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_NOT_RECEIVERID;
		SendMessage( kReturn );
		return;
	}

	if( iRecvPresentCnt >= g_PresentHelper.GetCanPresentCnt() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Exeed present cnt : %s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iRecvPresentCnt );
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_EXCEED_PRESENT_CNT;
		SendMessage( kReturn );
		return;
	}

	int iBuyCash = g_PresentHelper.GetCash( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBuyCash <= 0 )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error : %s:%d:%d:%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iPresentType, iBuyValue1, iBuyValue2 );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
		return;
	}
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_PRESENT_BUY, PRESENT_BUY_WANT_OF_CASH, iPresentType, vConsumeInfo ) )
		return;

	int iSize	= vConsumeInfo.size();

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;
	SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
	kBillingPacket << (int) GetChannelingType();
	kBillingPacket << m_szBillingGUID;
	kBillingPacket << iBuyCash;
	kBillingPacket << GetUserIndex();
	kBillingPacket << GetPublicID();
	kBillingPacket << GetPrivateID();
	kBillingPacket << GetPublicIP();
	kBillingPacket << iBuyCash;

	PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
	for( int i = 0; i < iSize; i++ )
	{
		PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
		PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
	}

	kBillingPacket << OUTPUT_CASH_PRESENT;
	kBillingPacket << iPresentType;
	kBillingPacket << iBuyValue1;
	kBillingPacket << iBuyValue2;
	kBillingPacket << dwRecvUserIndex;

	if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_PRESENT_BUY, PRESENT_BUY_BILLING_FAIL, szRecvPrivateID, szRecvPublicID, dwRecvUserIndex) )
		return;

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
		pLocal->FillRequestOutputCash( this, kBillingPacket, szRecvPrivateID );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s:%d:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_DISCONNECT;
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
	}
	else
	{
		//[HRYOON구매] 유저 구매 중인 상태로 변경함
		SetOutputStatus( true );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::_OnDBPresentBuy Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]%s Step 3 : %s:%d:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), m_szBillingGUID.c_str(), iBuyCash );
	}
}

void User::OnMemoMsg( SP2Packet &rkPacket )
{
	ioHashString szToID, szMsg;
	rkPacket >> szToID >> szMsg;

	UserParent *pUser = g_UserNodeManager.GetGlobalUserNode( szToID );
	if( !pUser )    
	{
		//접속하지 않은 유저의 쪽지 보관
		MemoNode kMemo;
		kMemo.SetMemo( szToID, GetPublicID(), szMsg );
		g_MemoNodeManager.AddMemo( kMemo );
	}
	else
	{
		//쪽지 발송
		SYSTEMTIME st;
		GetLocalTime( &st );
		DWORD dwTime = (st.wMonth * 1000000) + (st.wDay * 10000) + (st.wHour * 100) + st.wMinute;

		SP2Packet kPacket( STPK_MEMO_SEND_MSG );
		kPacket << MEMO_SEND_MSG << GetPublicID() << szMsg << dwTime << true; 
		pUser->RelayPacket( kPacket );
	}
}

void User::OnVoiceInfo( SP2Packet &rkPacket )
{
	if( !m_pMyRoom ) return;
	if( !m_pMyRoom->IsNoBattleModeType() ) return;

	int iType;
	rkPacket >> iType;

	if( !COMPARE( iType, ID_VOICE_ON, ID_VOICE_OFF_ADD_TABLE + 1) ) return;

	ioHashString szReceiverID;
	rkPacket >> szReceiverID;

	SP2Packet kReturnPacket( STPK_VOICE_INFO );
	kReturnPacket << iType;
	kReturnPacket << GetPublicID();

	if( szReceiverID.IsEmpty() ) // ID가 비어 있으면 모두에게 전송
		m_pMyRoom->RoomSendPacketTcpExceptBattleRoomUser( kReturnPacket, this );
	else
	{
		User *pUser = m_pMyRoom->FindUserInRoom( szReceiverID );
		if( pUser && !pUser->IsBattleRoom() && !pUser->IsLadderTeam() )
			pUser->SendMessage( kReturnPacket );
	}

#ifdef _DEBUG
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s (%d:%s)%d | %s", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iType, szReceiverID.c_str() );
#endif
}

void User::OnOfflineMemoList( SP2Packet &rkPacket )
{
	int iServerArray = 0, iCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iServerArray) );
	PACKET_GUARD_VOID( rkPacket.Read(iCount) );
	MAX_GUARD(iServerArray, 100);
	MAX_GUARD(iCount, 100);

	if( iServerArray < g_ServerNodeManager.GetNodeSize() )
	{
		SP2Packet kPacket( SSTPK_OFFLINE_MEMO );
		PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
		PACKET_GUARD_VOID( kPacket.Write(iCount) );
		g_ServerNodeManager.SendMessageArray( iServerArray, kPacket );
	}
	else if( iServerArray == g_ServerNodeManager.GetNodeSize() )      //현재 서버 메모 전송
	{
		g_MemoNodeManager.SendMemo( this, iCount );
	}
}

void User::OnWebEvent( SP2Packet &rkPacket )
{
	int iEventType = 0;
	int iValue1    = 0;
	rkPacket >> iEventType;
	rkPacket >> iValue1;

	if( iEventType == EVT_COIN )
	{
		EventUserManager &rEventUserMgr =  GetEventUserMgr();
		int iTotalCoin = rEventUserMgr.GetValue( (EventType)iEventType, VA_COIN_CNT );
		iTotalCoin += iValue1;
		rEventUserMgr.SetValue( (EventType)iEventType, VA_COIN_CNT, iTotalCoin );
		EventLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEvent OK:%d:%s:%d:%d:%d", GetUserIndex(),GetPublicID().c_str(), iEventType, iValue1, iTotalCoin );
	}
	else
		EventLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEvent Wrong Type:%d:%s:%d:%d", GetUserIndex(),GetPublicID().c_str(), iEventType, iValue1 );
}

void User::OnWebRefreshBlock( SP2Packet &rkPacket )
{
	g_DBClient.OnSelectBlockType( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetUserIndex() );	
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
}

void User::OnWebGetCash( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnWebGetCash Billing Wait : %s:%s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		return;
	}


	
	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;

	SP2Packet kBillingPacket( BSTPK_GET_CASH );
	kBillingPacket << GetChannelingType();
	kBillingPacket << m_szBillingGUID;
	kBillingPacket << GetUserIndex();
	kBillingPacket << GetPrivateID();
	kBillingPacket << GetPublicID();
	kBillingPacket << false; // true : 유저 mouse를 unbusy로 만든다.

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnWebGetCash pNode == NULL : %s(%d)", GetPublicID().c_str(), GetUserIndex() );
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_EXCEPTION;
		kReturn << false; // bSetMouse;
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
		return;
	}

	if( !pNode->AddRequestGetCashPacket( this, kBillingPacket, STPK_GET_CASH, GET_CASH_BILLING_EXCEPTION ) )
		return;

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
		pLocal->FillRequestGetCash( this, kBillingPacket );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnWebGetCash Cash Send Fail : %s", GetPublicID().c_str() );
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_DISCONNECT;
		kReturn << false; // bSetMouse;
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
	}

	
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnWebGetCash : %s", GetPublicID().c_str() );
}


void User::OnProtectCheck( SP2Packet &rkPacket )
{
#ifdef XTRAP
	if( !g_ioXtrap.IsUse() )
		return;

	XtrapPacket kXtrapPacket;
	rkPacket >> kXtrapPacket;

	g_ioXtrap.Step3( m_XtrapSessionBuf, kXtrapPacket.m_XTrapPacket, GetPublicID().c_str(), GetPublicIP(), GetGradeLevel() );
#endif
#ifdef NPROTECT
	if( !g_ioNProtect.IsUse() )
	{
		LOG.PrintTimeAndLog(0, "%s : NOTUSE NPROTECT :%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return;
	}

#ifdef NPROTECT_CSAUTH3
	
	//LOG.PrintTimeAndLog(0, "%s : Recv :%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
	NProtectPacket kNProtectPacket;
	rkPacket >> kNProtectPacket;

	DWORD dwPacketSize = kNProtectPacket.m_dwStructSize-sizeof(DWORD);
	if( dwPacketSize > NProtectPacket::MAX_PACKET_BUF )
	{
		LOG.PrintTimeAndLog(0, "%s : Size Error : %d : %s:%d", __FUNCTION__, dwPacketSize, GetPublicID().c_str(), GetUserIndex() );
		ExceptionClose( 0 ); 
		return;
	}

	memcpy( m_NProtectAuth.packet, kNProtectPacket.m_byNProtectPacket, dwPacketSize );
	UINT32 uReturn = m_NProtectAuth.Check( dwPacketSize );
	if( uReturn >= 3000 )
	{
		SP2Packet kPacket( SUPK_PROTECT );
		kPacket << PROTECT_FAIL_NPROTECT_CHECK;
		g_UDPNode.SendMessage( GetPublicIP(), GetUDP_port(), kPacket );

		LOG.PrintTimeAndLog(0, "%s: Error :%d:%s:%d", __FUNCTION__, uReturn, GetPublicID().c_str(), GetUserIndex() );
		ExceptionClose( 0 ); 
		return;
	}

	/*if( m_iSentNProtectCheckCnt == 1 )
	{
		if( !SendNProtectCheck() )
		{
			LOG.PrintTimeAndLog(0, "%s : Send Error : %d : %s:%d", __FUNCTION__, uReturn, GetPublicID().c_str(), GetUserIndex() );
			ExceptionClose( 0 ); 
			return;
		}
	}*/
#else

	if( !m_pNProtectAuth )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : NULL : %s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return;
	}

	rkPacket >> m_pNProtectAuth->m_AuthAnswer;

	// try 사용할 수 없어 생략
	DWORD dwRet = m_pNProtectAuth->CheckAuthAnswer();

	if( dwRet != ERROR_SUCCESS )
	{
		SP2Packet kPacket( SUPK_PROTECT );
		kPacket << PROTECT_FAIL_NPROTECT_CHECK;
		g_UDPNode.SendMessage( GetPublicIP(), GetUDP_port(), kPacket );

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : Error : %d : %08x : %08x : %08x : %08x : %s:%d", __FUNCTION__, dwRet, m_pNProtectAuth->m_AuthAnswer.dwIndex, m_pNProtectAuth->m_AuthAnswer.dwValue1, m_pNProtectAuth->m_AuthAnswer.dwValue2, m_pNProtectAuth->m_AuthAnswer.dwValue3, GetPublicID().c_str(), GetUserIndex() );
		ExceptionClose( 0 );
		return;
	}

	if( m_iSentNProtectCheckCnt == 1 )
	{
		if( !SendNProtectCheck() )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : Send Error : %d : %s:%d", __FUNCTION__, dwRet, GetPublicID().c_str(), GetUserIndex() );
			ExceptionClose( 0 );
			return;
		}
	}
#endif

#endif // NPROTECT

#ifdef XIGNCODE
	if( !g_ioXignCode.IsUse() )
		return;

	XignCodePacket kPacket;
	rkPacket >> kPacket;
	g_ioXignCode.OnReceive( this, kPacket.m_XignCodePacket );
#endif
#ifdef HACKSHIELD
	if( !g_ioHackShield.IsUse() )
		return;

	AHNHS_TRANS_BUFFER kBuf;
	rkPacket >> kBuf;
	if( !g_ioHackShield.VerifyRespose( m_hHackShield, kBuf ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : Error : %s:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetPrivateID().c_str(), GetUserIndex() );
		ExceptionClose( 0 );
	}

#endif

#ifdef SRC_LATIN
	ApexPacket kBuf;
	rkPacket >> kBuf;

	if( kBuf.nType == APEX_CMD_DATA )
	{
		g_ioApex.NoticeApexProxy_UserData(GetUserIndex(), kBuf.byBuffer, kBuf.nLength);
	}

#endif
}

void User::OnRoomStealthEnter( SP2Packet &rkPacket )
{
	if( !IsDeveloper() )
	{
		SP2Packet kPacket( STPK_ROOM_STEALTH_ENTER );
		kPacket << ROOM_STEALTH_ENTER_EXCEPTION_DEVELOPER;
		SendMessage( kPacket );
	}
	else
	{
		ioHashString kSyncName;
		rkPacket >> kSyncName;

		UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kSyncName );
		if( pUserParent )
		{
			if( pUserParent->IsUserOriginal() )
			{
				User *pUser = static_cast< User * >( pUserParent );
				Room *pEnterRoom = pUser->GetMyRoom();
				if( pEnterRoom )
				{
					SP2Packet kPacket( STPK_ROOM_STEALTH_ENTER );
					kPacket << ROOM_STEALTH_ENTER_OK;
					SendMessage( kPacket );

					LeaveRoom();
					// 스텔스 입장 시도
					m_bStealth = true;
					SP2Packet kPacket1( STPK_MOVING_ROOM );
					kPacket1 << pEnterRoom->GetModeType();
					kPacket1 << pEnterRoom->GetModeSubNum();
					kPacket1 << pEnterRoom->GetModeMapNum();
					kPacket1 << (int)pEnterRoom->GetPlazaModeType();
					SendMessage( kPacket1 );
					EnterRoom( pEnterRoom );
				}
				else
				{
					SP2Packet kPacket( STPK_ROOM_STEALTH_ENTER );
					kPacket << ROOM_STEALTH_ENTER_EXCEPTION_EXITUSER;
					SendMessage( kPacket );
				}
			}
			else
			{
				ServerNode *pServerNode = g_ServerNodeManager.GetUserIndexToServerNode( pUserParent->GetUserIndex() );
				if( pServerNode )
				{
					SP2Packet kPacket( STPK_ROOM_STEALTH_ENTER );
					kPacket << ROOM_STEALTH_ENTER_DIFFERENT_CHANNEL << pServerNode->GetServerIndex();
					SendMessage( kPacket );
				}
				else
				{
					SP2Packet kPacket( STPK_ROOM_STEALTH_ENTER );
					kPacket << ROOM_STEALTH_ENTER_EXCEPTION_EXITUSER;
					SendMessage( kPacket );
				}				
			}
		}
		else
		{
			SP2Packet kPacket( STPK_ROOM_STEALTH_ENTER );
			kPacket << ROOM_STEALTH_ENTER_EXCEPTION_EXITUSER;
			SendMessage( kPacket );
		}
	}
}

void User::OnCampSeasonBonus( SP2Packet &rkPacket )
{
	// 시즌 보상 있는지 확인
	g_DBClient.OnSelectCampSeasonBonus( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex() );
}

void User::OnWebRefreshUserEntry( SP2Packet &rkPacket )
{
	g_DBClient.OnSelectUserEntry( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID() , GetUserIndex() );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnWebRefreshUserEntry : %s", GetPublicID().c_str() );
}

void User::OnGetCash( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN ||
			ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
		{
			//[HRYOON구매]
			if(GetOutputStatus() == true)
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnGetCash Pass. User Buying...  : PrivateID %s:%s:%s", GetPrivateID().c_str(), GetPublicID().c_str(), m_szBillingGUID.c_str() );
				return;
			}
			else
			{
				//구매중이 아닌경우에만 
				ClearBillingGUID();
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGetCash Billing Wait GUID Clear : PrivateID %s:%s:%s", GetPrivateID().c_str(), GetPublicID().c_str(), m_szBillingGUID.c_str() );
				return;
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGetCash Billing Wait : PrivateID %s:%s:%s", GetPrivateID().c_str(), GetPublicID().c_str(), m_szBillingGUID.c_str() );

			SP2Packet kReturn( STPK_GET_CASH );
			kReturn << GET_CASH_BILLING_WAIT;
			kReturn << true; // bSetMouse;
			SendMessage( kReturn );

			return;
		}
	}

	g_DBClient.OnDeleteExpirationBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex());// 기간 만료된 보너스 캐쉬 만료상태로 변경

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;

	_OnSelectPresent(30);

	SP2Packet kBillingPacket( BSTPK_GET_CASH );
	kBillingPacket << GetChannelingType();
	kBillingPacket << m_szBillingGUID;
	kBillingPacket << GetUserIndex();
	kBillingPacket << GetPrivateID();
	kBillingPacket << GetPublicID();
	kBillingPacket << true; // true : 유저 mouse를 unbusy로 만든다.

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGetCash pNode == NULL : %s(%d)", GetPublicID().c_str(), GetUserIndex() );
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_EXCEPTION;
		kReturn << true; // bSetMouse;
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
		return;
	}

	if( !pNode->AddRequestGetCashPacket( this, kBillingPacket, STPK_GET_CASH, GET_CASH_BILLING_EXCEPTION ) )
		return;

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
		pLocal->FillRequestGetCash( this, kBillingPacket );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGetCash Cash Send Fail : %s", GetPublicID().c_str() );
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_DISCONNECT;
		kReturn << true; // bSetMouse;
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
	}
	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);
}

void User::OnBillingGetCash( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	bool         bSetUserMouse   = false;
	
	rkPacket >> szBillingGUID;
	rkPacket >> bSetUserMouse;
	
	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingGetCash BillingGUID Is Empty: %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_FAIL;
		kReturn << bSetUserMouse;
		SendMessage( kReturn );
		SetCash( 0 ); // 초기화
		SetChannelingCash( 0 );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingGetCash Wrong BillingGUID : %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN ||
			ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
		{
			ClearBillingGUID();
			return;
		}
		else
		{
			SP2Packet kReturn( STPK_GET_CASH );
			kReturn << GET_CASH_BILLING_FAIL;
			kReturn << bSetUserMouse;
			SendMessage( kReturn );
			SetCash( 0 ); // 초기화
			SetChannelingCash( 0 );
			return;
		}
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingGetCash pNode is NULL: %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_FAIL;
		kReturn << bSetUserMouse;
		SendMessage( kReturn );
		SetCash( 0 ); // 초기화
		SetChannelingCash( 0 );
		return;
	}

	rkPacket.SetPosBegin();
	pNode->OnRecieveGetCash( this, rkPacket, STPK_GET_CASH, GET_CASH_BILLING_FAIL );

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal && !pLocal->IsPCRoomCheck() )
	{
		
		if( !m_UserTimeCashTabel.IsActive() )
		{
			m_UserTimeCashTabel.CheckUpdateInfo();
		}
		return;
	}

    // PC방 확인 / 빌링릴레이서 서버와 패킷을 한번에 한개만 처리하므로 처음 캐쉬값을 알아온 후 PC방 체크를 함.
	if( m_bSendCheckPCRoom )
		return;

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	SetBillingGUID( szTempGUID );

	SP2Packet kBillingPacket( BSTPK_PCROOM );
	kBillingPacket << GetChannelingType();
	kBillingPacket << GetBillingGUID();
	kBillingPacket << GetUserIndex();
	kBillingPacket << GetPrivateID();
	kBillingPacket << GetPublicID();
	kBillingPacket << GetPublicIP(); 
	kBillingPacket << g_App.GetCSPort();


	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s PCRoom Send Fail : %s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		ClearBillingGUID();
	}
	else
		m_bSendCheckPCRoom  = true;
	//
	
}

void User::OnBillingOutputCash( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int          iReturnValue = 0;
	int          iPayAmt      = 1;
	int          iType        = 0;
	int          iTransactionID = 0;
	int          iReturnItemPrice = 0;
	ioHashString szSubscriptionID;
	bool         bBillingError    = false;
	ioHashString sBillingError;
	
	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;

	//HRYOON 물건 실 가격
	rkPacket >> iReturnItemPrice;
	rkPacket >> iType;
	int test1 = 0;
	int test2 = 0;
	int test3 = 0;
	int test4 = 0;
	if( iReturnValue == CASH_RESULT_SUCCESS )
	{
		rkPacket >> iPayAmt;
		rkPacket >> iTransactionID;
 
		rkPacket >> szSubscriptionID;//kyg 빌링서버 업데이트 된곳만 진행됨 
		//kyg 여기에 szCargeNo 추가 
	}
	else
	{
		rkPacket >> bBillingError;
		if( bBillingError )
			rkPacket >> sBillingError;
	}

	//[HRYOON구매] 빌링으로 부터 캐쉬 차감된 후 응답 들어왔으므로 구매 상태 변경함
	SetOutputStatus( false );
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnBillingOutputCash Status(false) change %d:%s:%s", iType, GetPublicID().c_str(), szBillingGUID.c_str() );

	DWORD dwPacketID    = 0;
	DWORD dwReturnType  = 0;
	if( iType == OUTPUT_CASH_SOLDIER )
	{
		dwPacketID	 = STPK_CHAR_CREATE;
		dwReturnType = CREATE_CHAR_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_DECO )
	{
		dwPacketID	 = STPK_CHAR_DECORATION_BUY;
		dwReturnType = CHAR_DECORATION_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_SOLDIER_EXTEND )
	{
		dwPacketID	 = STPK_CHAR_EXTEND;
		dwReturnType = CHAR_EXTEND_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_ETC )
	{
		dwPacketID   = STPK_ETCITEM_BUY;
		dwReturnType = ETCITEM_BUY_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_SOLDIER_CHANGE_PERIOD )
	{
		dwPacketID   = STPK_CHAR_CHANGE_PERIOD;
		dwReturnType = CHAR_CHANGE_PERIOD_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_EXTRA )
	{
		dwPacketID   = STPK_EXTRAITEM_BUY;
		dwReturnType = EXTRAITEM_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_PRESENT )
	{
		dwPacketID   = STPK_PRESENT_BUY;
		dwReturnType = PRESENT_BUY_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_SUBSCRIPTION )
	{
		dwPacketID   = STPK_SUBSCRIPTION_BUY;
		dwReturnType = SUBSCRIPTION_BUY_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_COSTUME )
	{
		dwPacketID	 = STPK_COSTUME_BUY;
		dwReturnType = ITEM_BUY_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_POPUP )
	{
		dwPacketID   = STPK_POPUP_ITEM_BUY_RESULT;
		dwReturnType = POPUP_ITEM_BILLING_FAIL;
	}
	else if( iType == OUTPUT_CASH_ACCESSORY )
	{
		dwPacketID   = STPK_ACCESSORY_BUY;
		dwReturnType = ITEM_BUY_BILLING_FAIL;
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingOutputCash Error Typs is %d:%s:%s", iType, GetPublicID().c_str(), szBillingGUID.c_str() );
		return;
	}

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingOutputCash BillingGUID Is Empty: %s:%s:%s:%d", GetPublicID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iType );
		SP2Packet kReturn( dwPacketID );
		kReturn << dwReturnType;
		SendMessage( kReturn );
		return;
	}
	szBillingGUID = GetBillingGUID();//temp fake
	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingOutputCashc : %s:%s:%s:%d", GetPublicID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iType );
		SP2Packet kReturn( dwPacketID );
		kReturn << dwReturnType;
		SendMessage( kReturn );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingOutputCash pNode == NULL. : %d:%s:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iType );
		SP2Packet kReturn( dwPacketID );
		kReturn << dwReturnType;
		SendMessage( kReturn );
		return;
	}
	
	//보너스 캐쉬 Flag 해제
	if( !pNode->CheckReciveOutputCash( this, iReturnValue, iPayAmt, bBillingError, sBillingError, dwPacketID, dwReturnType ) )
	{
		int iSize = 0;

		PACKET_GUARD_VOID( rkPacket.Read(iSize) );
		for( int i = 0; i < iSize; i++ )
		{
			int iIndex	= 0;
			PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
			m_UserBonusCash.RelieveFlag(iIndex);
		}

		ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}
	int iBuyType	= 0;
	int iValue1		= 0;
	int iValue2		= 0;

	if( iType == OUTPUT_CASH_SOLDIER )
	{
		_OnBillingOutputCashSoldier( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID, iBuyType, iValue1, iValue2 );
	}
	else if( iType == OUTPUT_CASH_DECO )
	{
		_OnBillingOutputCashDeco( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID, iBuyType, iValue1, iValue2 );
	}
	else if( iType == OUTPUT_CASH_SOLDIER_EXTEND )
	{
		_OnBillingOutputCashSoldierExtend( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID );
	}
	else if( iType == OUTPUT_CASH_ETC )
	{
	
		_OnBillingOutputCashEtc( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID, iBuyType, iValue1, iValue2 );
	}
	else if( iType == OUTPUT_CASH_SOLDIER_CHANGE_PERIOD )
	{
		_OnBillingOutputCashSoldierChangePeriod( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID );
	}
	else if( iType == OUTPUT_CASH_EXTRA )
	{
		_OnBillingOutputCashExtra( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID, iBuyType, iValue1, iValue2 );
	}
	else if( iType == OUTPUT_CASH_PRESENT )
	{
		_OnBillingOutputCashPresent( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID );
	}
	else if( iType == OUTPUT_CASH_SUBSCRIPTION )
	{
		_OnBillingOutputCashSubscription( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID, szSubscriptionID );
	}
	else if( iType == OUTPUT_CASH_COSTUME )
	{
		_OnBillingOutputCashCostume( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID, iBuyType, iValue1, iValue2 );
	}
	else if( iType == OUTPUT_CASH_POPUP )
	{
		_OnBillingOutputCashPopup( rkPacket, iReturnItemPrice, iPayAmt, iTransactionID );
	}
	else if( iType == OUTPUT_CASH_ACCESSORY )
	{
		//_OnBillingOutputCashAccessory( rkPacket, iPayAmt, iTransactionID, iBuyType, iValue1, iValue2 );
	}

	//// 캐시로 구매 성공할 경우 db에 사용 캐시 금액 넣어줌
	
	//이상한값 있나 체크
	if( 0 < iPayAmt && iPayAmt < 500000 )
		g_DBClient.OnUpdateSpentCash( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iPayAmt );
	else
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingOutputCash iPayAmt is wrong. : %u:%s:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iPayAmt );

	if( iType != OUTPUT_CASH_SUBSCRIPTION )
	{

		//int iSize = 0;
		//PACKET_GUARD_VOID( rkPacket.Read(iSize) );
		//for( int i = 0; i < iSize; i++ )
		//{
		//	int iIndex	= 0;
		//	int iValue	= 0;


		//	PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
		//	PACKET_GUARD_VOID( rkPacket.Read(iValue) );


		//	//보너스 캐쉬 사용!
		//	m_UserBonusCash.SpendBonusCash(iIndex, iValue, iBuyType, iValue1, iValue2);
		//}
	}

	// 구매 관련 칭호 체크.
	m_TitleInven.CheckTitleValue(TITLE_CONSUME_ACCUMULATE_GOLD, iPayAmt);

	// 누적 소비 골드, 캐시로 구매 성공할 경우 db에 사용 캐시 금액 넣어줌, userSpentGoldDB
	g_DBClient.OnUpdateSpentCash( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iPayAmt ); 
	//kyg 테스트 코드 ㄱ

	//// 캐시로 구매 성공할 경우 db에 사용 캐시 금액 넣어줌
	
	//이상한값 있나 체크
	if( 0 < iPayAmt && iPayAmt < 500000 )
		g_DBClient.OnUpdateSpentCash( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iPayAmt );
	else
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingOutputCash iPayAmt is wrong. : %u:%s:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iPayAmt );

#if(0)
	SP2Packet pk(1);
	pk << 1;
	pk << szSubscriptionID;
	pk.SetPosBegin();
	SetSubscriptionRetr(1,szSubscriptionID);
#endif
}


void User::_OnBillingOutputCashSoldier( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID, int& iBuyType, int& iValue1, int& iValue2 )
{
	// Parsing
	int iClassType   = 0;
	int iKindred     = 0;
	int iSex         = 0;
	int iLimitSecond = 0;
	int iPeriodType  = 0;

	rkPacket >> iClassType;
	rkPacket >> iKindred;
	rkPacket >> iSex;
	rkPacket >> iLimitSecond;
	rkPacket >> iPeriodType;

	iBuyType	= PRESENT_SOLDIER;
	iValue1		= iClassType;
	iValue2		= iLimitSecond;

	

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	// 상점 블럭.
	if( IsCharCreating() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier Create Char Error : %s:%s", GetPublicID().c_str(), GetBillingGUID().c_str() );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CREATE );
		kReturn << CREATE_CHAR_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	int iBuyCash = 0;

	if( iPeriodType == CPT_TIME )
		iBuyCash = g_ItemPriceMgr.GetClassBuyCash( iClassType, iLimitSecond );
	else if( iPeriodType == CPT_MORTMAIN )
		iBuyCash = g_ItemPriceMgr.GetMortmainCharCash( iClassType );
	else if( iPeriodType == CPT_DATE )
		iBuyCash = g_ItemPriceMgr.GetClassBuyCash( iClassType, iLimitSecond );


	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier Cash Price Wrong : %d:%s:%s:%d:%d", iPeriodType, GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CREATE );
		kReturn << CREATE_CHAR_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	
	if( iBuyCash != iReturnItemPrice )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier Cash Price Different : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CREATE );
		kReturn << CREATE_CHAR_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	// Success
	int iPreCash           = GetCash();
	int iPreRealCash		= GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier pNode == NULL. : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CREATE );
		kReturn << CREATE_CHAR_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_CHAR_CREATE, CREATE_CHAR_BILLING_FAIL ) )
			return;
	}

	//HRYOON 보너스 캐쉬
	int iBonusCashSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iBonusCashSize) );
	for( int i = 0; i < iBonusCashSize; i++ )
	{
		int iIndex	= 0;
		int iValue	= 0;

		PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(iValue) );

		//보너스 캐쉬 사용!
		if ( !m_UserBonusCash.SpendBonusCash(iIndex, iValue, iBuyType, iValue1, iValue2) )
		{
			
			//보너스 캐쉬 차감 실패 로그 
			
			SP2Packet kReturn( STPK_CHAR_CREATE );
			kReturn << CREATE_CHAR_BILLING_FAIL;
			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier Spend Bonus Cash Error : userIndex:%d,publicID:%s,guid:%s,index:%d,money:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iIndex, iValue );
			

		}
	}

	__int64 iPreMoney = GetMoney();
	bool bMortmain = false;
	if( iPeriodType == CPT_MORTMAIN )
		bMortmain = true;
	int iBonusPeso = g_ItemPriceMgr.GetBonusPeso( iClassType, bMortmain );
	if( iBonusPeso > 0 )
	{
		AddMoney( iBonusPeso );
		SaveUserData();
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_SOLDIER, iClassType, iBonusPeso, NULL);
	}

	CHARACTER kCharInfo;
	kCharInfo.m_class_type   = iClassType;
	kCharInfo.m_kindred      = iKindred;
	kCharInfo.m_sex          = iSex;
	kCharInfo.m_iLimitSecond = iLimitSecond;
	kCharInfo.m_ePeriodType  = (CharPeriodType) iPeriodType;

	// 착용중인 아이템
	m_Inventory.GetEquipItemCode( kCharInfo );	
	// 착용한 아이템이 없다면 Default 지급
	if( kCharInfo.m_face == -1)
		kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
	if( kCharInfo.m_hair == -1 )
		kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
	if( kCharInfo.m_skin_color == -1 )
		kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
	if( kCharInfo.m_hair_color == -1 )
		kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
	if( kCharInfo.m_underwear == -1 )
		kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	

	m_iCreateCharCount++;
	//캐릭터 생성.

	if( kCharInfo.m_ePeriodType == CPT_DATE )
		SetCharDateType(kCharInfo);

	g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
	g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK , 1, LogDBClient::CT_CASH, iPayAmt ); // false : 페소, true : 캐쉬

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier Soldier Success :%s:%s:%d:%d:%d:%dSec:%dPrice:%dCash:%dPreCash:%I64dMoney:%I64dPreMoney:%dBonusPeso:%dPreChannelingCash:%dChannelingCash", GetPublicID().c_str(), GetBillingGUID().c_str(), iClassType, iKindred, iSex, iLimitSecond, iPayAmt, GetCash(), iPreCash, GetMoney(), iPreMoney, iBonusPeso, iPreChannelingCash, GetChannelingCash() );	

	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);



	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldier Soldier Success userID:%s, GUID:%s, ClassType:%d, Sec:%d, UsedCash:%d, ItemPrice:%d, PreCash:%I64d", 
		GetPrivateID().c_str(), GetBillingGUID().c_str(), iClassType, iLimitSecond, iPayAmt, iBuyCash, iPreCash );	

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
		{
			int iValue2 = -1;
			if( iPeriodType == CPT_TIME )
				iValue2 = iLimitSecond;
			else if( iPeriodType == CPT_MORTMAIN )
				iValue2 = 0;
			if( iPeriodType == CPT_DATE )
				iValue2 = iLimitSecond;
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_SOLDIER, iClassType, iValue2, iBuyCash );
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_SOLDIER, iClassType, iValue2, iPayAmt );
			if( iPeriodType == CPT_DATE )
				iValue2 = iLimitSecond;
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_SOLDIER, iClassType, iValue2, iBuyCash );
		}
	}

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(), PRESENT_SOLDIER, iClassType, iLimitSecond);
}


void User::_OnBillingOutputCashDeco( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID, int& iBuyType, int& iValue1, int& iValue2 )
{
	// Parsing
	int iDecoType    = 0;
	int iDecoCode    = 0;
	int iCharArray   = 0;

	rkPacket >> iDecoType;
	rkPacket >> iDecoCode;
	rkPacket >> iCharArray;	

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	iBuyType	= PRESENT_DECORATION;
	iValue1		= iDecoType;
	iValue2		= iDecoCode;

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashDeco SelectArray is Wrong : %s:%s:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash());
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
		kReturn << CHAR_DECORATION_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	int iBuyCash = g_DecorationPrice.GetDecoCash( iDecoType, iDecoCode );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashDeco Cash Price Wrong : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
		kReturn << CHAR_DECORATION_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}


	if( iBuyCash != iReturnItemPrice )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashDeco Cash Price Different : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
		kReturn << CHAR_DECORATION_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	ITEMSLOT kSlot;
	kSlot.m_item_type = iDecoType;	
	kSlot.m_item_code = iDecoCode;	

	/*if( m_Inventory.IsFull() )
	{
		SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );
		PACKET_GUARD_VOID( kPacket.Write( CHAR_DECORATION_MAX_COUNT ) );
		SendMessage( kPacket );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;		
	}*/

	// 장착	
	if( !m_CharList[iCharArray]->SetCharDecoration( kSlot.m_item_type, kSlot.m_item_code ) )	
	{		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashDeco Set Char Deco Error : %s:%s:%d:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iCharArray, kSlot.m_item_type, kSlot.m_item_code );		
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
		kReturn << CHAR_DECORATION_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	// Success
	int iPreCash = GetCash();
	int iPreRealCash		= GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashDeco pNode == NULL. : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
		kReturn << CHAR_DECORATION_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_CHAR_DECORATION_BUY, CHAR_DECORATION_BILLING_FAIL ) )
			return;
	}

	//HRYOON 보너스 캐쉬 사용
	int iBonusCashSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iBonusCashSize) );
	for( int i = 0; i < iBonusCashSize; i++ )
	{
		int iIndex	= 0;
		int iValue	= 0;
		PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(iValue) );
		//보너스 캐쉬 사용!
		if( !m_UserBonusCash.SpendBonusCash(iIndex, iValue, iBuyType, iValue1, iValue2) )
		{
			

			SP2Packet kReturn( STPK_CHAR_DECORATION_BUY );
			kReturn << CHAR_DECORATION_BILLING_FAIL;
			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnCharDecorationBuy Spend Bonus Cash Error : userIndex:%d,publicID:%s:,guid:%s,index:%d,money:%d,itemType:%d,itemCode:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iIndex, iValue, kSlot.m_item_type, kSlot.m_item_code );
		
		}
	}

	// 슬롯 추가	
	DWORD dwIndex = 0;
	int   iArray  = 0;
	m_Inventory.AddSlotItem( kSlot, true, iPayAmt, LogDBClient::DT_BUY,  dwIndex, iArray );


	m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code);	
	__int64 iPreMoney  = GetMoney();
	int iBonusPeso = g_DecorationPrice.GetBonusPeso( iDecoType, iDecoCode );
	if( iBonusPeso > 0 )
	{
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, (iDecoType % 1000), iDecoCode, iBonusPeso, NULL);
	}
	if( dwIndex != 0 )
	{
		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
		
		g_LogDBClient.OnInsertCashItem( this, kSlot.m_item_type, kSlot.m_item_code, iPayAmt, szItemIndex, LogDBClient::CIT_DECO , GetBillingGUID().c_str());
	}

	// 종족 치장을 구매하면 랜덤 치장 아이템을 지급한다.	
	if( kSlot.m_item_type % 1000 == UID_KINDRED )	
	{		
		const CHARACTER &rkCharInfo = m_CharList[iCharArray]->GetCharInfo();
		CHARACTER rkChangeInfo = rkCharInfo;
		m_Inventory.GetEquipItemCode( rkChangeInfo );
		m_CharList[iCharArray]->SetChangeKindred( rkChangeInfo, GetPrivateID().GetHashCode() );
		SetDefaultDecoItem( m_CharList[iCharArray]->GetCharInfo() );
	}	

	SP2Packet kPacket( STPK_CHAR_DECORATION_BUY );	
	kPacket << CHAR_DECORATION_OK << GetMoney() << GetCash() << GetChannelingCash() << kSlot.m_item_type << kSlot.m_item_code<< m_CharList[iCharArray]->GetCharIndex() << (CHARACTER)m_CharList[iCharArray]->GetCharInfo() << iBonusPeso;	
	SendMessage( kPacket );		
	SaveInventory();	
	SaveUserData();	

	m_UserGrowthLevel.AddCharGrowthPointByDecoWoman( kSlot.m_item_type, kSlot.m_item_code );
	


	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);



	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashDeco Success userID:%s, GUID:%s, CharArray:%d, itemtype:%d, Itemcode:%d, Cash:%d, UsedCash:%d, ItemPrice:%d, BonusPeso:%d",
		                 GetPrivateID().c_str(), GetBillingGUID().c_str(), iCharArray, kSlot.m_item_type, kSlot.m_item_code, GetCash(), iPayAmt, iBuyCash, iBonusPeso );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_DECO, kSlot.m_item_type, kSlot.m_item_code, iPayAmt );
	}

	if( m_pMyRoom )
	{
		m_pMyRoom->OnModeCharDecoUpdate( this, m_CharList[iCharArray] );
	}

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(), PRESENT_DECORATION, kSlot.m_item_code, 1);
}


void User::_OnBillingOutputCashSoldierExtend( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID )
{
	// Parsing
	int iCharArray   = 0;
	int iClassType   = 0;
	int iLimitSecond = 0;
	rkPacket >> iCharArray;
	rkPacket >> iClassType;
	rkPacket >> iLimitSecond;
	
	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierExtend CharArray is Wrong : %s:%s:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash());
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_EXTEND );
		kReturn << CHAR_EXTEND_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	int iBuyCash = g_ItemPriceMgr.GetClassBuyCash( iClassType, iLimitSecond );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierExtend Cash Price Wrong : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_EXTEND );
		kReturn << CHAR_EXTEND_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( iBuyCash != iPayAmt )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierExtend Cash Price Different : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_EXTEND );
		kReturn << CHAR_EXTEND_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	// Success
	int iPreCash = GetCash();
	int iPreRealCash		= GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierExtend pNode == NULL. : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_EXTEND );
		kReturn << CHAR_EXTEND_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_CHAR_EXTEND, CHAR_EXTEND_BILLING_FAIL ) )
			return;
	}

	__int64 iPreMoney = GetMoney();
	bool bMortmain = false;
	int iBonusPeso = g_ItemPriceMgr.GetBonusPeso( iClassType, bMortmain );
	if( iBonusPeso > 0 )
	{
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_SOLDIER, iClassType, iBonusPeso, NULL);
	}

	// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->UpdateLimitTimer();
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnBillingOutputCashSoldierExtend Extend %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}	
	// 플레이 연장
	if(m_CharList[iCharArray]->GetCharInfo().m_ePeriodType == CPT_DATE)
		m_CharList[iCharArray]->SetCharLimitExtendDate( iLimitSecond );
	else
	m_CharList[iCharArray]->SetCharLimitExtend( iLimitSecond );
	// 플레이중이면 연장한 시간부터 세팅한다. 
	m_CharList[iCharArray]->SetActive( true );
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->StartLimitTimer( m_pMyRoom->GetCharLimitCheckTime() );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnBillingOutputCashSoldierExtend Extend %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}		
	SaveCharacter();  //변경된 정보 저장
	SaveUserData();   //금액이 차감되었다.

	//

	//판매 기록
	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );

	g_LogDBClient.OnInsertCashItem( this, iClassType, iLimitSecond, iPayAmt, szItemIndex, LogDBClient::CIT_CHAR , GetBillingGUID().c_str());

	const CHARACTER &ExtendInfo = m_CharList[iCharArray]->GetCharInfo();		
	SP2Packet kPacket( STPK_CHAR_EXTEND );
	kPacket << CHAR_EXTEND_OK << GetMoney() << GetCash() << GetChannelingCash() << iCharArray << iBonusPeso;
	kPacket << m_CharList[iCharArray]->IsActive() << m_CharList[iCharArray]->GetCharLimitDate() << m_CharList[iCharArray]->GetLimitCheckSecond();
	SendMessage( kPacket );		

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnBillingOutputCashSoldierExtend : %s:%s : %dPreCash : %dCash : %dSEC : %I64dPreMoney : %I64dMoney :  %dPreChannelingCash : %dChannelingCash", GetPublicID().c_str(), GetBillingGUID().c_str(), iPreCash, GetCash(), m_CharList[iCharArray]->GetCharLimitDate(), iPreMoney, GetMoney(), iPreChannelingCash, GetChannelingCash() );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_SOLDIER, iClassType, iLimitSecond, iPayAmt );
	}

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(), PRESENT_SOLDIER, iClassType, iLimitSecond);
}


void User::_OnBillingOutputCashEtc( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID, int& iBuyType, int& iValue1, int& iValue2 )
{
	// Parsing
	DWORD dwType    = 0;
	int   iArray    = 0;

	rkPacket >> dwType;
	rkPacket >> iArray;	

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem(dwType);
	if(!pEtcItem)
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashEtc Type is wrong : %s:%s:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), dwType );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_BILLING_FAIL) );
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	bool bSpecialGoods = pEtcItem->IsSpecialGoods();
	int iBuyCash = pEtcItem->GetCash( iArray );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashEtc Cash Price Wrong : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_BILLING_FAIL) );
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	/*if( iBuyCash != iPayAmt )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashEtc Cash Price Different : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_BILLING_FAIL) );
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}
	*/
	//////////////////////////예외아이템/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if( pEtcItem->IsAfterBuyAction() )
	{
		pEtcItem->OnAfterBuy( this, rkPacket, iArray, iTransactionID, iBuyCash );
		if( dwType == ioEtcItem::EIT_ETC_SELECT_EXTRA_GASHAPON || COMPARE( dwType, ioEtcItem::EIT_ETC_SELECT_EXTRA_GASHAPON02, ioEtcItem::EIT_ETC_SELECT_EXTRA_GASHAPON51+1 ) )
		{
			ClearSelectExtraItemCodes();
		}
		else if( COMPARE( dwType, ioEtcItem::EIT_ETC_SELECT_GASHAPON001, ioEtcItem::EIT_ETC_SELECT_GASHAPON300+1 ) )
		{
			ClearSelectGashapon();
		}

		ClearBillingGUID();
		return; 
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	ioUserEtcItem::ETCITEMSLOT kEtcItemSlot;
	bool bExist = m_UserEtcItem.GetEtcItem( dwType, kEtcItemSlot );
	int iServerValue = pEtcItem->GetValue( iArray );

	bool bNewMortmain = false;

	iBuyType	= PRESENT_ETC_ITEM;
	iValue1		= dwType;
	iValue2		= iServerValue;

	if( g_EtcItemMgr.IsBlockEtcItem( dwType ) && iServerValue == 0 )
	{
		if( pEtcItem->IsCanMortmain( iArray ) )
			bNewMortmain = true;
	}

	DWORD dwCompensation = _OnEtcItemSetting( pEtcItem, kEtcItemSlot, iServerValue, bNewMortmain );

	// set my item
	DWORD dwIndex        = 0;
	int   iArrayInIndex  = 0;
	BOOL bBlockItem	= FALSE;

	if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_GUILD_HOUSING_BLOCK_1000 + 1 ) )
	{
		DWORD dwBlockCode	= pEtcItem->GetProperty();
		
		if( !g_BlockPropertyMgr.IsValidItemCode(dwBlockCode) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][block]block item buy fail, Invalid block itemcode : [%d] [%d]", GetUserIndex(), dwBlockCode);
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			return;
		}
		for( int i = 0; i < iServerValue; i++ )
			g_DBClient.OnAddGuildBlockItem(GetUserIndex(), GetGuildIndex(),  dwBlockCode, GBA_ITEM_BUY);

		bBlockItem	= TRUE;
	}
	else if( COMPARE( pEtcItem->GetType(), ioEtcItem::EIT_ETC_HOUSING_BLOCK_0001, ioEtcItem::EIT_ETC_HOUSING_BLOCK_1000 + 1 ) )
	{
		DWORD dwBlockCode	= pEtcItem->GetProperty();
		
		if( !g_BlockPropertyMgr.IsValidItemCode(dwBlockCode) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][block]block item buy fail, Invalid personal block itemcode : [%d] [%d]", GetUserIndex(), dwBlockCode);
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			return;
		}

		BOOL bEnd	= FALSE;
		for( int i = 0; i < iServerValue; i++ )
		{
			if( (iServerValue - 1 ) == i )
				bEnd	= TRUE;

			g_DBClient.OnAddPersonalHQBlockItem(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwBlockCode, iServerValue, bEnd);
		}

		bBlockItem	= TRUE;
	}
	else if( !m_UserEtcItem.AddEtcItem( kEtcItemSlot, true, iPayAmt,  dwIndex, iArrayInIndex ) )	
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashEtc Error AddEtcItem - %s(%d) %d:%d", GetPublicID().c_str(), GetUserIndex(), dwType, iServerValue );
		ClearBillingGUID();
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kPacket );	

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	// success
	//HRYOON 2015 가레나
	int dwEtcType = 0;

	if( dwIndex != 0 )
	{

		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayInIndex+1 ); // db field는 1부터 이므로 +1

		g_LogDBClient.OnInsertCashItem( this, dwType, iServerValue, iPayAmt, szItemIndex, LogDBClient::CIT_ETC , GetBillingGUID().c_str());
		
		dwEtcType = dwType;
		StartEtcItemTime(  __FUNCTION__ , dwType );
	}

	int iPreCash = GetCash();
	int iPreRealCash		= GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashEtc pNode == NULL. : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_ETCITEM_BUY, ETCITEM_BUY_EXCEPTION ) )
			return;
	}

	//HRYOON 보너스 캐쉬 사용
	int iBonusCashSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iBonusCashSize) );
	for( int i = 0; i < iBonusCashSize; i++ )
	{
		int iIndex	= 0;
		int iValue	= 0;
		PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(iValue) );
		//보너스 캐쉬 사용!
		if( !m_UserBonusCash.SpendBonusCash(iIndex, iValue, iBuyType, iValue1, iValue2) )
		{
			

			SP2Packet kReturn( STPK_ETCITEM_BUY );
			PACKET_GUARD_VOID( kReturn.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Spend Bonus Cash Error - guid:%s,publicID:%s(userIndex:%d) Index:%d:money:%d %d %d",GetBillingGUID().c_str(), GetPublicID().c_str(), GetUserIndex(), iIndex, iValue, dwType, iArray );
			

		}
	}
	
	__int64 iPreMoney = GetMoney();
	int iBonusPeso = pEtcItem->GetBonusPeso( iArray );
	if( iBonusPeso > 0 )
	{
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, iBonusPeso, NULL);
	}

	// compensation
	AddMoney( dwCompensation );
	g_LogDBClient.OnInsertPeso( this, dwCompensation, LogDBClient::PT_SELL_ETCITEM );
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_ETCITEM, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, dwCompensation, NULL);

	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);



	SP2Packet kPacket( STPK_ETCITEM_BUY );
	if( bBlockItem )
	{
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_BLOCK) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iType) );
		PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );
		PACKET_GUARD_VOID( kPacket.Write(GetCash()) );
		PACKET_GUARD_VOID( kPacket.Write(GetChannelingCash()) );
		PACKET_GUARD_VOID( kPacket.Write(iBonusPeso) );
	}
	else
	{
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_OK) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iType) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iValue1) );
		PACKET_GUARD_VOID( kPacket.Write(kEtcItemSlot.m_iValue2) );
		PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );
		PACKET_GUARD_VOID( kPacket.Write(GetCash()) );
		PACKET_GUARD_VOID( kPacket.Write(GetChannelingCash()) );
		PACKET_GUARD_VOID( kPacket.Write(iBonusPeso) );
		PACKET_GUARD_VOID( kPacket.Write(true) );				//구매 알림 팝업
		PACKET_GUARD_VOID( kPacket.Write(dwCompensation) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)EBRT_BUY) );
	}
	
	SendMessage( kPacket );
	
	SaveEtcItem();
	SaveUserData();

	if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_CHAR_SLOT_EXTEND )
	{
		CheckCurMaxCharSlot();
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_FISHING_SLOT_EXTEND )
	{
		m_UserFishingItem.CheckCurMaxInventory();
	}
	else if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_EXTRAITEM_SLOT_EXTEND )
	{
		m_UserExtraItem.SetMaxPossessionCount();
	}

	if( bSpecialGoods )
	{
		SP2Packet kMainPacket( MSTPK_SPECIAL_SHOP_GOODS_BUY_RESULT );
		PACKET_GUARD_VOID( kMainPacket.Write(SPECIAL_SHOP_GOODS_BUY_RESULT_OK) );
		PACKET_GUARD_VOID( kMainPacket.Write(dwType) );
		PACKET_GUARD_VOID( kMainPacket.Write(GetUserIndex()) );

		g_MainServer.SendMessage( kMainPacket );
	}
		

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashEtc Success userID:%s, GUID:%s, Type:%d, Value:%d, UsedCash:%d, ItemPrice:%d, BonusPeso:%d",
		GetPrivateID().c_str(), GetBillingGUID().c_str(), dwType, iServerValue, iPayAmt, iBuyCash, iBonusPeso );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_ETC, dwType, iServerValue, iPayAmt );
	}

	//HRYOON 20150209 특별 아이템 중에서 특정 아이템을 산 경우 빌링 한번 더 타서 API 호출한다. 
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN ||
		ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND &&
		g_App.GetUseBuyItemEvent() == 1 )
	{
		if( dwEtcType == g_App.GetEventItemValue1() 
			 //||  iServerValue == g_App.GetEventItemValue2() 
			 )
		{
			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;

			SP2Packet kBillingPacket( BSTPK_GA_WEB_EVENT );
			int dwType = 2;
			PACKET_GUARD_VOID( kBillingPacket.Write(m_szBillingGUID) );
			PACKET_GUARD_VOID( kBillingPacket.Write(dwType) );
			PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
			PACKET_GUARD_VOID( kBillingPacket.Write( GetPublicID()) );
			PACKET_GUARD_VOID( kBillingPacket.Write (GetPublicIP()) );
			PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
			PACKET_GUARD_VOID( kBillingPacket.Write( BSTPK_GA_WEB_EVENT_RESULT) );

			if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Garena Web Event Send Fail : %d : %s", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
			}
			else
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GARENA_EVENT]%s Garena Web Event Send %d : %s", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
			}
		}
	}

	//기간 캐쉬박스.
	if( pEtcItem->GetType() == ioEtcItem::EIT_ETC_TIME_CASH )
	{
		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		SetBillingGUID(szTempGUID);
		
		//DB Update 요청.
		//시간 계산.
		int iYear	= kEtcItemSlot.GetYear();
		int iMonth	= kEtcItemSlot.GetMonth();
		int iDay	= kEtcItemSlot.GetDay();
		int iHour	= kEtcItemSlot.GetHour();
		int iMinute	= kEtcItemSlot.GetMinute();
		CTime cEndDate( iYear, iMonth, iDay, iHour, iMinute, 0);
		DWORD dwEndDate	= cEndDate.GetTime();

		g_DBClient.OnInsertTimeCashTable(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetBillingGUID(), ioEtcItem::EIT_ETC_TIME_CASH, dwEndDate );
	}

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(), PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, iServerValue);
}


void User::_OnBillingOutputCashSoldierChangePeriod( SP2Packet &rkPacket, int iReturnItemPrice,  int iPayAmt, int iTransactionID )
{
	// Parsing
	int iCharArray   = 0;
	int iClassType   = 0;
	rkPacket >> iCharArray;
	rkPacket >> iClassType;

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierChange CharArray is Wrong : %s:%s:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash());
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CHAR_CHANGE_PERIOD_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	int iBuyCash = g_ItemPriceMgr.GetMortmainCharCash( iClassType );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierChange Cash Price Wrong : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CHAR_CHANGE_PERIOD_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( iBuyCash != iPayAmt )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierChange Cash Price Different : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CHAR_CHANGE_PERIOD_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	// Success
	int iPreCash           = GetCash();
	int iPreRealCash		= GetPurchasedCash();
	__int64 iPreMoney      = GetMoney();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSoldierChange pNode == NULL. : %s:%s:%d:%d", GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_CHAR_CHANGE_PERIOD );
		kReturn << CHAR_CHANGE_PERIOD_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_CHAR_CHANGE_PERIOD, CHAR_CHANGE_PERIOD_BILLING_FAIL ) )
			return;
	}

	// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
	if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
	{
		m_CharList[iCharArray]->UpdateLimitTimer();
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "_OnBillingOutputCashSoldierChange - UpdateLimitTimer %s - %d : %d", GetPublicID().c_str(), m_CharList[iCharArray]->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
	}	

	int iResellLimitDate = m_CharList[iCharArray]->GetCharLimitDate();

	bool bResell = true;

	if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN)
	{
		CTime cCharTime = Help::ConvertNumberToCTime(iResellLimitDate);
		CTime kCurTime = CTime::GetCurrentTime();

		if(kCurTime < cCharTime)
		{
			CTimeSpan cRemainTime = cCharTime - kCurTime;
			iResellLimitDate = cRemainTime.GetTotalMinutes();
		}
		else
		{
			bResell = false;
			iResellLimitDate = 1;
		}
	}

	int iResellPeso      = g_ItemPriceMgr.GetTimeCharResellPeso( iClassType, iResellLimitDate  );

	if(!bResell)
		iResellPeso = 0;

	if( iResellPeso > 0 )
	{
		AddMoney( iResellPeso );
		g_LogDBClient.OnInsertPeso( this, iResellPeso, LogDBClient::PT_DEL_CHAR );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_DEL_CHAR, PRESENT_SOLDIER, iClassType, iResellPeso, NULL);
	}

	bool bMortmain = true;
	int iBonusPeso = g_ItemPriceMgr.GetBonusPeso( iClassType, bMortmain );
	if( iBonusPeso > 0 )
	{
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_SOLDIER, iClassType, iBonusPeso, NULL);
	}

	// 변경
	m_CharList[iCharArray]->SetPeriodType( CPT_MORTMAIN );
	m_CharList[iCharArray]->SetCharLimitDate( 0 );
	m_CharList[iCharArray]->SetActive( true );

	SaveCharacter();  //변경된 정보 저장
	SaveUserData();   //금액이 차감되었다.

	Room *pMyRoom = GetMyRoom();
	/*if( pMyRoom )
	{*/
	int iSoldierType	= GetSpecialSoldierType(m_CharList[iCharArray]->GetClassType());

	if( iSoldierType != SST_END )
	{
		if( m_CharList[iCharArray]->HasExerciseStyle(EXERCISE_NONE) && m_CharList[iCharArray]->IsMortmain() )
		{
			if( SST_RSOLDIER == iSoldierType )
			{
				//해당 방 유저에게 R용병 구매 했다고 통지.
				SP2Packet kPacket(STPK_RSOLDIER_STATUS);
				PACKET_GUARD_VOID( kPacket.Write(RSOLDIER_BUY) );
				PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

				if( pMyRoom )
					pMyRoom->RoomSendPacketTcp(kPacket);
				else
					SendMessage(kPacket);
			}
			else
			{
				SP2Packet kPacket(STPK_SOLDIER_SET_STATUS);
				PACKET_GUARD_VOID( kPacket.Write(RSOLDIER_BUY) );
				PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
				PACKET_GUARD_VOID( kPacket.Write(m_CharList[iCharArray]->GetClassType()) );

				if( pMyRoom )
					pMyRoom->RoomSendPacketTcp(kPacket);
				else
					SendMessage(kPacket);
			}
		}
	}
	/*}*/

	//판매 기록
	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );

	g_LogDBClient.OnInsertCashItem( this, iClassType, m_CharList[iCharArray]->GetCharLimitDate(), iPayAmt, szItemIndex, LogDBClient::CIT_CHAR , GetBillingGUID().c_str());

	SP2Packet kPacket( STPK_CHAR_CHANGE_PERIOD );
	kPacket << CHAR_CHANGE_PERIOD_OK << GetMoney() << GetCash() << GetChannelingCash() << iCharArray << iResellPeso << iBonusPeso << true; // bCash
	SendMessage( kPacket );		

	CreateSelectCharData( m_CharList[iCharArray] );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnBillingOutputCashSoldierExtend : %s:%s : %dPreCash : %dCash : %I64dPrePeso : %I64dPeso %d - %d - %d -%d :%dPreChannelingCash:%dChannelingCash", GetPublicID().c_str(), GetBillingGUID().c_str(), iPreCash, GetCash(), iPreMoney, GetMoney(), m_CharList[iCharArray]->GetCharIndex(), iResellPeso, iResellLimitDate, iBonusPeso, iPreChannelingCash, GetChannelingCash() );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_SOLDIER, iClassType, 0, iPayAmt );
	}

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(),PRESENT_SOLDIER, iClassType, 0);
}


void User::_OnBillingOutputCashExtra( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID, int& iBuyType, int& iValue1, int& iValue2 )
{
	// Parsing
	int   iMachineCode = 0;
	rkPacket >> iMachineCode;	

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	int iBuyCash = g_ExtraItemInfoMgr.GetNeedCash( iMachineCode );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Wrong : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}


	if( iBuyCash != iReturnItemPrice )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Different : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	bool bPackage = g_ExtraItemInfoMgr.IsPackage( iMachineCode );

	int iTradeTypeList = 0;
	int iItemCode = g_ExtraItemInfoMgr.GetRandomItemCode( iMachineCode, iTradeTypeList );
	int iPeriodTime = g_ExtraItemInfoMgr.GetRandomPeriodTime( iMachineCode );
	bool bAlarm     = g_ExtraItemInfoMgr.IsAlarm( iMachineCode, iPeriodTime );
	int iReinforce = g_ExtraItemInfoMgr.GetRandomReinforce( iMachineCode, true );

	ioUserExtraItem::EXTRAITEMSLOT kExtraItem;
	kExtraItem.m_iItemCode = iItemCode;
	kExtraItem.m_iReinforce = iReinforce;
	kExtraItem.m_PeriodType = ioUserExtraItem::EPT_TIME;
	kExtraItem.m_iTradeState = ioUserExtraItem::EET_DISABLE;

	int iSlotIndex = 0;

	if( bPackage )
	{

		g_LogDBClient.OnInsertCashItem( this, iMachineCode,  0, iPayAmt, "NONE", LogDBClient::CIT_EXTRA , GetBillingGUID().c_str()); 
		g_PresentHelper.SendExtraItemPackagePresent( this, iMachineCode );
	}
	else // bPackage == false
	{
		if( iPeriodTime >= 0 )
		{


			CTime kLimiteTime = CTime::GetCurrentTime();
			CTimeSpan kAddTime( 0, iPeriodTime, 0, 0 );
			kLimiteTime += kAddTime;

			kExtraItem.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );

			if( iPeriodTime == 0 ) // 무제한
			{
				kExtraItem.m_PeriodType = ioUserExtraItem::EPT_MORTMAIN;

				int iTradeType = g_ExtraItemInfoMgr.GetRandomTradeType( iMachineCode, iTradeTypeList );
				kExtraItem.m_iTradeState = iTradeType;
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail ExtraItem1 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );

			// 예외처리
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			kReturn << EXTRAITEM_PERIOD;
			SendMessage( kReturn );
			return;
		}

		DWORD dwIndex = 0;
		int iArrayIndex = 0;
		iSlotIndex = m_UserExtraItem.AddExtraItem( kExtraItem, true, iPayAmt, LogDBClient::CIT_EXTRA, iMachineCode, iPeriodTime, dwIndex, iArrayIndex );

		if( iSlotIndex > 0 )
		{
			char szItemIndex[MAX_PATH]="";
			if( dwIndex != 0 )
			{
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayIndex+1 ); // db field는 1부터 이므로 +1

				g_LogDBClient.OnInsertCashItem( this, kExtraItem.m_iItemCode,  ( kExtraItem.m_iReinforce*10000 ) + iPeriodTime, iPayAmt, szItemIndex, LogDBClient::CIT_EXTRA, GetBillingGUID().c_str() ); // ( 장비 성장값 * 10000 ) + 장비기간. ex)장비기간값이 0이면 무제한 - 선물하기와 같은 구조  
			}
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "ExtraItemLOG : AddItem(%s:%d) : %d-%d : Cash", GetPublicID().c_str(), GetUserIndex(), iMachineCode, kExtraItem.m_iItemCode );
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Extraitem2 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );

			// 예외처리
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			kReturn << EXTRAITEM_EXCEPTION;
			kReturn << 1;
			SendMessage( kReturn );
			return;
		}
	} // bPackage == false;

	int iPreCash = GetCash();
	int iPreRealCash		= GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_EXCEPTION;
		kReturn << 2;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_EXTRAITEM_BUY, EXTRAITEM_EXCEPTION ) )
			return;
	}


	//HRYOON 보너스 캐쉬 사용
	int iBonusCashSize = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iBonusCashSize) );
	for( int i = 0; i < iBonusCashSize; i++ )
	{
		int iIndex	= 0;
		int iValue	= 0;
		PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(iValue) );
		//보너스 캐쉬 사용!
		if( !m_UserBonusCash.SpendBonusCash(iIndex, iValue, LogDBClient::CIT_EXTRA, kExtraItem.m_iItemCode, ( kExtraItem.m_iReinforce*10000 ) + iPeriodTime) )
		{
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			kReturn << EXTRAITEM_EXCEPTION;
			kReturn << 2;
			SendMessage( kReturn );

			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error : publicID:%s(userIndex:%d)guid:%s, index:%d,money:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iIndex, iValue );

			
		}
	}

	__int64 iPreMoney = GetMoney();
	int iBonusPeso = g_ExtraItemInfoMgr.GetBonusPeso( iMachineCode );
	if( iBonusPeso > 0 )
	{
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_EXTRAITEM, kExtraItem.m_iItemCode, iBonusPeso, NULL);
	}

	iBuyType	= PRESENT_EXTRAITEM;
	iValue1		= kExtraItem.m_iItemCode;
	iValue2		= kExtraItem.m_iValue1;

	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);



	if( bPackage )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_PACKAGE_BUY_OK;
		kReturn << GetMoney();
		kReturn << GetCash();
		kReturn << GetChannelingCash();
		kReturn << iMachineCode;				// MachineCode
		SendMessage( kReturn );
	}
	else
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_BUY_OK;
		kReturn << kExtraItem.m_iItemCode;
		kReturn << kExtraItem.m_iReinforce;
		kReturn << iSlotIndex;
		kReturn << kExtraItem.m_iTradeState;
		kReturn << kExtraItem.m_PeriodType;
		kReturn << kExtraItem.m_iValue1;
		kReturn << kExtraItem.m_iValue2;
		kReturn << kExtraItem.m_dwMaleCustom;
		kReturn << kExtraItem.m_dwFemaleCustom;
		kReturn << iPeriodTime;
		kReturn << GetMoney();
		kReturn << GetCash();
		kReturn << GetChannelingCash();
		kReturn << iMachineCode;				// MachineCode
		kReturn << bAlarm;
		kReturn << iBonusPeso;
		SendMessage( kReturn );
	}
	
	SaveExtraItem();
	SaveUserData();


	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Success userID:%s, userIndex:%d, GUID:%s, MachineCode:%d, ItemCode:%d, Reinforce:%d, UsedCash:%d, ItemPrice:%d, BonusPeso:%d",
		__FUNCTION__, GetPrivateID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iMachineCode, kExtraItem.m_iItemCode, ( kExtraItem.m_iReinforce*10000 ) + iPeriodTime, iPayAmt, iBuyCash, iBonusPeso );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, false, ioPresentHelper::BT_EXTRA_BOX, iMachineCode, 0, iPayAmt);
	}

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(), PRESENT_EXTRAITEM, kExtraItem.m_iItemCode, iPeriodTime);
}


void User::_OnBillingOutputCashPresent( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID )
{
	
	// Parsing
	short iPresentType = 0;
	int   iBuyValue1   = 0;
	int   iBuyValue2   = 0;
	DWORD dwRecvUserIndex = 0;

	PACKET_GUARD_VOID( rkPacket.Read(iPresentType) );
	PACKET_GUARD_VOID( rkPacket.Read(iBuyValue1) );
	PACKET_GUARD_VOID( rkPacket.Read(iBuyValue2) );
	PACKET_GUARD_VOID( rkPacket.Read(dwRecvUserIndex) );

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	int iBuyCash = g_PresentHelper.GetCash( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Wrong : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( iBuyCash != iPayAmt )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Different : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	// 구매한 선물
	if( !g_PresentHelper.InsertUserPresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2, false, true ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2 );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	//HRYOON 20141222 마일리지 선물함에 쏨, 인니일 경우에만..
	if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_INDONESIA && g_EventMgr.isMileageShopOpen() )
	{
		int iMileage	= 0;
		if( iPayAmt < 0)
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
		}
		else 
		{
			// 20150716 마일리지 비율 수정 z3
			/*if( IsPCRoomAuthority() )
				iMileage = (iPayAmt  * g_EventMgr.GetPcRoomMileageRatio()) / 100;
			else
				iMileage = (iPayAmt / 100) * g_EventMgr.GetMileageRatio();*/
		                                       
			CTime cCurTime = CTime::GetCurrentTime();
			if ( Help::ConvertCTimeToDate( cCurTime ) >= Help::ConvertCTimeToDate( g_EventMgr.GetLosaStartDate() ) && 
				( Help::ConvertCTimeToDate( cCurTime ) < Help::ConvertCTimeToDate( g_EventMgr.GetLosaEndDate() ) ) )
			{
				int iMilegeRatio	= 0;
				if( IsPCRoomAuthority() )

					iMilegeRatio = g_EventMgr.GetPcRoomMileageRatio();
				else 
					iMilegeRatio  = g_EventMgr.GetLosaMileageRatio();


				iMileage = (iPayAmt / 100) * iMilegeRatio;
			}
			else
			{
				if( IsPCRoomAuthority() )
					iMileage = (iPayAmt / 100) * g_EventMgr.GetPcRoomMileageRatio();
				else
					iMileage = (iPayAmt / 100) * g_EventMgr.GetMileageRatio();

			}
			// 마일리지가 0이면 선물보내지 않음
			if( iMileage <= 0 )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Mileage 0 : %s:%s:%d:%d[%d:%d:%d:%d:mileage:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2, iMileage );
				ClearBillingGUID();
				return;
			}
			if( !g_PresentHelper.InsertUserPresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), GetUserIndex(), iPresentType, ioEtcItem::EIT_ETC_MILEAGE_COIN, iMileage, false, true ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
				ClearBillingGUID();
				SP2Packet kReturn( STPK_PRESENT_BUY );
				kReturn << PRESENT_BUY_BILLING_FAIL;
				SendMessage( kReturn );

				if( pLocal )
					pLocal->SendRefundCash( this, iTransactionID, true );
				return;
			}
			//HRYOON 20141222 선물함 갱신, 바로 마일리지 들어오도록..
			enum { SELECT_CNT = 30, };
			_OnSelectPresent( SELECT_CNT );
		}
	}

	PresentBuyEventNode* pPresentBuyNode = static_cast< PresentBuyEventNode* > (g_EventMgr.GetNode(EVT_PRESENT_BUY));
	BOOL bBuyPresentEvent	= FALSE;

	if( pPresentBuyNode )
	{
		if( pPresentBuyNode->IsAlive() )
		{
			if( pPresentBuyNode->IsEventItem(iPresentType, iBuyValue1) )
			{
				//선물 구매한 유저도 선물 지급.
				if( g_PresentHelper.InsertUserPresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2, false, true ) )
				{	
					bBuyPresentEvent	= TRUE;
					_OnSelectPresent( 30 );
				}
				else
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][presentevent]Buy user insert present fail : [%d][%d][%d][%d]", GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2);
			}
			
		}
	}

	// 보너스 페소
	__int64 iPreMoney = GetMoney();
	int iBonusPeso = g_PresentHelper.GetBonusPeso( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBonusPeso > 0 )
	{
		if( !g_PresentHelper.InsertUserPresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), dwRecvUserIndex, PRESENT_PESO, iBonusPeso, 0, true, true ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present Peso : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2 );
			ClearBillingGUID();
			SP2Packet kReturn( STPK_PRESENT_BUY );
			kReturn << PRESENT_BUY_BILLING_FAIL;
			SendMessage( kReturn );

			if( pLocal )
				pLocal->SendRefundCash( this, iTransactionID, true );
			return;
		}

		if( bBuyPresentEvent )
		{
			if( g_PresentHelper.InsertUserPresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), GetUserIndex(), PRESENT_PESO, iBonusPeso, 0, true, true ) )
				_OnSelectPresent( 30 );
		}
	}

	// 구매 선물
	static IntVec vEventTypeVec;
	vEventTypeVec.clear();

	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();

	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
		{
			if( !pEventNode->InsertUserPresentByBuyPresent( this, false, dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2 ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present Item : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2 );
				ClearBillingGUID();
				SP2Packet kReturn( STPK_PRESENT_BUY );
				kReturn << PRESENT_BUY_BILLING_FAIL;
				SendMessage( kReturn );

				if( pLocal )
					pLocal->SendRefundCash( this, iTransactionID, true );
				return;
			}

			if( bBuyPresentEvent )
			{
				if( pEventNode->InsertUserPresentByBuyPresent( this, false, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2, true ) )
				{
					_OnSelectPresent( 30 );
				}
			}
		}
	}

	// 선물 받을 유저에게 알림
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( dwRecvUserIndex );
	if( pUserParent )
	{
		enum { SELECT_CNT = 30, };
		if( pUserParent->IsUserOriginal() )
		{
			User *pUser = (User*)pUserParent;
			if( pUser )
				pUser->_OnSelectPresent( SELECT_CNT );
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserParent;
			SP2Packet kPacket( SSTPK_PRESENT_SELECT );
			kPacket << dwRecvUserIndex << SELECT_CNT;
			pUser->SendMessage( kPacket );
		}
	}

	int iPreCash = GetCash();
	int iPrePurchasedCash = GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_PRESENT_BUY );
		kReturn << PRESENT_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_PRESENT_BUY, PRESENT_BUY_BILLING_FAIL ) )
			return;
	}

	SP2Packet kReturn( STPK_PRESENT_BUY );
	kReturn << PRESENT_BUY_SUCCESS;
	kReturn << GetMoney();
	kReturn << GetCash();
	kReturn << GetPurchasedCash();
	kReturn << GetChannelingCash();
	SendMessage( kReturn );

	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%d:%d:%d", iPresentType, iBuyValue1, iBuyValue2 ); // 스트링 형식 수정 불가, DB에서 파싱해서 사용함.

	//LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s User Present Success %s:%s:[%d:%d:%d:%d]%dCash:%dPrice:%dPreCash:%I64dMoney:%I64dPreMoney:%dBonusPeso:%dPreChannelingCash:%dChannelingCash:%dPrePurchasedCash:%dPurchasedCash", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2, GetCash(), iPayAmt, iPreCash, GetMoney(), iPreMoney, iBonusPeso, iPreChannelingCash, GetChannelingCash(), iPrePurchasedCash, GetPurchasedCash() );
	g_LogDBClient.OnInsertCashItem( this, iBuyValue1, iBuyValue2, iPayAmt, szItemIndex, LogDBClient::CIT_PRESENT, GetBillingGUID().c_str() );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s User Present Success %s:%s:[%d:%d:%d:%d]%dCash:%dPrice:%dPreCash:%I64dMoney:%I64dPreMoney:%dBonusPeso:%dPreChannelingCash:%dChannelingCash:%dPrePurchasedCash:%dPurchasedCash", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2, GetCash(), iPayAmt, iPreCash, GetMoney(), iPreMoney, iBonusPeso, iPreChannelingCash, GetChannelingCash(), iPrePurchasedCash, GetPurchasedCash() );
	//LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s User Present Success %s:%s:[%d:%d:%d:%d]%dCash:%dPrice:%dPreCash:%I64dMoney:%I64dPreMoney:%dBonusPeso:%dPreChannelingCash:%dChannelingCash:%dPrePurchasedCash:%dPurchasedCash", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2, GetCash(), iPayAmt, iPreCash, GetMoney(), iPreMoney, iBonusPeso, iPreChannelingCash, GetChannelingCash(), iPrePurchasedCash, GetPurchasedCash() );

	ClearBillingGUID();

	//비밀상점 목록일 경우 처리
	if( PRESENT_ETC_ITEM == iPresentType )
	{
		ioEtcItem* pEtcItem = g_EtcItemMgr.FindEtcItem(iBuyValue1);
		if( pEtcItem )
		{
			if( pEtcItem->IsSpecialGoods() )
			{
				SP2Packet kMainPacket( MSTPK_SPECIAL_SHOP_GOODS_BUY_RESULT );
				PACKET_GUARD_VOID( kMainPacket.Write(SPECIAL_SHOP_GOODS_BUY_RESULT_OK) );
				PACKET_GUARD_VOID( kMainPacket.Write(iBuyValue1) );
				PACKET_GUARD_VOID( kMainPacket.Write(GetUserIndex()) );

				g_MainServer.SendMessage( kMainPacket );
			}
		}
	}

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	//HRYOON 20160412 선물보냈을때 해당 유저에게 전달되어야함
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN ||
		ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND &&
		g_App.GetUseBuyItemEvent() == 1 )
	{
		if( iBuyValue1 == g_App.GetEventItemValue1() 
			//||  iServerValue == g_App.GetEventItemValue2() 
			)
		{
			g_DBClient.OnSelectPrivateID( GetUserDBAgentID(), GetAgentThreadID(), dwRecvUserIndex );
		}
	}
	

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPrePurchasedCash, GetCash(), GetPurchasedCash(), iPresentType, iBuyValue1, iBuyValue2);
	m_TitleInven.CheckTitleValue(TITLE_CONSUME_PRESENT_GOLD, iPayAmt);
}
     

void User::_OnBillingOutputCashCostume( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID, int& iBuyType, int& iValue1, int& iValue2 )
{
	// Parsing
// 	int   iMachineCode = 0;
// 	PACKET_GUARD_VOID( rkPacket.Read(iMachineCode) );
// 
// 	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
// 
// 	int iBuyCash = g_CostumeShopGoodsMgr.GetNeedCash(iMachineCode);
// 	if( iBuyCash <= 0 )
// 	{
// 		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Wrong : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
// 		ClearBillingGUID();
// 		SP2Packet kReturn( STPK_COSTUME_BUY );
// 		PACKET_GUARD_VOID(kReturn.Write(ITEM_BUY_BILLING_FAIL));
// 		SendMessage( kReturn );
// 
// 		if( pLocal )
// 			pLocal->SendRefundCash( this, iTransactionID, true );
// 		return;
// 	}
// 
// 	if( iBuyCash != iPayAmt )
// 	{
// 		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Different : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
// 		ClearBillingGUID();
// 		SP2Packet kReturn( STPK_COSTUME_BUY );
// 		PACKET_GUARD_VOID(kReturn.Write(ITEM_BUY_BILLING_FAIL));
// 		SendMessage( kReturn );
// 
// 		if( pLocal )
// 			pLocal->SendRefundCash( this, iTransactionID, true );
// 		return;
// 	}
// 
// 	int iPreCash = GetCash();
// 	int iPreChannelingCash = GetChannelingCash();
// 	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
// 	if( !pNode )
// 	{
// 		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
// 		ClearBillingGUID();
// 		SP2Packet kReturn( STPK_COSTUME_BUY );
// 		kReturn << ITEM_BUY_EXEPTION;
// 		SendMessage( kReturn );
// 
// 		if( pLocal )
// 			pLocal->SendRefundCash( this, iTransactionID, true );
// 		return;
// 	}
// 
// 	if( pLocal )
// 	{
// 		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_COSTUME_BUY, ITEM_BUY_EXEPTION ) )
// 			return;
// 	}

	//DB이용해서 insert후 나머지 처리

}

void User::OnBillingLogin( SP2Packet &rkPacket )
{
	
	ioHashString szBillingGUID;
	int          iReturnValue;

	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;
#ifdef LOCAL_DBG
	iReturnValue = 1; //park 빌링에서 결과값! 이상해! 고쳐야 함..ㅠㅠ
#endif	
	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s:%s:%s", __FUNCTION__,GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		SendMessage( kReturn );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(),szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		SendMessage( kReturn );
		return;
	}

	if( iReturnValue != BILLING_LOGIN_RESULT_SUCCESS )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return: %s:%s:%d", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), iReturnValue );
		bool bError = false;
		ioHashString sError;
		rkPacket >> bError;
		if( bError )
			rkPacket >> sError;
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		if( bError )
		{
			kReturn << bError;
			kReturn << sError;
		}
		SendMessage( kReturn );
		// 태국 추가 해야함
		//ClearBillingGUID();
		return;
	}

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
	{
		if( !pLocal->ApplyLogin( this, rkPacket ) )
			return;
	}

	ioHashString sLoginID = GetPrivateID();
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Success %s : %s:%s", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), sLoginID.c_str() );

	ClearBillingGUID();
	g_DBClient.OnSelectMemberConut( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPrivateID() );

	//g_LogDBClient.OnInsertPCRoom( this, 0, LogDBClient::PCT_LOGIN, LogDBClient::PCST_FREE_PCROOM );
}

void User::OnBillingRefundCash( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int          iReturnValue;

	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s(%d):%s:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s(%d):%s:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		return;
	}

	if( iReturnValue != BILLING_REFUND_CASH_RESULT_SUCCESS )
	{
		// 북미만 사용함, 패킷을 더 만들 필요가 없어 기존 캐쉬 패킷을 사용
		bool bBillingError = false;
		ioHashString sBillingError;

		rkPacket >> bBillingError;
		if( bBillingError )
			rkPacket >> sBillingError;
		
		SP2Packet kReturn( STPK_GET_CASH );
		kReturn << GET_CASH_BILLING_FAIL;
		kReturn << true;
		kReturn << bBillingError;
		if( bBillingError )
			kReturn << sBillingError;
		SendMessage( kReturn );

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s ReturnValue is Error : %s(%d):%s:%s[%s]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str(), sBillingError.c_str() );
		return;
	}

	ClearBillingGUID();

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s complete: %s(%d):%s:(%s)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), m_szBillingUserKey.c_str() );
}

void User::OnBillingUserInfo( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	ioHashString szPrivateID;

	rkPacket >> szBillingGUID;
	rkPacket >> szPrivateID;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s:%s:%s", __FUNCTION__, szPrivateID.c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		SendMessage( kReturn );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s:%s:%s", __FUNCTION__, szPrivateID.c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		SendMessage( kReturn );
		return;
	}

	if( szPrivateID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s PrivateID empty: %s:%s:%s", __FUNCTION__, szPrivateID.c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		SendMessage( kReturn );
		return;
	}

	if( !g_App.IsRightID( szPrivateID.c_str() ))
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s PrivateID Wrong: %s:%s:%s", __FUNCTION__, szPrivateID.c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		SendMessage( kReturn );
		return;
	}

	bool bError = false;
	rkPacket >> bError;

	if( bError )
	{
		ioHashString sError;
		rkPacket >> bError;

		SP2Packet kReturn( STPK_CONNECT );
		kReturn << CONNECT_EXCEPT << "";
		if( bError )
		{
			kReturn << bError;
			kReturn << sError;
		}
		SendMessage( kReturn );

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return: %s:%s:%s:%s", __FUNCTION__, szPrivateID.c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), sError.c_str() );
		return;
	}

	ClearBillingGUID();

	//hr 멤버추가

	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN )
	{
		g_DBClient.OnInsertMemberLatin( GetUserDBAgentID(), GetAgentThreadID(), GetPrivateID(), szPrivateID, GetCountry() );
	}
	
	else if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_US )
	{
		//hr 유저 가입시 소문자로 변경
		ioHashString strPrivateID;
		strPrivateID = GetPrivateID().c_str();
		strPrivateID.MakeLower();
		g_DBClient.OnInsertMember( GetUserDBAgentID(), GetAgentThreadID(), strPrivateID, szPrivateID );
	}
	else
	{
		//hr 유저 가입시 소문자로 변경
		ioHashString strPrivateID;
		strPrivateID = GetPrivateID().c_str();
		strPrivateID.MakeLower();
		g_DBClient.OnInsertMember( GetUserDBAgentID(), GetAgentThreadID(), strPrivateID, szPrivateID );
	}
	g_DBClient.OnSelectUserLoginInfo( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPrivateID() );
}

void User::OnBillingAutoUpgradeLogin( SP2Packet &rkPacket )
{	
	ioHashString szBillingGUID;
	int          iReturnValue;

	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false ;
		SendMessage( kReturn );
		return;
	}

	if( iReturnValue != BILLING_LOGIN_RESULT_SUCCESS )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return: %s:%s:%s:%d", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iReturnValue );

		if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
		{
			SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
			kReturn << false;
			SendMessage( kReturn );

			ioHashString szEmpty;
			SetPrivateID( szEmpty ); // 초기화
			ClearBillingGUID();

			return;

		}
		// receive
		bool bError = false;
		ioHashString sError;
		rkPacket >> bError;
		if( bError )
			rkPacket >> sError;

		// return;
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		if( bError )
		{
			char szFullError[MAX_PATH]="";
			ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
			if( pLocal )
			{
				StringCbCopy( szFullError, sizeof( szFullError ), pLocal->GetOtherComanyErrorMent() );
				StringCbCat( szFullError, sizeof( szFullError ), sError.c_str() );
			}
			else
				StringCbCopy( szFullError, sizeof( szFullError ), sError.c_str() );
			
			kReturn << bError;
			kReturn << szFullError;
		}
		else
			kReturn << bError;

		SendMessage( kReturn );

		ioHashString szEmpty;
		SetPrivateID( szEmpty ); // 초기화
		ClearBillingGUID();
		return;
	}

	ioHashString sPrivateID;
	ioHashString sOTPID;
	int returnCode = 0;
	rkPacket >> sPrivateID;
	rkPacket >> sOTPID;	//hr 2014-11-11 아시아소프트 마이그레이션인 경우 여기에 유저 네임이 들어감
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
	{
		rkPacket >> returnCode; 
	}


	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
	{
		if( !pLocal->CheckDuplication( this, sPrivateID ) )
			return;
	}

	
	SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
	kReturn << true;
	if( !sPrivateID.IsEmpty() )
	{
		kReturn << sPrivateID;
		if( !sOTPID.IsEmpty() )
			kReturn << sOTPID;
		if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
		{
			kReturn << returnCode; 
	}
	}
	SendMessage( kReturn );

	
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Success %s:%s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), sPrivateID.c_str(), sOTPID.c_str() );

	ioHashString szEmpty;
	SetPrivateID( szEmpty ); // 초기화
	ClearBillingGUID();
}

void User::OnBillingAutoUpgradeOTP( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int          iReturnValue;

	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false ;
		SendMessage( kReturn );
		return;
	}

	if( iReturnValue != BILLING_OTP_RESULT_SUCCESS )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return: %s:%s:%s:%d", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iReturnValue );

		// receive
		bool bError = false;
		ioHashString sError;
		rkPacket >> bError;
		if( bError )
			rkPacket >> sError;

		// return;
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		if( bError )
		{
			char szFullError[MAX_PATH]="";
			ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
			if( pLocal )
			{
				StringCbCopy( szFullError, sizeof( szFullError ), pLocal->GetOtherComanyErrorMent() );
				StringCbCat( szFullError, sizeof( szFullError ), sError.c_str() );
			}
			else
				StringCbCopy( szFullError, sizeof( szFullError ), sError.c_str() );

			kReturn << bError;
			kReturn << szFullError;
		}
		else
			kReturn << bError;

		SendMessage( kReturn );

		ioHashString szEmpty;
		SetPrivateID( szEmpty ); // 초기화
		ClearBillingGUID();
		return;
	}

	SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
	kReturn << true;
	SendMessage( kReturn );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Success %s:%s:", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str() );

	ioHashString szEmpty;
	SetPrivateID( szEmpty ); // 초기화
	ClearBillingGUID();
}

void User::OnBillingGetMileage( SP2Packet &rkPacket )
{
	ioHashString szDummy;
	int          iReturnValue = 0;

	rkPacket >> szDummy;
	rkPacket >> iReturnValue;

	if( iReturnValue != BILLING_GET_MILEAGE_RESULT_SUCCESS )
	{
		SP2Packet kReturn( STPK_GET_MILEAGE );

		PACKET_GUARD_VOID( kReturn.Write(GET_MILEAGE_EXCEPTION) );

		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return : %d : %s : %d", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str(), iReturnValue );
		return;
	}

	int iMileage = 0;
	rkPacket >> iMileage;

	SP2Packet kReturn( STPK_GET_MILEAGE );

	PACKET_GUARD_VOID( kReturn.Write(GET_MILEAGE_SUCCESS) );
	PACKET_GUARD_VOID( kReturn.Write(iMileage) );

	SendMessage( kReturn );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Success %d:%s:%d:", __FUNCTION__, GetUserIndex(), GetPrivateID().c_str(), iMileage );
}

void User::OnBillingAddMileage( SP2Packet &rkPacket )
{
	ioHashString szDummy;
	int          iReturnValue = 0;

	rkPacket >> szDummy;
	rkPacket >> iReturnValue;
	if( iReturnValue != BILLING_ADD_MILEAGE_RESULT_SUCCESS )
	{
		bool bError = false;
		ioHashString szError;
		rkPacket >> bError;
		if( bError )
		{
			rkPacket >> szError;
		}

		SP2Packet kReturn( STPK_ADD_MILEAGE );
		kReturn << ADD_MILEAGE_EXCEPTION;
		if( bError )
		{
			kReturn << true;
			kReturn << szError;
		}
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return : %d : %s : %d", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str(), iReturnValue );
		return;
	}

	int iMileage = 0;
	int iAddMileage = 0;
	rkPacket >> iMileage;
	rkPacket >> iAddMileage;

	SP2Packet kReturn( STPK_ADD_MILEAGE );
	kReturn << ADD_MILEAGE_SUCCESS;
	kReturn << iMileage;
	kReturn << iAddMileage;
	SendMessage( kReturn );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Success %d:%s:%d:%d", __FUNCTION__, GetUserIndex(), GetPrivateID().c_str(), iMileage, iAddMileage );
}

void User::OnBillingIPBonus( SP2Packet &rkPacket )
{
	ioHashString szDummy;
	int          iReturnValue = 0;

	rkPacket >> szDummy;
	rkPacket >> iReturnValue;
	if( iReturnValue != BILLING_IPBONUS_RESULT_SUCCESS )
	{
		bool bError = false;
		ioHashString szError;
		rkPacket >> bError;
		if( bError )
		{
			rkPacket >> szError;
		}
		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return : %d : %s : %d : %s", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str(), iReturnValue, szError );
		return;
	}

	rkPacket >> m_dwPCRoomNumber;
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]OnBillingIPBonus PCRoom Index : [%d] [%d]", GetUserIndex(), m_dwPCRoomNumber );

	if( g_EventMgr.IsAlive( EVT_FREEDAY_HERO, GetChannelingType() ) )
	{
		if( GetPCRoomNumber() == 0 )
			SendFreeDayEvent(FREEDAY_EVENT_CODE);
	}
	else
	{
		if( GetPCRoomNumber() == FREEDAY_EVENT_CODE )
			SendFreeDayEvent(0);
	}

	// 접속 완료 되었으면 유저에게 즉시 알림
	if( IsConnectProcessComplete() )
	{
		SP2Packet kPacket( STPK_PCROOM_AUTHORITY );
		PACKET_GUARD_VOID( kPacket.Write( GetPCRoomNumber() ) );
		PACKET_GUARD_VOID( kPacket.Write( m_UserPcRoom.GetPcRoomCharMax() ) );
		SendMessage( kPacket );
	}

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Success %d:%s:%d", __FUNCTION__, GetUserIndex(), GetPrivateID().c_str(), m_dwPCRoomNumber );
}

void User::OnAutoUpgradeLogin( SP2Packet &rkPacket )
{
	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	// 게임서버 종료 처리 중
	if(g_App.IsReserveLogOut())
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		if( pLocal )
		{
			kReturn << true;
			char szMent[MAX_PATH]="";
			StringCbCopy( szMent , sizeof( szMent ), pLocal->GetExitingServerMent() );
			kReturn << szMent;
		}
		else
			kReturn << false;
		SendMessage( kReturn );
		return;
	}

	//hr 2014-11-11 아시아 소프트 마이그레이션용 임시 코드
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
	{
		ioHashString szToken;
		ioHashString szAsiasoftPrivateID;
		ioHashString szPublicIP;

		rkPacket >> szToken;
		rkPacket >> szAsiasoftPrivateID;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		SetBillingGUID( szTempGUID );

		// 유저 공인IP 확인
		char szPeerIP[MAX_PATH]="";
		int  iPeerPort = 0;
		if( GetPeerIP( szPeerIP, sizeof( szPeerIP ), iPeerPort ) )
			szPublicIP = szPeerIP;



		SP2Packet kBillingPacket( BSTPK_LOGIN );
		kBillingPacket << GetBillingGUID();
		kBillingPacket << szAsiasoftPrivateID;
		kBillingPacket << szToken;
		kBillingPacket << szPublicIP; 
		kBillingPacket << BSTPK_AUTOUPGRADE_LOGIN_RESULT; // return msg type

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
		
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send Fail : %s:%s", __FUNCTION__, szAsiasoftPrivateID.c_str(), GetBillingGUID().c_str() );
			SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
			kReturn << false;
			SendMessage( kReturn );
			ClearBillingGUID();
		}
		SetPrivateID( szAsiasoftPrivateID );

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnAutoUpgradeLogin Migration AsiaSoft privateID : %s", szAsiasoftPrivateID.c_str() );
		return;
	}

	ioHashString szPrivateID;
	ioHashString szEncodePW;
	ioHashString szPublicIP;
	ioHashString szValue1;
	ioHashString szValue2;

	rkPacket >> szPrivateID;	//Real ID
	rkPacket >> szEncodePW;		
	rkPacket >> szPublicIP;		//ip 

	
	if( pLocal )
	{
		pLocal->ApplyRequestLogin( rkPacket, szValue1, szValue2 );

		m_szMacAddress = szValue1;
		m_szPremiumKey = szValue2;

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "jal mac %s, [%s], privateID : %s", m_szMacAddress.c_str() , m_szPremiumKey.c_str(), szPrivateID.c_str() );
	}
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_EU )
	{
		if( !szValue1.IsEmpty() )
			szEncodePW = szValue1;
	}

	if( pLocal && pLocal->IsPrivateLowerID() )
	{
		szPrivateID.MakeLower();
	}

	if( pLocal && !pLocal->IsRightID( szPrivateID.c_str() ) )
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error ID: %s", __FUNCTION__, szPrivateID.c_str() );
		m_sync_time = TIMEGETTIME();
		return;
	}

	if( szEncodePW.IsEmpty()  )
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Data Empty.: %s:%s", __FUNCTION__, szPrivateID.c_str() , szEncodePW.c_str() );
		m_sync_time = TIMEGETTIME();
		return;
	}
	if( g_UserNodeManager.IsConnectUser( szPrivateID ) )  //접속중..
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		if( pLocal )
		{
			kReturn << true;
			char szMent[MAX_PATH]="";
			StringCbCopy( szMent , sizeof( szMent ), pLocal->GetDuplicationMent() );
			kReturn << szMent;
		}
		else
			kReturn << false;
		SendMessage( kReturn );

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Exist User: %s:%s", __FUNCTION__, szPrivateID.c_str() , szEncodePW.c_str() );
		m_sync_time = TIMEGETTIME();
			
		//[HRYOON 중복접속]
		if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
		{
			//상대방 유저 접속 끊음
			User *pNode = g_UserNodeManager.GetUserNodeByPrivateID( szPrivateID );
			pNode->SessionClose();

			//gameserverID 초기화
			g_DBClient.OnUpdateUserLogout( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), szPrivateID );

		}
		return;
	}
	
	
	SetPrivateID( szPrivateID );

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	SetBillingGUID( szTempGUID );

	// 유저 공인IP 확인
	char szPeerIP[MAX_PATH]="";
	int  iPeerPort = 0;
	if( GetPeerIP( szPeerIP, sizeof( szPeerIP ), iPeerPort ) )
		szPublicIP = szPeerIP;

	
	SP2Packet kBillingPacket( BSTPK_LOGIN );
	kBillingPacket << GetBillingGUID();
	kBillingPacket << GetPrivateID();
	kBillingPacket << szEncodePW;
	kBillingPacket << szPublicIP; 
	kBillingPacket << BSTPK_AUTOUPGRADE_LOGIN_RESULT; // return msg type
	
	if( pLocal )
	{
		pLocal->FillRequestLogin( kBillingPacket, szValue1, szValue2 );
	}
	
	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send Fail : %s:%s(%s)", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), szEncodePW.c_str() );
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_LOGIN_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		ClearBillingGUID();
	}
	else
		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send : %s:%s(%s)", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), szEncodePW.c_str() );

	m_sync_time = TIMEGETTIME();
}

void User::OnBillingPCRoom( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int          iReturnValue = 0;

	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		ClearBillingGUID();
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s:%s:%s", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		ClearBillingGUID();
		return;
	}

	if( iReturnValue != CASH_RESULT_SUCCESS )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error ReturnValue: %s:%s:%s:%d", __FUNCTION__, GetPrivateID().c_str(), szBillingGUID.c_str(), GetBillingGUID().c_str(), iReturnValue );
		ClearBillingGUID();
		return;
	}
	
	rkPacket >> m_dwPCRoomNumber;
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]OnBillingPCRoom PCRoom Index : [%d] [%d]", GetUserIndex(), m_dwPCRoomNumber );

	if( g_EventMgr.IsAlive( EVT_FREEDAY_HERO, GetChannelingType() ) )
	{
		if( GetPCRoomNumber() == 0 )
			SendFreeDayEvent(FREEDAY_EVENT_CODE);
	}
	else
	{
		if( GetPCRoomNumber() == FREEDAY_EVENT_CODE )
			SendFreeDayEvent(0);
	}

	// 접속 완료 되었으면 유저에게 즉시 알림
	if( IsConnectProcessComplete() )
	{
		SP2Packet kPacket( STPK_PCROOM_AUTHORITY );			
		PACKET_GUARD_VOID( kPacket.Write( GetPCRoomNumber() ) );
		PACKET_GUARD_VOID( kPacket.Write( m_UserPcRoom.GetPcRoomCharMax() ) );
		SendMessage( kPacket );
	}

// 	if( m_cLoginTime == 0 )
// 	{
// 		m_cLoginTime = CTime::GetCurrentTime();
// 		g_LogDBClient.OnInsertPCRoom( this, 0, LogDBClient::PCT_LOGIN, LogDBClient::PCST_FREE_PCROOM );
// 	}

	InsertLoginRecord();	

	LOG.PrintTimeAndLog( 0, "User::OnBillingPCRoom : %s - %s - %d", GetPublicID().c_str(), GetPublicIP(), m_dwPCRoomNumber );
	ClearBillingGUID();
}

void User::OnBillingAddCash( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	rkPacket >> szBillingGUID;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingAddCash BillingGUID Is Empty: %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_ADD_CASH );
		kReturn << ADD_CASH_BILLING_FAIL;
		SendMessage( kReturn );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingAddCash Wrong BillingGUID : %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_ADD_CASH );
		kReturn << ADD_CASH_BILLING_FAIL;
		SendMessage( kReturn );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingAddCash pNode is NULL: %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_ADD_CASH );
		kReturn << ADD_CASH_BILLING_FAIL;
		SendMessage( kReturn );
		return;
	}

	pNode->OnRecieveAddCash( this, rkPacket );
}

void User::OnBillingFillCashUrl( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int iReturnValue = 0;
	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: %s(%d):%s:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_FILL_CASH_URL );
		kReturn << FILL_CASH_URL_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID : %s(%d):%s:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_FILL_CASH_URL );
		kReturn << FILL_CASH_URL_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	if( iReturnValue != CASH_RESULT_SUCCESS )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error Return : %s(%d):%s:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_FILL_CASH_URL );
		kReturn << FILL_CASH_URL_EXCEPTION;
		SendMessage( kReturn );
		ClearBillingGUID();
		return;
	}

	ioHashString szFillCashUrl;
	rkPacket >> szFillCashUrl;

	SP2Packet kReturn( STPK_FILL_CASH_URL );
	kReturn << FILL_CASH_URL_OK;
	kReturn << szFillCashUrl;
	SendMessage( kReturn );
	ClearBillingGUID();

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Success %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
}

void User::OnAutoUpgradeOTP( SP2Packet &rkPacket )
{
	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	// 게임서버 종료 처리 중
	if(g_App.IsReserveLogOut())
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		if( pLocal )
		{
			kReturn << true;
			char szMent[MAX_PATH]="";
			StringCbCopy( szMent , sizeof( szMent ), pLocal->GetExitingServerMent() );
			kReturn << szMent;
		}
		else
			kReturn << false;
		SendMessage( kReturn );
		return;
	}

	ioHashString szPrivateID;
	ioHashString szEncodePW;

	rkPacket >> szPrivateID;
	rkPacket >> szEncodePW;

	if( pLocal && !pLocal->IsRightID( szPrivateID.c_str() ) )
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error ID: %s", __FUNCTION__, szPrivateID.c_str() );
		m_sync_time = TIMEGETTIME();
		return;
	}

	if( szEncodePW.IsEmpty()  )
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Data Empty.: %s:%s", __FUNCTION__, szPrivateID.c_str() , szEncodePW.c_str() );
		m_sync_time = TIMEGETTIME();
		return;
	}

	if( g_UserNodeManager.IsConnectUser( szPrivateID ) )  //접속중..
	{
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		if( pLocal )
		{
			kReturn << true;
			char szMent[MAX_PATH]="";
			StringCbCopy( szMent , sizeof( szMent ), pLocal->GetDuplicationMent() );
			kReturn << szMent;
		}
		else
			kReturn << false;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Exist User: %s:%s", __FUNCTION__, szPrivateID.c_str() , szEncodePW.c_str() );
		m_sync_time = TIMEGETTIME();
		return;
	}

	SetPrivateID( szPrivateID );

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	SetBillingGUID( szTempGUID );

	SP2Packet kBillingPacket( BSTPK_OTP );
	kBillingPacket << GetBillingGUID();
	kBillingPacket << GetPrivateID();
	kBillingPacket << szEncodePW;

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send Fail : %s:%s(%s)", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), szEncodePW.c_str() );
		SP2Packet kReturn( ASTPK_OTHER_COMPANY_OTP_RESULT );
		kReturn << false;
		SendMessage( kReturn );
		ClearBillingGUID();
	}
	else
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Send : %s:%s(%s)", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str(), szEncodePW.c_str() );

	m_sync_time = TIMEGETTIME();
}

void User::OnHoleSendComplete( SP2Packet &rkPacket )
{
	ioHashString szUserID, szUserIP;
	int iPort;
	rkPacket >> szUserID >> szUserIP >> iPort;

	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szUserID );
	if( pUserParent )
	{
		SP2Packet kPacket( STPK_HOLE_SEND_COMPLETE );
		kPacket << GetPublicID() << szUserIP << iPort;
		pUserParent->RelayPacket( kPacket );

		if( !pUserParent->IsUserOriginal() )
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnHoleSendComplete Relay Packet : %s", szUserID.c_str() );

		// "나"한테 UDP 전송 가능하다
		BattleRoomParent *pBattleParent = GetMyBattleRoom();
		if( pBattleParent )
		{			
			pBattleParent->UserP2PRelayInfo( GetUserIndex(), pUserParent->GetUserIndex(), false );
		}
	}
	else
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnHoleSendComplete - NULL User ; %s", szUserID.c_str() );
}

void User::OnUDPRecvTimeOut( SP2Packet &rkPacket )
{
	ioHashString szUserID;
	rkPacket >> szUserID;

	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szUserID );
	if( pUserParent )
	{
		if( pUserParent->IsUserOriginal() )
		{
			User *pUser = (User*)pUserParent;
			if( pUser->IsRoomLoadingOrServerMoving() )
			{
				// 로딩중이므로 다시 연결 요청
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnUDPRecvTimeOut User Loading... : %s", szUserID.c_str() );
				SP2Packet kPacket( STPK_UDP_RECV_TIMEOUT_RECHECK );
				kPacket << szUserID;
				SendMessage( kPacket );
			}
			else
			{    
				SP2Packet kPacket( STPK_UDP_RECV_TIMEOUT );
				kPacket << GetPublicID();
				pUser->SendMessage( kPacket );

				// "나"한테 UDP 전송이 불가능하다
				BattleRoomParent *pBattleParent = GetMyBattleRoom();
				if( pBattleParent )
				{			
					pBattleParent->UserP2PRelayInfo( GetUserIndex(), pUser->GetUserIndex(), true );
				}
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnUDPRecvTimeOut Relay Packet : %s", szUserID.c_str() );
			
			// 해당 유저가 있는 서버로 전송하여 위와 같이 처리
			UserCopyNode *pUser = (UserCopyNode*)pUserParent;
			SP2Packet kServerPacket( SSTPK_UDP_RECV_TIMEOUT );
			kServerPacket << GetPublicID() << GetUserIndex() << szUserID << m_dwMyBattleRoom;
			pUser->SendMessage( kServerPacket );
		}		
	}
	else
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnUDPRecvTimeOut - NULL User ; %s", szUserID.c_str() );
}

void User::OnEventDataUpdate( SP2Packet &rkPacket )
{
	int iEventType = 0;
	rkPacket >> iEventType;
		
	EventUserNode *pEventNode = m_EventUserMgr.GetEventUserNode( (EventType) iEventType );
	if( pEventNode )
		pEventNode->OnRecievePacket( this, rkPacket );
	else
	{
		SP2Packet kReturn( STPK_EVENT_DATA_UPDATE );
		kReturn << iEventType;
		kReturn << EVENT_DATA_UPDATE_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEventDataUpdate pEventNode == NULL. %s : %d : %d", GetPublicID().c_str(), GetUserIndex(), iEventType );
	}
}

void User::OnServerLobbyInfo( SP2Packet &rkPacket )
{
	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_UserNodeManager.SendServerLobbyUserList( this, iCurPage, iMaxCount );
}

void User::OnCampDataSync( SP2Packet &rkPacket )
{
	// 메인 서버에 요청
	SP2Packet kPacket( MSTPK_CAMP_DATA_SYNC );
	kPacket << GetUserIndex();
	g_MainServer.SendMessage( kPacket );
}

void User::OnCampChangePos( SP2Packet &rkPacket )
{
	bool bShowResultUI = false;
	bool bDeleteDelayGuildList = false;
	bool bEnterCamp = false;
	int iPrevCampPosition = m_user_data.m_camp_position;
	int iCampPosition;
	rkPacket >> iCampPosition >> bDeleteDelayGuildList >> bShowResultUI;
	if( iCampPosition == 0 )
	{
		m_user_data.m_camp_position = iCampPosition;
	}
	else
	{
		bEnterCamp = true;
		m_user_data.m_camp_position = iCampPosition;
	}

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnCampChangePos %s : %d - > %d", GetPublicID().c_str(), iPrevCampPosition, m_user_data.m_camp_position );
	SP2Packet kPacket( STPK_CAMP_CAHNGE_POS );
	kPacket << m_user_data.m_camp_position << bShowResultUI;
	SendMessage( kPacket );

	if( iPrevCampPosition != m_user_data.m_camp_position )
	{
		// 래더 포인트 초기화
		SetLadderPoint( 0 );
		// 메인 서버의 진영 유저수 갱신
		if( bEnterCamp )
			iPrevCampPosition = m_user_data.m_camp_position;
		SP2Packet kMainPacket( MSTPK_CAMP_ENTRY_CHANGE );
		kMainPacket << iPrevCampPosition << bEnterCamp;
		g_MainServer.SendMessage( kMainPacket );

		SyncUserCamp();

		g_DBClient.OnUpdateUserCampPosition( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetUserCampPos() );
	}

	// 진영 타입 변경 쿼리 발송

	if( bDeleteDelayGuildList )
		g_DBClient.OnDeleteEntryDelayGuildList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex() );
}

void User::OnCampBattleEndLeaveTeam( SP2Packet &rkPacket )
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LeaveRoom();
		LeaveLadderTeam();
		ExitRoomToTraining( EXIT_ROOM_OK, false );
	}
	else
	{
		LeaveLadderTeam();
	}
}

void User::OnServerAlarmMsg( SP2Packet &rkPacket )
{
	SP2Packet kPacket( SUPK_SERVER_ALARM_MENT );
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_UserNodeManager.SendAllServerAlarmMent( kPacket );
}

void User::OnControlKeys( SP2Packet &rkPacket )
{
	ControlKeys kControlKeys;
	rkPacket >> kControlKeys;
	if( !kControlKeys.IsRight() )
	{
		//인트라넷에 로그 전송
		char szLog[2048] = "";
		sprintf_s( szLog, "%s Control Key is wrong. %d) %s", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		SP2Packet kPacket2( LUPK_LOG );
		kPacket2 << "ServerError";
		kPacket2 << szLog;
		g_UDPNode.SendLog( kPacket2 );
		LOG.PrintTimeAndLog( LOG_RELEASE_LEVEL, szLog );
		return;
	}

	m_kControlKeys = kControlKeys;
}

bool User::IsBuyExerciseChar( int iExerciseStyle )
{
	if( iExerciseStyle == EXERCISE_GENERAL )
	{
		if( GetPlayingMode() == MT_NONE )
			return true;
		if( GetPlayingMode() == MT_TRAINING )
			return true;
		if( GetPlayingMode() == MT_HEADQUARTERS )
			return true;
		return false;
	}
	return true;
}

EventUserManager &User::GetEventUserMgr()
{
	return m_EventUserMgr;
}

void User::SetEntryType( EntryType eEntryType )
{
	m_user_data.m_eEntryType = eEntryType;
}

EntryType User::GetEntryType() const
{
	return m_user_data.m_eEntryType;
}

bool User::IsEntryFormality() const
{
	if( m_user_data.m_eEntryType == ET_FORMALITY    ||
		m_user_data.m_eEntryType == ET_FORMALITY_CASH )
	{
		return true;
	}

	return false;
}

bool User::IsCanBuyItem( const ioSetItemInfo *pSetItemInfo )
{
	if( pSetItemInfo == NULL )
		return false;

	// 모든 제한이 해제된다.
	if( GetUserEventType() == USER_TYPE_LIMIT_IGNORE )
		return true;

	bool isCanBuy = false;
	int iMax = pSetItemInfo->GetNeedLevelInfoListCnt();
	for (int i = 0; i < iMax ; i++)
	{
		ioSetItemInfo::NeedLevelType eNeedType = pSetItemInfo->GetNeedLevelType( i );
		int iNeedLevel = pSetItemInfo->GetNeedLevel( i );
		isCanBuy = false;

		if( iNeedLevel == -1 )
			break;

		if( eNeedType == ioSetItemInfo::NLT_GRADE )
		{
			if( GetGradeLevel() >= iNeedLevel )
				isCanBuy = true;
		}
		else if( eNeedType == ioSetItemInfo::NLT_BATTLE )
		{
			if( GetPartyExp() >= g_LevelMgr.GetNextPartyupExp( iNeedLevel-1 ) )
				isCanBuy = true;
		}
		else if( eNeedType == ioSetItemInfo::NLT_AWARD )
		{
			if( m_Award.GetAwardLevel() >= iNeedLevel )
				isCanBuy = true;
		}

		if( isCanBuy == false )
			break;
	}

	return isCanBuy;
}

bool User::IsCanBuyItemBySameGradeLevel( const ioSetItemInfo *pSetItemInfo )
{
	if( pSetItemInfo == NULL )
		return false;

	// 모든 제한이 해제된다.
	if( GetUserEventType() == USER_TYPE_LIMIT_IGNORE )
		return true;

	bool isCanBuy = false;
	int iMax = pSetItemInfo->GetNeedLevelInfoListCnt();
	for (int i = 0; i < iMax ; i++)
	{
		ioSetItemInfo::NeedLevelType eNeedType = pSetItemInfo->GetNeedLevelType( i );
		int iNeedLevel = pSetItemInfo->GetNeedLevel( i );
		isCanBuy = false;

		if( iNeedLevel == -1 )
			break;

		if( eNeedType == ioSetItemInfo::NLT_GRADE )
		{
			if( GetGradeLevel() == iNeedLevel )
				isCanBuy = true;
		}

		if( isCanBuy == false )
			break;
	}

	return isCanBuy;
}

void User::ImmediatelyEquipItem( ioItem *pItem, const ioHashString& szItemName, int eObjectCreateType, SP2Packet &rkPacket )
{
	if( !pItem )
		return;

	if( !m_pMyRoom )
		return;

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ImmediatelyEquipItem() - Out of range %s:%d:%d", GetPublicID().c_str(), m_CharList.size(), m_select_char );
		return;
	}	

	SP2Packet kReturn( STPK_IMMEDIATELY_EQUIP );
	PACKET_GUARD_VOID( kReturn.Write( GetPublicID() ) );
	PACKET_GUARD_VOID( kReturn.Write( pItem->GetItemCode() ) );
	PACKET_GUARD_VOID( kReturn.Write( pItem->GetItemReinforce() ) );
	PACKET_GUARD_VOID( kReturn.Write( pItem->GetItemMaleCustom() ) );
	PACKET_GUARD_VOID( kReturn.Write( pItem->GetItemFemaleCustom() ) );
	PACKET_GUARD_VOID( kReturn.Write( pItem->GetGameIndex() ) );
	PACKET_GUARD_VOID( kReturn.Write( szItemName ) );
	PACKET_GUARD_VOID( kReturn.Write( eObjectCreateType ) );

	if( eObjectCreateType == OCT_EQUIP_BUFF1 || eObjectCreateType == OCT_EQUIP_BUFF2 )
	{
		ioHashString szControlBuffName;
		PACKET_GUARD_VOID( rkPacket.Read( szControlBuffName ) );
		
		PACKET_GUARD_VOID( kReturn.Write( szControlBuffName ) );
	}

	m_pMyRoom->RoomSendPacketTcp( kReturn );

	ioItem *pPreItem = m_CharList[m_select_char]->EquipItem( pItem );
	if( pPreItem )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ImmediatelyEquipItem() - PreItem is Exist" );
	}

	m_pMyRoom->NotifyPickItemToMode( pItem , this );

}

void User::DeleteGuildMarkChangeKeyValue()
{
	// 길드 마크 변경 암호 테이블
	if( m_dwGuildMarkChangeKeyValue != 0 )
		g_DBClient.OnUpdateGuildMarkChangeKeyValue( GetUserDBAgentID(), GetAgentThreadID(), m_dwGuildMarkChangeKeyValue );
	m_dwGuildMarkChangeKeyValue = 0;
}

void User::SetDefaultDecoItem( const CHARACTER &rkCharInfo )
{
	enum 
	{
		MAX_DEFAULT_DECO_ITEM = 5,
	};

	int iDecoTypeList[MAX_DEFAULT_DECO_ITEM]={ UID_FACE, UID_HAIR, UID_HAIR_COLOR, UID_SKIN_COLOR, UID_UNDERWEAR };
	ITEMSLOT kSlotList[MAX_DEFAULT_DECO_ITEM];
	bool bChange[MAX_DEFAULT_DECO_ITEM] = { false, false, false , false, false };
	for (int i = 0; i < MAX_DEFAULT_DECO_ITEM ; i++)
	{
		kSlotList[i] = GetItemSlot( iDecoTypeList[i], rkCharInfo );
		if( !m_Inventory.IsSlotItem( kSlotList[i] ) )
		{
			DWORD dwIndex = 0;
			int   iArray  = 0;
			m_Inventory.AddSlotItem( kSlotList[i], false, 0, LogDBClient::DT_DEFAULT, dwIndex, iArray ); //default 지급
			bChange[i] = true;
			
			if( dwIndex != 0 && dwIndex != ioInventory::NEW_INDEX )
			{
				char szItemIndex[MAX_PATH]="";
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertDeco( this, kSlotList[i].m_item_type, kSlotList[i].m_item_code, 0, szItemIndex, LogDBClient::DT_DEFAULT );
			}
		}

		int iEquipItemCode = m_Inventory.GetEquipItemCode( kSlotList[i].m_item_type );
		if( iEquipItemCode != kSlotList[i].m_item_code )
		{
			m_Inventory.SetEquipItem( kSlotList[i].m_item_type, kSlotList[i].m_item_code );
		}
	}	
	SaveInventory();

	int iSize = 0;
	for (int i = 0; i < MAX_DEFAULT_DECO_ITEM ; i++)
	{
		if( !bChange[i] )
			continue;
		iSize++;

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::SetDefaultDecoItem | %s | %d | %d", GetPublicID().c_str(), kSlotList[i].m_item_type, kSlotList[i].m_item_code );
	}

	if( iSize == 0 )
		return;

	SP2Packet kPacket( STPK_DEFAULT_DECO_ITEM );
	kPacket << iSize;
	for (int i = 0; i < MAX_DEFAULT_DECO_ITEM ; i++)
	{
		if( !bChange[i] )
			continue;

	   	kPacket << kSlotList[i].m_item_type;
		kPacket << kSlotList[i].m_item_code;
	}
	SendMessage( kPacket );	
}

ITEMSLOT User::GetItemSlot( int iDecoType, const CHARACTER &rkCharInfo )
{
	//고유 특성 1111 22 333 ( 세트, 종족(성별), 치장타입 )
	ITEMSLOT kSlot;
	kSlot.m_item_type = ( rkCharInfo.m_class_type * 100000 ) + ( ( rkCharInfo.m_sex - 1 )  * 1000 );
	kSlot.m_item_code = 0;
	switch( iDecoType )
	{
	case UID_FACE:
		{
			kSlot.m_item_type += iDecoType;
			kSlot.m_item_code =  rkCharInfo.m_face;
		}
		break;
	case UID_HAIR:
		{
			kSlot.m_item_type += iDecoType;
			kSlot.m_item_code =  rkCharInfo.m_hair;
		}
		break;
	case UID_SKIN_COLOR:
		{
			kSlot.m_item_type += iDecoType;
			kSlot.m_item_code =  rkCharInfo.m_skin_color;
		}
		break;
	case UID_HAIR_COLOR:
		{
			kSlot.m_item_type += iDecoType;
			kSlot.m_item_code =  rkCharInfo.m_hair_color;
		}
		break;
	case UID_UNDERWEAR:
		{
			kSlot.m_item_type += iDecoType;
			kSlot.m_item_code = rkCharInfo.m_underwear;
		}	
		break;
	}

	return kSlot;
}

RaceDetailType User::GetRaceDetailType( const CHARACTER &rkInfo )
{
	switch( rkInfo.m_kindred )
	{
	case 1:
		if( rkInfo.m_sex == 1 )
			return RDT_HUMAN_MAN;
		else
			return RDT_HUMAN_WOMAN;
		break;
	case 2:
		if( rkInfo.m_sex == 1 )
			return RDT_ELF_MAN;
		else
			return RDT_ELF_WOMAN;
		break;
	case 3:
		if( rkInfo.m_sex == 1 )
			return RDT_DWARF_MAN;
		else
			return RDT_DWARF_WOMAN;
		break;
	}

	return RDT_HUMAN_MAN;
}

void User::SetBillingGUID( const char* szGUID )
{
	m_szBillingGUID = szGUID;
}

void User::ClearBillingGUID()
{
	m_szBillingGUID.Clear();
}

void User::OnGrowthLevelUp( SP2Packet &rkPacket )
{
	bool bItem;
	int iClassType, iSlot, iGrowthInfoNum;

	rkPacket >> iClassType;
	rkPacket >> bItem;
	rkPacket >> iSlot;
	rkPacket >> iGrowthInfoNum;

	int iTimeSlot = 0;
	int iCurPoint = 0;
	int iCurLevel, iUpLevel;
	iCurLevel = iUpLevel = 0;

	iCurPoint = m_UserGrowthLevel.GetCharGrowthPoint( iClassType );

	if( bItem )
	{
		iCurLevel = m_UserGrowthLevel.GetItemGrowthLevel( iClassType, iSlot, true );
		iTimeSlot = iSlot + 1;
	}
	else
	{
		iCurLevel = m_UserGrowthLevel.GetCharGrowthLevel( iClassType, iSlot, true );
		iTimeSlot = iSlot + 1 + 4;
	}

	int iSelect = -2;

	int iCurMaxLevel = m_ClassExpert.GetClassLevel( iClassType );
	iCurMaxLevel = min( iCurMaxLevel, g_GrowthMgr.GetMaxLevel() );

	if( iCurLevel >= iCurMaxLevel )
		iUpLevel = 100;
	else
		iUpLevel = g_GrowthMgr.CheckUpLevel( iGrowthInfoNum, iCurLevel );

	if( iUpLevel == 100 )
	{
		// 실패 전송
		SP2Packet kPacket( STPK_GROWTH_LEVEL_UP );
		kPacket << GetPublicID();
		kPacket << GROWTH_UP_FAIL;
		SendMessage( kPacket );

		return;
	}

	__int64 iNeedPeso = g_GrowthMgr.GetGrowthUpNeedPeso( !bItem, iCurLevel+iUpLevel );
	int iNeedPoint = g_GrowthMgr.GetGrowthUpNeedPoint( !bItem );
	int iUsePoint = g_GrowthMgr.GetGrowthUpUsePoint( !bItem, iUpLevel );

	int iCheckPoint = iCurPoint;
	if( m_UserGrowthLevel.HasTimeGrowthValue( iClassType, iTimeSlot ) )
		iCheckPoint += iUsePoint;

	// 레벨업 체크
	// Point 체크
	if( iCheckPoint < iNeedPoint )
	{
		// 포인트 부족 실패 전송
		SP2Packet kPacket( STPK_GROWTH_LEVEL_UP );
		kPacket << GetPublicID();
		kPacket << GROWTH_UP_FAIL_POINT;
		SendMessage( kPacket );
		return;
	}

	// Peso 체크
	if( GetMoney() < iNeedPeso )
	{
		// Peso 부족 실패 전송
		SP2Packet kPacket( STPK_GROWTH_LEVEL_UP );
		kPacket << GetPublicID();
		kPacket << GROWTH_UP_FAIL_PESO;
		SendMessage( kPacket );
		return;
	}
	else
	{
		// 포이트/Peso 차감, 해당레벨 UP
		bool bRemove = m_UserGrowthLevel.RemoveTimeGrowth( iClassType, iTimeSlot );
		if( bRemove )
			iCurPoint += iUsePoint;

		iCurPoint -= iUsePoint;
		m_UserGrowthLevel.SetCharGrowthPoint( iClassType, iCurPoint );
		__int64 iPreMoney = GetMoney();
		RemoveMoney( iNeedPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_GROWTH, 0, 0, iNeedPeso, NULL);

		if( bItem )
			m_UserGrowthLevel.ItemGrowthLevelUp( iClassType, iSlot, iUpLevel );
		else
			m_UserGrowthLevel.CharGrowthLevelUp( iClassType, iSlot, iUpLevel );

		SP2Packet kPacket( STPK_GROWTH_LEVEL_UP );
		kPacket << GetPublicID();
		kPacket << GROWTH_UP_SUCESS;

		kPacket << iClassType;
		kPacket << bItem;
		kPacket << iSlot;

		kPacket << bRemove;
		kPacket << iCurPoint;
		kPacket << iUpLevel;
		kPacket << GetMoney();

		if( m_pMyRoom )
		{
			m_pMyRoom->RoomSendPacketTcp( kPacket );
			m_pMyRoom->OnModeCharGrowthUpdate( this, iClassType, iSlot, bItem, iUpLevel );
		}
		else
		{
			SendMessage( kPacket );
		}

		g_LogDBClient.OnInsertPeso( this, -iNeedPeso, LogDBClient::PT_GROWTH );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s %d)%s %I64d Price / %I64d PreMoney / %I64d Money",__FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iNeedPeso, iPreMoney, GetMoney() );
	}
}

void User::OnCheckTimeGrowth( SP2Packet &rkPacket )
{
	CheckTimeGrowth();
}

void User::CheckTimeGrowth()
{
	TimeGrowthInfoList vInfoList;

	m_UserGrowthLevel.CheckTimeGrowth( vInfoList );

	if( vInfoList.empty() ) return;

	int iSize = vInfoList.size();

	SP2Packet kPacket( STPK_TIME_GROWTH_CHECK );

	PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
	PACKET_GUARD_VOID( kPacket.Write(iSize) );

	for( int i=0; i < iSize; ++i )
	{
		PACKET_GUARD_VOID( kPacket.Write(vInfoList[i].m_iClassType) );
		PACKET_GUARD_VOID( kPacket.Write(vInfoList[i].m_iTimeSlot) );
		PACKET_GUARD_VOID( kPacket.Write(vInfoList[i].m_bConfirm) );
		PACKET_GUARD_VOID( kPacket.Write(m_UserGrowthLevel.GetCharGrowthPoint(vInfoList[i].m_iClassType)) );
	}

	if( m_pMyRoom )
		m_pMyRoom->RoomSendPacketTcp( kPacket );
	else
		SendMessage( kPacket );
}

void User::OnAddTimeGrowth( SP2Packet &rkPacket )
{
	int iClassType, iSlot;

	rkPacket >> iClassType >> iSlot;

	bool bItem = false;
	if( COMPARE( iSlot, TIG_WEAPON, TIG_ATTACK ) )
		bItem = true;


	if( !m_UserGrowthLevel.CheckEnableTimeGrowthLevel( iClassType, iSlot ) )
	{
		SP2Packet kPacket( STPK_TIME_GROWTH_ADD );
		kPacket << TIME_GROWTH_ADD_LIMIT_LEVEL;
		SendMessage( kPacket );
		return;
	}

	int iCurPoint = m_UserGrowthLevel.GetCharGrowthPoint( iClassType );
	int iNeedPoint = g_GrowthMgr.GetGrowthUpNeedPoint( !bItem );

	if( iCurPoint < iNeedPoint )
	{
		SP2Packet kPacket( STPK_TIME_GROWTH_ADD );
		kPacket << TIME_GROWTH_ADD_POINT;
		SendMessage( kPacket );
		return;
	}

	int iCurGrowthCnt = m_UserGrowthLevel.GetCurTimeGrowthCntInChar( iClassType );
	if( iCurGrowthCnt >= g_GrowthMgr.GetTimeGrowthEnableCharCnt() )
	{
		SP2Packet kPacket( STPK_TIME_GROWTH_ADD );
		kPacket << TIME_GROWTH_ADD_LIMIT_CNT;
		SendMessage( kPacket );
		return;
	}

	int iTotalGrowthCnt = m_UserGrowthLevel.GetCurTimeGrowthTotalCnt();
	if( iTotalGrowthCnt >= g_GrowthMgr.GetTimeGrowthEnableTotalCnt() )
	{
		SP2Packet kPacket( STPK_TIME_GROWTH_ADD );
		kPacket << TIME_GROWTH_ADD_LIMIT_TOTAL_CNT;
		SendMessage( kPacket );
		return;
	}

	int iValue1, iValue2;
	iValue1 = iValue2 = 0;
	if( m_UserGrowthLevel.AddTimeGrowth( iClassType, iSlot, iValue1, iValue2 ) )
	{
		iCurPoint -= iNeedPoint;
		m_UserGrowthLevel.SetCharGrowthPoint( iClassType, iCurPoint );

		SP2Packet kPacket( STPK_TIME_GROWTH_ADD );
		kPacket << TIME_GROWTH_ADD_OK;
		kPacket << iClassType;
		kPacket << iSlot;
		kPacket << iValue1;
		kPacket << iValue2;
		kPacket << iCurPoint;
		SendMessage( kPacket );
		return;
	}
	else
	{
		SP2Packet kPacket( STPK_TIME_GROWTH_ADD );
		kPacket << TIME_GROWTH_ADD_FAIL;
		kPacket << 2;
		SendMessage( kPacket );
		return;
	}
}

void User::OnRemoveTimeGrowth( SP2Packet &rkPacket )
{
	int iClassType, iSlot;

	rkPacket >> iClassType >> iSlot;

	bool bItem = false;
	if( COMPARE( iSlot, TIG_WEAPON, TIG_ATTACK ) )
		bItem = true;

	int iCurPoint = m_UserGrowthLevel.GetCharGrowthPoint( iClassType );
	int iNeedPoint = g_GrowthMgr.GetGrowthUpNeedPoint( !bItem );

	if( m_UserGrowthLevel.RemoveTimeGrowth( iClassType, iSlot ) )
	{
		iCurPoint += iNeedPoint;
		m_UserGrowthLevel.SetCharGrowthPoint( iClassType, iCurPoint );

		SP2Packet kPacket( STPK_TIME_GROWTH_REMOVE );
		kPacket << TIME_GROWTH_REMOVE_OK;
		kPacket << iClassType;
		kPacket << iCurPoint;
		SendMessage( kPacket );
	}
	else
	{
		SP2Packet kPacket( STPK_TIME_GROWTH_REMOVE );
		kPacket << TIME_GROWTH_REMOVE_FAIL;
		kPacket << 1;
		SendMessage( kPacket );
		return;
	}
}

void User::OnGrowthLevelInit( SP2Packet &rkPacket )
{
	int iClassType;
	rkPacket >> iClassType;

	int iCurLevel = m_ClassExpert.GetClassLevel( iClassType );
	if( iCurLevel == 0 )
	{
		// 실패 전송
		SP2Packet kPacket( STPK_GROWTH_LEVEL_INIT );
		kPacket << GetPublicID();
		kPacket << GROWTH_INIT_FAIL;
		SendMessage( kPacket );
		return;
	}

	if( GetMoney() < g_GrowthMgr.GetGrowthInitPeso() )
	{
		// 실패 전송
		SP2Packet kPacket( STPK_GROWTH_LEVEL_INIT );
		kPacket << GetPublicID();
		kPacket << GROWTH_INIT_FAIL_PESO;
		SendMessage( kPacket );
		return;
	}

	int iCurTotalPoint = g_GrowthMgr.CheckCurTotalGrowthPoint( iCurLevel );
 
	m_UserGrowthLevel.CharGrowthLevelInit( iClassType, iCurTotalPoint );

	__int64 iPreMoney = GetMoney();
	RemoveMoney( g_GrowthMgr.GetGrowthInitPeso() );
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ETC, LogDBClient::PT_GROWTH, 0, 0, g_GrowthMgr.GetGrowthInitPeso(), NULL);

	// Init 성공 전송
	SP2Packet kPacket( STPK_GROWTH_LEVEL_INIT );
	kPacket << GetPublicID();
	kPacket << GROWTH_INIT_SUCESS;
	kPacket << iClassType;
	kPacket << iCurTotalPoint;
	kPacket << GetMoney();

	if( m_pMyRoom )
		m_pMyRoom->RoomSendPacketTcp( kPacket );
	else
		SendMessage( kPacket );

	g_LogDBClient.OnInsertPeso( this, -g_GrowthMgr.GetGrowthInitPeso(), LogDBClient::PT_GROWTH );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s %d)%s %I64d Price / %I64d PreMoney / %I64d Money",__FUNCTION__, GetUserIndex(), GetPublicID().c_str(), g_GrowthMgr.GetGrowthInitPeso(), iPreMoney, GetMoney() );
}



int User::GetFriendSlotSize()
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	if( !m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_FRIEND_SLOT_EXTEND, kSlot ) )
		return Help::GetFriendDefaultSlotSize();

	return Help::GetFriendDefaultSlotSize() + kSlot.m_iValue1;
}

void User::StartEtcItemTime( const char *szFunction, int iType /*= 0/*ioEtcItem::EIT_NONE*/ )
{
	if( !m_UserEtcItem.SetStartTimeMap( m_pMyRoom, szFunction, iType ) )
		return;

	SP2Packet kPacket( STPK_START_ETC_ITEM_TIME );
	m_UserEtcItem.FillTimeData( kPacket, iType );
	SendMessage( kPacket );
}

void User::UpdateEtcItemTime( const char *szFunction, int iType /*= 0/*ioEtcItem::EIT_NONE*/ )
{
	// update
	IntVec vUpdateType;
	if( !m_UserEtcItem.UpdateTimeData( vUpdateType, m_pMyRoom, szFunction, iType ) )
		return;

	// send
	SP2Packet kPacket( STPK_UPDATE_ETC_ITEM_TIME );

	PACKET_GUARD_VOID( kPacket.Write((int) vUpdateType.size()) );

	for(int i = 0;i < (int) vUpdateType.size();i++ )
	{
		int &riType = vUpdateType[i];
		ioUserEtcItem::ETCITEMSLOT kSlot;
		if( !m_UserEtcItem.GetEtcItem( riType, kSlot ) )
		{
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
		}
		else
		{
			PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iType) );
			PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iValue1) );
			PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iValue2) );
		}
	}
	SendMessage( kPacket );

	// delete
	m_UserEtcItem.DeleteEtcItemZeroTime();
}

void User::LeaveRoomEtcItemTime()
{
	// update
	IntVec vUpdateType;
	m_UserEtcItem.LeaveRoomTimeItem( vUpdateType );

	if( vUpdateType.empty() )
		return;

	// send
	SP2Packet kPacket( STPK_UPDATE_ETC_ITEM_TIME );

	PACKET_GUARD_VOID( kPacket.Write((int) vUpdateType.size()) );

	for(int i = 0;i < (int) vUpdateType.size();i++ )
	{
		int &riType = vUpdateType[i];
		ioUserEtcItem::ETCITEMSLOT kSlot;
		if( !m_UserEtcItem.GetEtcItem( riType, kSlot ) )
		{
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write(0) ); 
			PACKET_GUARD_VOID( kPacket.Write(0) );
		}
		else
		{
			PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iType) );
			PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iValue1) ); 
			PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iValue2) );
		}
	}
	SendMessage( kPacket );
}

void User::DeleteEtcItemPassedDate()
{
	IntVec vDeletTypeVec;
	m_UserEtcItem.DeleteEtcItemPassedDate( vDeletTypeVec );

	if( vDeletTypeVec.empty() )
		return;

	// send
	int iSize = vDeletTypeVec.size();

	SP2Packet kPacket( STPK_DELETE_ETC_ITEM_DATE );
	PACKET_GUARD_VOID( kPacket.Write(iSize) );
	for (int i = 0; i < iSize ; i++)
	{
		int &riType = vDeletTypeVec[i];
		PACKET_GUARD_VOID( kPacket.Write(riType) );
	}
	SendMessage( kPacket );
}

void User::SendEventData()
{
	m_EventUserMgr.SendData( this );
}

void User::ChildrenDayEventEndProcess()
{
	if( g_EventMgr.IsAlive( EVT_CHILDRENDAY, GetChannelingType() ) ) return;
	
	DeleteExerciseChar( EXERCISE_EVENT );
	FixSelectChar();

	// 클라이언트에 용병 슬롯에있는 이벤트 용병 삭제 전송 
	SP2Packet kPacket( STPK_EXERCISE_CHAR_DELETE );

	PACKET_GUARD_VOID( kPacket.Write((int)EXERCISE_EVENT) );

	SendMessage( kPacket );
}

bool User::IsRoomLoadingOrServerMoving()
{
	if( m_pMyRoom )
	{
		// 룸에 입장 후 로딩중..
		if( m_pMyRoom->IsRoomLoadingState( this ) )
			return true;
	}

	// 서버 이동 로딩중...
	if( !IsConnectState() )
		return true;

	return false;
}

void User::OnEtcItemAction( SP2Packet &rkPacket )
{
	int iType = 0;
	rkPacket >> iType;

	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( iType, kSlot );
	if( kSlot.m_iType <= 0 || kSlot.m_iValue1 <= 0 )
	{
		SP2Packet kReturn( STPK_ETCITEM_ACTION );
		kReturn << ETCITEM_ACTION_DONT_HAVE;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemAction Fail - %s) %d don't have value.",  GetPublicID().c_str(), iType );
		return;
	}

	ioEtcItem *pEtcItem = g_EtcItemMgr.FindEtcItem( iType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_ETCITEM_ACTION );
		kReturn << ETCITEM_ACTION_EXCEPTION;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemAction Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), iType );
		return;
	}

	pEtcItem->OnAction( iType, this );
}

void User::OnEtcItemSwitch( SP2Packet &rkPacket )
{
	int iType = 0;
	rkPacket >> iType;

	ioEtcItem *pEtcItem = g_EtcItemMgr.FindEtcItem( iType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_ETCITEM_SWITCH );
		kReturn << ETCITEM_SWITCH_EXCEPTION;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemSwitch Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), iType );
		return;
	}
	pEtcItem->OnUseSwitch( rkPacket, this );
}

void User::OnFishingState( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnFishingState - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( m_pMyRoom->GetModeType() != MT_TRAINING )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnFishingState - %s Not in 광장", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	int iType;
	rkPacket >> iType;

	switch( iType )
	{
	case FISHING_START:
		{
			if( m_UserFishingItem.IsFullInventory() )		// 인벤에 빈자리 없는데 요청들어온 경우 실패 처리
			{
				// 종료상태로 만들자
				m_dwFishingStartTime = 0;
				m_dwFishingLoopTime = 0;

				m_iFishingRodType = 0;
				m_iFishingBaitType = 0;

				g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
				SetStartTimeLog(0); // 낚시시간을 남겼으므로 다른시간에 영향을 주지 않도록 초기화

				m_pMyRoom->SetFishingState( GetPublicID(), false );

				SP2Packet kFailReturn( STPK_FISHING );
				kFailReturn << GetPublicID();
				kFailReturn << FISHING_ERROR;
				kFailReturn << 3;
				m_pMyRoom->RoomSendPacketTcp( kFailReturn );

				HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Fishing : %s Over Fishing", GetPublicID().c_str() );
				return;
			}

			bool bFirst;
			rkPacket >> bFirst;
			rkPacket >> m_iFishingRodType;
			rkPacket >> m_iFishingBaitType;

			if( !HasEtcItem( m_iFishingRodType ) )
			{
				// 종료상태로 만들자
				m_dwFishingStartTime = 0;
				m_dwFishingLoopTime = 0;

				m_iFishingRodType = 0;
				m_iFishingBaitType = 0;

				g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
				SetStartTimeLog(0); // 낚시시간을 남겼으므로 다른시간에 영향을 주지 않도록 초기화

				m_pMyRoom->SetFishingState( GetPublicID(), false );

				SP2Packet kFailReturn( STPK_FISHING );
				kFailReturn << GetPublicID();
				kFailReturn << FISHING_ERROR;
				kFailReturn << 4;
				m_pMyRoom->RoomSendPacketTcp( kFailReturn );
				return;
			}

			if( bFirst )
			{
				SetStartTimeLog( TIMEGETTIME() );
			}

			DWORD dwTime = g_FishingMgr.GetCurFishingTime( GetFishingExtraType(m_iFishingRodType), IsPCRoomAuthority() );
			if( dwTime == 0 )
			{
				// 종료상태로 만들자
				m_dwFishingStartTime = 0;
				m_dwFishingLoopTime = 0;

				m_iFishingRodType = 0;
				m_iFishingBaitType = 0;

				g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
				SetStartTimeLog(0); // 낚시시간을 남겼으므로 다른시간에 영향을 주지 않도록 초기화

				m_pMyRoom->SetFishingState( GetPublicID(), false );

				SP2Packet kFailReturn( STPK_FISHING );
				kFailReturn << GetPublicID();
				kFailReturn << FISHING_ERROR;
				kFailReturn << 5;
				m_pMyRoom->RoomSendPacketTcp( kFailReturn );
				return;
			}

			//길드 본부 낚시 일 경우 해당 오브젝트 있는지 체크
			if( m_pMyRoom->GetPlazaModeType() == PT_GUILD )
			{
				__int64 iFisheryIndex	= 0;
				PACKET_GUARD_VOID( rkPacket.Read(iFisheryIndex) );

				GuildRoomInfos* pGuildRoomInfo	= g_GuildRoomBlockMgr.GetGuildRoomInfos(GetGuildIndex());
				if( !pGuildRoomInfo )
				{
					SP2Packet kFailReturn( STPK_FISHING );
					PACKET_GUARD_VOID( kFailReturn.Write(GetPublicID()) );
					PACKET_GUARD_VOID( kFailReturn.Write(FISHING_ERROR) );
					PACKET_GUARD_VOID( kFailReturn.Write(6) );
					m_pMyRoom->RoomSendPacketTcp( kFailReturn );
					return;
				}

				ioBlockDBItem* pFisheryInfo = pGuildRoomInfo->GetBlockItemInfo(iFisheryIndex);
				if( !pFisheryInfo )
				{
					SP2Packet kFailReturn( STPK_FISHING );
					PACKET_GUARD_VOID( kFailReturn.Write(GetPublicID()) );
					PACKET_GUARD_VOID( kFailReturn.Write(FISHING_NONEXIST_BLOCK) );
					m_pMyRoom->RoomSendPacketTcp( kFailReturn );
					return;
				}

				DWORD dwItemCode = pFisheryInfo->m_iItemCode;
				if( pGuildRoomInfo->GetItemType(dwItemCode) != GRT_FISHERY )
				{
					SP2Packet kFailReturn( STPK_FISHING );
					PACKET_GUARD_VOID( kFailReturn.Write(GetPublicID()) );
					PACKET_GUARD_VOID( kFailReturn.Write(FISHING_NONEXIST_BLOCK) );
					m_pMyRoom->RoomSendPacketTcp( kFailReturn );
					return;
				}
				//
				m_dwFisheryCode = dwItemCode;
			}


			m_pMyRoom->SetFishingState( GetPublicID(), true );

			m_dwFishingStartTime = TIMEGETTIME();
			m_dwFishingLoopTime = dwTime;

			SP2Packet kReturn( STPK_FISHING );
			kReturn << GetPublicID();
			kReturn << FISHING_START;
			kReturn << dwTime;
			kReturn << m_iFishingRodType;
			kReturn << m_iFishingBaitType;
			m_pMyRoom->RoomSendPacketTcp( kReturn );
		}
		break;
	case FISHING_RESULT:
		{
			// 시간 체크
			if( !CheckFishingInfo() )
			{
				// 종료상태로 만들자
				m_dwFishingStartTime = 0;
				m_dwFishingLoopTime = 0;

				m_iFishingRodType = 0;
				m_iFishingBaitType = 0;

				g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
				SetStartTimeLog(0); // 낚시시간을 남겼으므로 다른시간에 영향을 주지 않도록 초기화

				m_pMyRoom->SetFishingState( GetPublicID(), false );

				// 너무빨리 결과 요청이 왔음
				SP2Packet kFailReturn( STPK_FISHING );
				kFailReturn << GetPublicID();
				kFailReturn << FISHING_ERROR;
				kFailReturn << 2;
				m_pMyRoom->RoomSendPacketTcp( kFailReturn );

				HackLOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Fishing : %s Fast Fishing", GetPublicID().c_str() );
				return;
			}

			if( !HasEtcItem( m_iFishingBaitType ) )
			{
				// 종료상태로 만들자
				m_dwFishingStartTime = 0;
				m_dwFishingLoopTime = 0;

				m_iFishingRodType = 0;
				m_iFishingBaitType = 0;

				g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
				SetStartTimeLog(0); // 낚시시간을 남겼으므로 다른시간에 영향을 주지 않도록 초기화

				m_pMyRoom->SetFishingState( GetPublicID(), false );

				SP2Packet kFailReturn( STPK_FISHING );
				kFailReturn << GetPublicID();
				kFailReturn << FISHING_ERROR;
				kFailReturn << 5;
				m_pMyRoom->RoomSendPacketTcp( kFailReturn );
				return;
			}

			// 결과정보 설정
			bool bSuccess = false;
			bool bSpecial = false;
			bool bEvent = false;
			bool bEventFishing = false;

			int iItemType = -1;
			int iArray = 0;

			int iPresentNum = -1;

			bSuccess = g_FishingMgr.IsFishingSuccess( GetFishingExtraType(m_iFishingBaitType), IsPCRoomAuthority() );
			
			if( bSuccess )
			{
				// 이벤트 기간중이면 bEvent 를 true로 만들어 주면
				// 이벤트시 사용할 낚시 아이템 정보로 낚이는 아이템을 결정.
				FishingEventUserNode *pEventNode = static_cast<FishingEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_FISHING ) );
				if( pEventNode )
				{
					if( pEventNode->IsEventTime( this ) )
						bEvent = true;
				}

				bool bGuildFishery	= false;
				if( m_dwFisheryCode != 0 )
					bGuildFishery	= true;

				iItemType = g_FishingMgr.GetFishingItemNum( bEvent, IsPCRoomAuthority(), bGuildFishery );

				// 낚시광 이벤트
				iPresentNum = g_FishingMgr.GetEventFishingPresentNum( iItemType, bEvent, IsPCRoomAuthority() );
				if( iPresentNum > 0 )
				{
					bEventFishing = true;
					RateCheckLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "EventFishing - ID: %s(%d), Item: %d, Present: %d",
													 GetPublicID().c_str(), GetUserIndex(), iItemType, iPresentNum );
				}

				// 특별한 아이템을 낚았는지 체크
				if( g_FishingMgr.IsSpecial(iItemType, bGuildFishery) )
				{
					bSpecial = true;
				}
				else
				{
					// 인벤에 추가
					iArray = m_UserFishingItem.AddFishItem( (BYTE)(iItemType) );
				}
			}

			// 경험치 처리
			bool bLevelUp = false;
			int iAddExp = g_LevelMgr.GetFishingFailExp();
			if( bSuccess )
				iAddExp = g_LevelMgr.GetFishingSuccessExp();
			bLevelUp = AddFishingExp( iAddExp );

			// 낚시하는 용병 경험치 처리
			bool bGradeLevelUp = false;
			int iAddSoldierExp = 0;
			int iClassType = GetSelectClassType();
			if( iClassType > 0 )
			{
				if( bSuccess )
				{	
					iAddSoldierExp = g_LevelMgr.GetFishingSuccessSoldierExp();
				}
				else
				{	
					iAddSoldierExp = g_LevelMgr.GetFishingFailSoldierExp();
				}
				
				// 대여 용병은 경험치 획득X
				if( IsClassTypeExerciseStyle( iClassType, EXERCISE_RENTAL ) == false )
					AddClassExp( iClassType, iAddSoldierExp );  
				AddGradeExp( iAddSoldierExp );
				GradeNClassUPBonus();
			}

			// 슬롯 처리
			int iPreMaxSlot = m_UserFishingItem.GetCurMaxInventory();
			if( bLevelUp )
				m_UserFishingItem.CheckCurMaxInventory();

			bool bAddSlot = false;
			if( iPreMaxSlot < m_UserFishingItem.GetCurMaxInventory() )
				bAddSlot = true;


			m_dwFishingStartTime = 0;
			m_dwFishingLoopTime = 0;

			m_iFishingRodType = 0;
			m_iFishingBaitType = 0;

			SP2Packet kReturn( STPK_FISHING );
			kReturn << GetPublicID();
			kReturn << FISHING_RESULT;
			kReturn << bSuccess;
			kReturn << iItemType;
			kReturn << g_FishingMgr.IsAllAlarm( iItemType );
			kReturn << g_FishingMgr.IsRoomAlarm( iItemType );
			kReturn << iArray;
			kReturn << m_user_data.m_fishing_level;
			kReturn << m_user_data.m_fishing_exp;
			kReturn << bLevelUp;
			kReturn << bAddSlot;
			kReturn << iAddExp;
			kReturn << bEventFishing;
			kReturn << bSpecial;
			kReturn << iClassType;
			kReturn << iAddSoldierExp;
			kReturn << GetGradeLevel();
			kReturn << GetClassLevel( m_select_char, true );

			if( bEventFishing )
				g_PresentHelper.SendEventFishingPresent( this, iPresentNum, kReturn );

			if( bSpecial )
			{
				g_PresentHelper.SendSpecialFishingPresent( this, kReturn );
			}

			static DWORDVec vFishingInfo;
			vFishingInfo.clear();
			if( bSuccess )
				vFishingInfo.push_back(1);
			else
				vFishingInfo.push_back(2);

			g_MissionMgr.DoTrigger(MISSION_CLASS_FISHING, this, vFishingInfo);
			m_pMyRoom->RoomSendPacketTcp( kReturn );
		}
		break;
	case FISHING_END:
		{
			m_dwFishingStartTime	= 0;
			m_dwFishingLoopTime		= 0;

			m_iFishingRodType		= 0;
			m_iFishingBaitType		= 0;
			//m_dwFisheryCode			= 0;

			g_LogDBClient.OnInsertTime( this, LogDBClient::TT_FISHING );
			SetStartTimeLog(0); // 낚시시간을 남겼으므로 다른시간에 영향을 주지 않도록 초기화

			m_pMyRoom->SetFishingState( GetPublicID(), false );

			SP2Packet kReturn( STPK_FISHING );
			kReturn << GetPublicID();
			kReturn << FISHING_END;
			m_pMyRoom->RoomSendPacketTcp( kReturn, this );
		}
		break;
	case FISHING_SELL:
		{
			int iItemType;
			int iItemArray;
			rkPacket >> iItemArray;

			// 인벤에서 해당 아이템 제거
			iItemType = m_UserFishingItem.DeleteFishItem( iItemArray );

			__int64 iSellPeso = 0;
			int iItemGrade = -1;
			iItemType = iItemType;

			bool bEvent = false;
			FishingEventUserNode *pEventNode = static_cast<FishingEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_FISHING ) );
			if( pEventNode )
			{
				if( pEventNode->IsEventTime( this ) )
					bEvent = true;
			}
			
			bool bGuildFishery	= false;
			if( m_dwFisheryCode != 0 )
				bGuildFishery	= true;

			iItemGrade = g_FishingMgr.GetGrade( bEvent, IsPCRoomAuthority(), bGuildFishery );
			iSellPeso = g_FishingMgr.GetFishingItemSellPeso( iItemType, iItemGrade, bEvent, IsPCRoomAuthority(), bGuildFishery );

			// 페소 증가
			AddMoney( iSellPeso );
			g_LogDBClient.OnInsertPeso( this, iSellPeso, LogDBClient::PT_FISH_ITEM );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_FISH_ITEM, 0, 0, iSellPeso, NULL);

			// 알림 체크
			bool bAlarm = false;
			if( iItemType > 0 )
			{
				if( g_FishingMgr.IsSellAlarm( iItemType, iItemGrade, bEvent, IsPCRoomAuthority() ) )
					bAlarm = true;
			}

            // 한 명에게만 전송
			SP2Packet kReturn( STPK_FISHING );
			kReturn << GetPublicID();
			kReturn << FISHING_SELL;
			kReturn << iItemType;
			kReturn << iItemGrade;
			kReturn << iItemArray;
			kReturn << bAlarm;
			kReturn << iSellPeso;
			kReturn << GetMoney();
			SendMessage( kReturn );
		}
		break;
	case FISHING_OPEN:
		{
			// Test용
			if( g_FishingMgr.IsTestFishing() )
			{
				typedef std::map< int, int > FishingMap;
				FishingMap eFishingItemMap, eFishingPresentMap, eFishingGrade;

				int i=0;
				bool bEvent = false;
				FishingEventUserNode *pEventNode = static_cast<FishingEventUserNode*> ( m_EventUserMgr.GetEventUserNode( EVT_FISHING ) );
				if( pEventNode )
				{
					bEvent = pEventNode->IsEventTime( this );
				}

				for(int i=0; i < 1000000; ++i )
				{
					bool bSuccess = g_FishingMgr.IsFishingSuccess( GetFishingExtraType(ioEtcItem::EIT_ETC_FISHING_MOON_BAIT), IsPCRoomAuthority() );
					{
						int iItemType = g_FishingMgr.GetFishingItemNum( bEvent, IsPCRoomAuthority(), false );
						if( iItemType > 0 )
						{
							// Item
							FishingMap::iterator iter = eFishingItemMap.find( iItemType );
							if( iter != eFishingItemMap.end() )
							{
								iter->second += 1;
							}
							else
							{
								eFishingItemMap.insert( FishingMap::value_type(iItemType, 1) );
							}

							// Present
							if( g_FishingMgr.IsSpecial(iItemType) )
							{
								int iPresent = g_PresentHelper.CheckSpecialFishingPresent( this );
								iter = eFishingPresentMap.find( iPresent );
								if( iter != eFishingPresentMap.end() )
								{
									iter->second += 1;
								}
								else
								{
									eFishingPresentMap.insert( FishingMap::value_type(iPresent, 1) );
								}
							}

							// Grade
							int iItemGrade = g_FishingMgr.GetGrade( bEvent, IsPCRoomAuthority(), false );
							iter = eFishingGrade.find( iItemGrade );
							if( iter != eFishingGrade.end() )
							{
								iter->second += 1;
							}
							else
							{
								eFishingGrade.insert( FishingMap::value_type(iItemGrade, 1) );
							}
						}
					}
				}

				FishingMap::iterator iter_i = eFishingItemMap.begin();
				for( ; iter_i != eFishingItemMap.end(); ++iter_i )
				{
					int iItem = iter_i->first;
					float fRate = (float) iter_i->second / 1000000 * 100.0f;
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "TestFishing(%d) - %d : %f", bEvent, iItem, fRate );
				}

				FishingMap::iterator iter_p = eFishingPresentMap.begin();
				for( ; iter_p != eFishingPresentMap.end(); ++iter_p )
				{
					int iPresent = iter_p->first;
					float fRate = (float) iter_p->second / 1000000 * 100.0f;
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "TestFishingPresent(%d) - %d : %f", bEvent, iPresent, fRate );
				}

				FishingMap::iterator iter_g = eFishingGrade.begin();
				for( ; iter_g != eFishingGrade.end(); ++iter_g )
				{
					int iGRade = iter_g->first;
					float fRate = (float) iter_g->second / 1000000 * 100.0f;
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "TestFishingGrade(%d) - %d : %f", bEvent, iGRade, fRate );
				}
			}
			//

			// DB로 부터 정보를 가져왔었는지 체크후 가져온적 없으면 가져오기
			// (가져온값 보내는 것은 DB에서 도착한 처리시점에 전송
			if( !m_UserFishingItem.IsDataLoad() )
			{
				g_DBClient.OnSelectAllFishData( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex() );
				break;
			}

			// 이미로드된 경우
			m_UserFishingItem.CheckCurMaxInventory();

			SP2Packet kReturn( STPK_FISHING );
			kReturn << GetPublicID();
			kReturn << FISHING_OPEN;
			kReturn << GetFishingLevel();
			kReturn << GetFishingExpert();
			kReturn << false;		// 처음인지아닌지 체크
			SendMessage( kReturn );
			//
			break;
		}
	}
}

void User::OnRouletteState( SP2Packet &rkPacket )
{
	if( !m_pMyRoom )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnRouletteState - %s Not in Room", GetPublicID().c_str() );
		return;
	}

	if( m_pMyRoom->GetModeType() != MT_TRAINING )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnRouletteState - %s Not in 광장", GetPublicID().c_str() );
		return;
	}

	if( !m_pMyRoom->IsEnableState( this ) )
		return;

	SP2Packet kReturn( STPK_ROULETTE );
	kReturn << GetPublicID();
	m_pMyRoom->RoomSendPacketTcp( kReturn );
}

bool User::CheckFishingInfo()
{
	DWORD dwCurTime = TIMEGETTIME();

	if( m_dwFishingStartTime > 0 && m_dwFishingLoopTime > 0 )
	{
		if( m_dwFishingStartTime+m_dwFishingLoopTime < dwCurTime + 2000 )
		{
			return true;
		}
	}

	return false;
}

ChannelingType User::GetChannelingType() const
{
	return m_user_data.m_eChannelingType;
}

const ioHashString & User::GetChannelingUserID() const
{
	return m_user_data.m_szChannelingUserID;
}

const ioHashString & User::GetChannelingUserNo() const
{
	return m_user_data.m_szChannelingUserNo;
}

int User::GetChannelingCash() const
{
	return m_user_data.m_iChannelingCash;
}

BlockType User::GetBlockType() const
{
	return m_user_data.m_eBlockType;
}

float User::GetBlockPointPer()
{
	if( m_user_data.m_eBlockType == BKT_NORMAL )
		return 1.0f;
	else if( m_user_data.m_eBlockType == BKT_WARNNING )
		return 0.7f;
	else if( m_user_data.m_eBlockType == BKT_LIMITATION )
		return 0.5f;

	return 0.0f; 
}

void User::SetBlockType( BlockType eBlockType )
{
	m_user_data.m_eBlockType = eBlockType;
}

CTime User::GetBlockTime() const
{
	return m_user_data.m_kBlockTime;
}

void User::SetBlockTime( CTime &rkTime )
{
	m_user_data.m_kBlockTime = rkTime;
}

void User::SetChannelingCash( int iCash )
{
	m_user_data.m_iChannelingCash = iCash;
}

void User::AddChannelingCash( int iCash )
{
	m_user_data.m_iChannelingCash += iCash;
}

void User::CheckCurMaxCharSlot()
{
	m_iCurMaxCharSlot = m_iDefaultMaxCharSlot;

	// 슬롯 확장 아이템 체크
	// m_iCurMaxCharSlot += 확장된 슬롯수
	ioUserEtcItem::ETCITEMSLOT kSlot;
	if( !m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_CHAR_SLOT_EXTEND, kSlot ) )
	{
		return;
	}

	m_iCurMaxCharSlot += kSlot.GetUse();
	m_iCurMaxCharSlot = min( m_iCurMaxCharSlot, m_iLimiteMaxCharSlot );
	//
}

int User::ChanceMortmainCharEventLotto( int &iMortmainCnt )
{
	int iLogType = 1;       // 1은 페소를 받은거.
	int iBonusType = 0;
	// 보상 지급
	IORandom kRandom;
	kRandom.SetRandomSeed( timeGetTime() );
	ioINILoader kLoader( "config/config.ini" );
	kLoader.SetTitle( "event" );
	int irand_seed = kLoader.LoadInt( "rand_seed", 100 );
	DWORD dwRand = kRandom.Random( irand_seed );
	if( dwRand >= 87 ) iBonusType = 100000; // 100 Peso
	else if( dwRand >= 57 ) iBonusType = 200000; // 200 Peso
	else if( dwRand >= 17 ) iBonusType = 300000; // 300 Peso
	else if( dwRand >= 7 ) iBonusType = 500000;  // 500 Peso
	else if( dwRand >= 2 ) iBonusType = 700000;  // 700 Peso
	else if( dwRand >= 1 ) iBonusType = 1000000; // 1000 Peso
	else
	{
		// 용병 지급
		bool bSoldier = false;
		dwRand = kRandom.Random( 10000 );
		switch( iMortmainCnt )
		{
		case 0:
			bSoldier = true;
			break;
		case 1:      
			if( dwRand < 2500 )
				bSoldier = true;
			break;
		case 2:
			if( dwRand < 625 )
				bSoldier = true;
			break;
		case 3:
			if( dwRand < 156 )
				bSoldier = true;
			break;
		case 4:
			if( dwRand < 39 )
				bSoldier = true;
			break;
		case 5:
			if( dwRand < 9 )
				bSoldier = true;
			break;
		}

		if( !bSoldier ) 
		{
			iBonusType = 1000000; // 1000 Peso
			iLogType = 2;      // 2는 영구용병 받은 횟수 초과로 페소 받은거.
		}
		else
		{
			if( ( m_vLevelUpAndPresentCreateClass.size() + GetCharCount() ) == m_iCurMaxCharSlot )
			{
				LOOP_GUARD();
				// 슬롯이 가득찼으면 기간제 용병중 한개를 영구용병으로 지급한다.
				bool bAllMortmain = true;
				vCharList::iterator iter = m_CharList.begin();
				while( iter != m_CharList.end() )
				{
					ioCharacter *pChar = *iter++;
					if( !pChar ) continue;				
					if( !pChar->IsMortmain() )
					{
						bAllMortmain = false;
						break;
					}
				}
				LOOP_GUARD_CLEAR();

				if( !bAllMortmain || !m_vLevelUpAndPresentCreateClass.empty() )
				{
					// 슬롯이 가득찼는데 보유한 용병중 기간제 용병이 있으면 1,000페소 지급
					iBonusType = 1000000; // 1,000 Peso				
					iLogType = 3;      // 3은 슬롯이 가득차서 페소 받은거.
				}
				else
				{
					// 슬롯이 가득찼는데 보유한 용병중 기간제 용병도 없으면 50,000페소 지급
					iBonusType = 50000000; //50,000 Peso
					iLogType = 4;      // 4는 슬롯이 가득차서 페소 받은거.
					iMortmainCnt++;
				}
			}
			else
			{
				// 받을 수 있는 영구 용병 타입
				int i = 0;
				DWORDVec vClassList;
				bool bAllMortmain = true;
				for(i = 0;i < g_ItemPriceMgr.GetMaxClassInfo();i++)
				{
					if( !g_ItemPriceMgr.GetArrayClassActive( i ) ) continue;
					vClassList.push_back( g_ItemPriceMgr.GetArrayClassCode( i ) );
				}

				// 보유하지 않은 용병 지급
				LOOP_GUARD();
				vCharList::iterator iter = m_CharList.begin();
				while( iter != m_CharList.end() )
				{
					ioCharacter *pChar = *iter++;
					if( !pChar ) continue;				

					if( !pChar->IsMortmain() )
					{
						bAllMortmain = false;
					}

					for(i = 0;i < (int)vClassList.size();i++)
					{
						if( pChar->GetCharInfo().m_class_type == vClassList[i] )
						{
							vClassList.erase( vClassList.begin() + i );
							break;
						}
					}
				}
				LOOP_GUARD_CLEAR();

				// 레벨업 보상으로 받은 용병도 제외한다
				for(i = 0;i < (int)m_vLevelUpAndPresentCreateClass.size();i++)
				{
					for(int j = 0;j < (int)vClassList.size();j++)
					{
						if( m_vLevelUpAndPresentCreateClass[i] == vClassList[j] )
						{
							vClassList.erase( vClassList.begin() + j );
							break;
						}
					}
				}

				if( vClassList.empty() )     // 지급할 용병이 없다.
				{
					if( !bAllMortmain || !m_vLevelUpAndPresentCreateClass.empty() )
					{
						// 슬롯이 가득찼는데 보유한 용병중 기간제 용병이 있으면 1,000페소 지급
						iBonusType = 1000000; // 1,000 Peso			
						iLogType = 5;      // 5는 슬롯이 가득차서 페소 받은거.	
					}
					else
					{
						// 슬롯이 가득찼는데 보유한 용병중 기간제 용병도 없으면 50,000페소 지급
						iBonusType = 50000000; //50,000 Peso
						iLogType = 6;          // 6은 슬롯이 가득차서 페소 받은거.
						iMortmainCnt++;
					}
				}
				else
				{
					// 지급할 용병 선택
					int r = rand()%(int)vClassList.size();
					iBonusType = vClassList[r];
					iLogType = 7;          // 
					iMortmainCnt++;
				}
			}
		}
	}
	
	if( iBonusType % 1000 == 0 )      // 페소 지급 되었다.
	{
		int iBonusPeso = iBonusType/1000;
		AddMoney( iBonusPeso );
		g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_EVENT_PESO );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_EVENT_PESO, PRESENT_SOLDIER, iBonusType, iBonusPeso, NULL);
		EventLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "ChanceMortmainCharEventLotto PESO : %s : %d - %d", GetPublicID().c_str(), iBonusPeso, iLogType );
	}
	else        //용병 지급되었다.
	{
		// 용병 지급
		CHARACTER kCharInfo;
		kCharInfo.m_class_type	 = iBonusType;
		kCharInfo.m_iLimitSecond = 0;
		kCharInfo.m_ePeriodType  = CPT_MORTMAIN;
		m_Inventory.GetEquipItemCode( kCharInfo );         // 치장이 있다면 입힌다.

		// 착용한 아이템이 없다면 Default 지급
		if( kCharInfo.m_face == -1)
			kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
		if( kCharInfo.m_hair == -1 )
			kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
		if( kCharInfo.m_skin_color == -1 )
			kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
		if( kCharInfo.m_hair_color == -1 )
			kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
		if( kCharInfo.m_underwear == -1 )
			kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	

		m_iCreateCharCount++;
		//캐릭터 생성.
		g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
		g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_MORTMAIN_CHAR_EVENT, 1, LogDBClient::CT_EVENT_CHAR );
		m_vLevelUpAndPresentCreateClass.push_back( kCharInfo.m_class_type );
		EventLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "ChanceMortmainCharEventLotto CHAR : %s : %d - %d", GetPublicID().c_str(), iBonusType % 1000, iLogType );

		// 전체 유저에게 공지
		SP2Packet kPacket( SUPK_SERVER_ALARM_MENT );
		kPacket << UDP_SERVER_ALARM_EVENT << GetPublicID() << iBonusType;
		g_UserNodeManager.SendAllServerAlarmMent( kPacket );
	}
	return iBonusType;
}

bool User::IsFishingState()
{
	if( !m_pMyRoom )
		return false;

	return m_pMyRoom->IsFishingState( GetPublicID() );
}

int User::GetFishingLevel()
{
	return m_user_data.m_fishing_level;
}

int User::GetFishingExpert()
{
	return m_user_data.m_fishing_exp;
}

bool User::AddFishingExp( int iExp )
{
	if( GetFishingLevel() >= g_LevelMgr.GetMaxFishingLevel() )
		return false;

	int iNextExp = g_LevelMgr.GetNextFishingLevelUpExp( GetFishingLevel() );
	m_user_data.m_fishing_exp += iExp;	
	if( iNextExp <= m_user_data.m_fishing_exp )
	{
		if( GetFishingLevel() < g_LevelMgr.GetMaxFishingLevel() )
		{
			m_user_data.m_fishing_level++;

			int iRemainExp = m_user_data.m_fishing_exp - iNextExp;
			m_user_data.m_fishing_exp = 0;

			if( iRemainExp > 0 )
				AddFishingExp( iRemainExp );
			return true;
		}
	}
	return false;
}

int User::GetFishingSlotExtendItem()
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	if( !m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_FISHING_SLOT_EXTEND, kSlot ) )
	{
		return 0;
	}

	return kSlot.GetUse();
}

int User::GetFishingExtraType( int iEtcType )
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	if( !m_UserEtcItem.GetEtcItem( iEtcType, kSlot ) )
	{
		return 0;
	}

	ioEtcItem *pItem = g_EtcItemMgr.FindEtcItem( iEtcType );
	if( !pItem )
		return 0;

	return pItem->GetExtraType();
}


bool User::HasEtcItem( int iEtcType )
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	return m_UserEtcItem.GetEtcItem( iEtcType, kSlot );
}

int User::GetFishingRodType()
{
	return m_iFishingRodType;
}

int User::GetFishingBaitType()
{
	return m_iFishingBaitType;
}

bool User::IsRealExcavating()
{
	enum { MAX_SIZE = 2, };
	int iEtcItemTypeArray[MAX_SIZE]={ ioEtcItem::EIT_ETC_EXCAVATING_KIT, ioEtcItem::EIT_ETC_GOLD_EXCAVATING_KIT };
	for (int i = 0; i < MAX_SIZE ; i++)
	{
		ioUserEtcItem::ETCITEMSLOT kSlot;
		m_UserEtcItem.GetEtcItem( iEtcItemTypeArray[i], kSlot );	
		if( kSlot.IsUse() )
		{
			DWORD dwPassedTime = TIMEGETTIME()-m_dwExcavatingTime;
			if( g_ExcavationMgr.GetRealExcavatingUserTime() <= (int)dwPassedTime )
				return true;
		}
	}
		
	return false;
}

void User::SetEquipExcavating( bool bEquip, int iEtcItemType )
{
	enum { ECAVATING_ITEM_CODE = 400312, GOLD_ECAVATING_ITEM_CODE = 400313, };
	int iItemCode = 0;
	if( iEtcItemType == ioEtcItem::EIT_ETC_EXCAVATING_KIT )
		iItemCode = ECAVATING_ITEM_CODE;
	else if( iEtcItemType == ioEtcItem::EIT_ETC_GOLD_EXCAVATING_KIT )
		iItemCode = GOLD_ECAVATING_ITEM_CODE;

	ioItem *pItemInfo = NULL;
	if( bEquip )
	{
		const ItemInfo *pItemInfoConst = g_ItemInfoMgr.GetItemInfo( iItemCode );
		if( !pItemInfoConst )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pItemInfoConst == NULL.(%s)", __FUNCTION__, GetPublicID().c_str() );
			return;
		}

		if( !m_pMyRoom )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s m_pMyRoom == NULL. ( %s )", __FUNCTION__, GetPublicID().c_str() );
			return;
		}

		pItemInfo = m_pMyRoom->CreateItemByName( pItemInfoConst->m_Name );
		if( !pItemInfo )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pItemInfo == NULL.(%s)", __FUNCTION__, GetPublicID().c_str() );
			return;
		}
	}

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s-( %s ) : Select char Error. %d >= %d", __FUNCTION__, GetPublicID().c_str(), m_select_char, GetCharCount() );
		return;
	}

	if( bEquip )
		m_CharList[m_select_char]->EquipItem( EQUIP_OBJECT, pItemInfo );
	else
	{
		ioItem *pReleaseItem =  m_CharList[m_select_char]->ReleaseItem( EQUIP_OBJECT );
		SAFEDELETE( pReleaseItem );
	}
}

int User::GetExcavationLevel()
{
	return m_user_data.m_iExcavationLevel;
}

int User::GetExcavationExp()
{
	return m_user_data.m_iExcavationExp;
}

bool User::AddExcavationExp( int iExp )
{
	if( GetExcavationLevel() >= g_LevelMgr.GetMaxExcavationLevel() )
		return false;

	int iNextExp = g_LevelMgr.GetNextExcavationLevelUpExp( GetExcavationLevel() );
	m_user_data.m_iExcavationExp += iExp;	
	if( iNextExp <= m_user_data.m_iExcavationExp )
	{
		if( GetExcavationLevel() < g_LevelMgr.GetMaxExcavationLevel() )
		{
			m_user_data.m_iExcavationLevel++;

			int iRemainExp = m_user_data.m_iExcavationExp - iNextExp;
			m_user_data.m_iExcavationExp = 0;

			if( iRemainExp > 0 )
				AddExcavationExp( iRemainExp );
			return true;
		}
	}
	return false;
}

// ExtraItem
void User::OnExtraItemSell( SP2Packet &rkPacket )
{
	int iSlotIndex;
	rkPacket >> iSlotIndex;

	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( !m_UserExtraItem.GetExtraItem( iSlotIndex, kSlot ) )
	{
		SP2Packet kPacket( STPK_EXTRAITEM_SELL );
		PACKET_GUARD_VOID( kPacket.Write( EXTRAITEM_SELL_FAIL ) );
		PACKET_GUARD_VOID( kPacket.Write( 1 ) );
		//kPacket << EXTRAITEM_SELL_FAIL;
		//kPacket << 1;
		SendMessage( kPacket );
		return;
	}

	// Peso 계산
	// 소수점 단위로 계산뒤 나중에 소수점단위를 버림.
	float fReturnPeso = 0.0f;
	if( kSlot.m_PeriodType == ioUserExtraItem::EPT_MORTMAIN )
	{
		fReturnPeso = g_ExtraItemInfoMgr.GetMortmainItemSellPeso() * ( 1 + ( (float)kSlot.m_iReinforce / 25 ) * g_ExtraItemInfoMgr.GetItemSellConst() );
	}
	else
	{
		CTime kCurTime = CTime::GetCurrentTime();
		CTime kLimitTime( Help::GetSafeValueForCTimeConstructor( kSlot.GetYear(),
																 kSlot.GetMonth(),
																 kSlot.GetDay(),
																 kSlot.GetHour(),
																 kSlot.GetMinute(),
																 0 ) );
		CTimeSpan kRemainTime = kLimitTime - kCurTime;
		DWORD dwTotalTime = 0;
		if( kRemainTime.GetTotalMinutes() > 0 )
			dwTotalTime = kRemainTime.GetTotalMinutes();

		fReturnPeso = dwTotalTime * g_ExtraItemInfoMgr.GetTimeItemSellPeso() * ( 1 + ( (float)kSlot.m_iReinforce / 25 ) * g_ExtraItemInfoMgr.GetItemSellConst() );
		fReturnPeso = max( 0, fReturnPeso );
	}

	__int64 iPeso = (__int64)fReturnPeso;
	if( SendBillingAddMileage( PRESENT_EXTRAITEM, kSlot.m_iItemCode, 0, (int)iPeso, false ) )
	{
		iPeso = 0;
	}
	
	if( m_UserExtraItem.DeleteExtraItem( iSlotIndex ) )
	{
		AddMoney( iPeso );
		
		g_LogDBClient.OnInsertPeso( this, iPeso, LogDBClient::PT_SELL_EXTRAITEM );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_EXTRAITEM, PRESENT_EXTRAITEM, kSlot.m_iItemCode, iPeso, NULL);
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "ExtraItemLOG : SellItem(%s) : %d, %I64d", GetPublicID().c_str(), kSlot.m_iItemCode, iPeso );

		SP2Packet kPacket( STPK_EXTRAITEM_SELL );
		PACKET_GUARD_VOID( kPacket.Write( EXTRAITEM_SELL_OK ) );
		PACKET_GUARD_VOID( kPacket.Write( iSlotIndex ) );
		PACKET_GUARD_VOID( kPacket.Write( iPeso ) );
		PACKET_GUARD_VOID( kPacket.Write( GetMoney() ) );
		SendMessage( kPacket );
	}
	else
	{
		SP2Packet kPacket( STPK_EXTRAITEM_SELL );
		PACKET_GUARD_VOID( kPacket.Write( EXTRAITEM_SELL_FAIL ) );
		PACKET_GUARD_VOID( kPacket.Write( 2 ) );
		SendMessage( kPacket );
	}

	SaveExtraItem();
	SaveUserData();
}

BOOL User::IsWearingExtraItem( int iIndex, int iTargetClass )
{
	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( !m_UserExtraItem.GetExtraItem( iIndex, kSlot ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][extraitem]Duplicated equipment : none exist item [%lu] [%d]", GetUserIndex(), iIndex );
		return TRUE;
	}

	if( kSlot.m_bEquip )
	{
		int iEquipedClass = GetEquipedClassWithExtraItem(iIndex);
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][extraitem]Duplicated equipment : change item [%lu] [%d] [%d] [%d]", GetUserIndex(), iIndex, iEquipedClass, iTargetClass );
		return TRUE;
	}
	return FALSE;
}

int	 User::GetEquipedClassWithExtraItem(int iItemIndex)
{
	int iCharCount	= GetCharCount();

	for( int i = 0; i < iCharCount; i++ )
	{
		ioCharacter *pCharacter = GetCharacter(i);
		if( !pCharacter )
			continue;

		for( int j = 0; j < MAX_CHAR_DBITEM_SLOT; j++ )
		{
			if( iItemIndex == pCharacter->GetExtraItemIndex(j) )
				return pCharacter->GetClassType();
		}
	}
	
	return 0;
}

void User::PutonExtraItem( const int iCharArray, int iSlot, int iNewIndex )
{
	ioCharacter *pCharacter = GetCharacter(iCharArray);
	if(!pCharacter)	return;

	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( m_UserExtraItem.GetExtraItem( iNewIndex, kSlot ) )
	{
		// youngdie, 장착
		kSlot.m_bEquip = TRUE;
		kSlot.m_iTradeState = ioUserExtraItem::EET_DISABLE;
		m_UserExtraItem.SetExtraItem( kSlot );
		
		pCharacter->SetChangeExtraItem( iSlot, iNewIndex );
		pCharacter->SetDBItemData( iSlot, kSlot.m_iItemCode, kSlot.m_iReinforce, kSlot.m_dwMaleCustom, kSlot.m_dwFemaleCustom );
	}
}

void User::TakeoffExtraItem( const int iCharArray, int iSlot )
{
	ioCharacter *pCharacter = GetCharacter(iCharArray);
	if(!pCharacter)	return;

	int iIndex = pCharacter->GetExtraItemIndex( iSlot );
	if(0 != iIndex)
	{
		ioUserExtraItem::EXTRAITEMSLOT kSlot;
		if( m_UserExtraItem.GetExtraItem( iIndex, kSlot ) )
		{
			// youngdie, 장착해제
			kSlot.m_bEquip = FALSE;
			m_UserExtraItem.SetExtraItem( kSlot );

			//pCharacter->TakeOffExtraItem( iSlot );
		}
	}
	pCharacter->TakeOffExtraItem( iSlot );
}

void User::OnExtraItemChange(SP2Packet &rkPacket)
{
	int iCharArray = 0, iSlot = 0, iNewIndex = 0;

	PACKET_GUARD_VOID( rkPacket.Read(iCharArray) );
	PACKET_GUARD_VOID( rkPacket.Read(iSlot) );
	PACKET_GUARD_VOID( rkPacket.Read(iNewIndex) );

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		// exception
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID(kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID(kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
		PACKET_GUARD_VOID(kReturn.Write(1) );
		SendMessage( kReturn );
		return;
	}

	ioCharacter *rkChar = m_CharList[iCharArray];
	if(rkChar == NULL)
	{
		// exception
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
		PACKET_GUARD_VOID( kReturn.Write(2) );
		SendMessage( kReturn );
		return;
	}

	DWORD   dwCharIndex = rkChar->GetCharIndex();
	int		iGameIndex = 0;
	int		iNewItemCode = 0;
	int		iNewReinforce = 0;
	DWORD	dwNewMaleCustom = 0;
	DWORD   dwNewFemaleCustom = 0;

	//
	if( iNewIndex == 0 )	// 해제
	{
		TakeoffExtraItem( iCharArray, iSlot );
	}
	else					// 장착
	{
		// 기존에 장착된 아이템 해제
		TakeoffExtraItem( iCharArray, iSlot );

		if( IsWearingExtraItem( iNewIndex, rkChar->GetClassType() ) )
		{
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
			PACKET_GUARD_VOID( kReturn.Write(3) );
			SendMessage( kReturn );
			return;
		}

		ioUserExtraItem::EXTRAITEMSLOT kSlot;
		if( !m_UserExtraItem.GetExtraItem( iNewIndex, kSlot ) )
		{
			return;
		}

		int iDefItemCode = 100000;
		int iItemCode = kSlot.m_iItemCode;

		int iEnableClass = 0;
		const ItemInfo *pItemInfo = g_ItemInfoMgr.GetItemInfo( iItemCode );
		if( pItemInfo )
		{
			iEnableClass = pItemInfo->m_iEnableClass;
		}

		const CHARACTER &rkInfo = rkChar->GetCharInfo();


		if( iEnableClass > 0 && iEnableClass != rkInfo.m_class_type  )
		{
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
			PACKET_GUARD_VOID( kReturn.Write(4) );
			SendMessage( kReturn );
			return;
		}

		if( iEnableClass > 0 && iEnableClass == rkInfo.m_class_type )
		{
			if( g_PowerUpMgr.GetPowerUpItemGrade(iItemCode) != rkInfo.m_byReinforceGrade )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][extraitemchange] powerUp item equp fail : [itemcode:%d reinforce:%d]", iItemCode, rkInfo.m_byReinforceGrade );
				SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
				PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
				PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
				PACKET_GUARD_VOID( kReturn.Write(4) );
				SendMessage( kReturn );
				return;
			}
		}

		int iEnableLevel = kSlot.m_iReinforce * g_ExtraItemInfoMgr.GetLevelLimitConst();
		int iCurLevel = GetClassLevel( iCharArray, true );
		if( iCurLevel < iEnableLevel )
		{
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
			PACKET_GUARD_VOID( kReturn.Write(5) );
			SendMessage( kReturn );
			return;
		}	

		PutonExtraItem( iCharArray, iSlot, iNewIndex );
	}

	// 본부
	if( GetModeType() == MT_NONE )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_OK) );
		PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
		PACKET_GUARD_VOID( kReturn.Write(iSlot) );
		PACKET_GUARD_VOID( kReturn.Write(iNewIndex) );
		SendMessage( kReturn );
	}
	else if( m_pMyRoom )
	{
		bool bResult = m_pMyRoom->IsRoundEndState();

		bool bSelectChar = false;
		if( m_select_char == iCharArray )
			bSelectChar = true;

		if( bSelectChar && !bResult )		// 출전중인 용병 처리
		{
			// 현재 장착중인 아이템 변경
			if( rkChar->GetItem( iSlot ) )
			{
				const ITEM_DATA *pItemData = rkChar->GetDBItemData( iSlot );
				if( pItemData && pItemData->m_item_code > 0 )
				{
					ioItem *pNewItem = m_pMyRoom->CreateItem( *pItemData, GetPublicID() );
					if( pNewItem )
					{
						ioItem *pPreItem = rkChar->EquipItem( iSlot, pNewItem );
						iGameIndex = pNewItem->GetGameIndex();
						iNewItemCode = pItemData->m_item_code;
						iNewReinforce = pItemData->m_item_reinforce;
						dwNewMaleCustom = pItemData->m_item_male_custom;
						dwNewFemaleCustom = pItemData->m_item_female_custom;

						SAFEDELETE( pPreItem );
					}
				}
				else
				{
					// 예외상황 DB Item이 없는 상황
					SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
					PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
					PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
					PACKET_GUARD_VOID( kReturn.Write(6) );
					SendMessage( kReturn );
					return;
				}
			}

			// 해당룸에 있는 유저들에게 변경 정보 전달
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_OK) );
			PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
			PACKET_GUARD_VOID( kReturn.Write(iSlot) );
			PACKET_GUARD_VOID( kReturn.Write(iNewIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iGameIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iNewItemCode) );
			PACKET_GUARD_VOID( kReturn.Write(iNewReinforce) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewMaleCustom) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewFemaleCustom) );
			m_pMyRoom->RoomSendPacketTcp( kReturn );
		}
		else			// 출전중이 아닌 용병
		{
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_OK) );
			PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
			PACKET_GUARD_VOID( kReturn.Write(iSlot) );
			PACKET_GUARD_VOID( kReturn.Write(iNewIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iGameIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iNewItemCode) );
			PACKET_GUARD_VOID( kReturn.Write(iNewReinforce) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewMaleCustom) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewFemaleCustom) );
			SendMessage( kReturn );
		}

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharExtraItemUpdate( this, dwCharIndex, iSlot, iNewIndex );
		}
	}
	else
	{
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
		PACKET_GUARD_VOID( kReturn.Write(7) );
		SendMessage( kReturn );
		return;
	}
}

void User::TakeOffCharExtraItem(ioCharacter* pCharacter, int iEquipType)
{
	if( !pCharacter )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
		PACKET_GUARD_VOID( kReturn.Write(2) );
		SendMessage( kReturn );
		return;
	}

	int iCharArray = GetCharArray(pCharacter->GetCharIndex());
	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][extraitem] don't use char : take off fail" );
		
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
		PACKET_GUARD_VOID( kReturn.Write(1) );
		SendMessage( kReturn );
		return;
	}

	int		iNewIndex = 0;
	int		iGameIndex = 0;
	int		iNewItemCode = 0;
	int		iNewReinforce = 0;
	DWORD	dwNewMaleCustom = 0;
	DWORD   dwNewFemaleCustom = 0;

	// 장착해제
	TakeoffExtraItem( iCharArray, iEquipType );

	//해제 정보 전송
	// 본부
	if( GetModeType() == MT_NONE )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_OK) );
		PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
		PACKET_GUARD_VOID( kReturn.Write(iEquipType) );
		PACKET_GUARD_VOID( kReturn.Write(iNewIndex) );
		SendMessage( kReturn );
	}
	else if( m_pMyRoom )
	{
		bool bResult = m_pMyRoom->IsRoundEndState();

		bool bSelectChar = false;
		if( m_select_char == iCharArray )
			bSelectChar = true;

		if( bSelectChar && !bResult )		// 출전중인 용병 처리
		{
			// 현재 장착중인 아이템 변경
			if( pCharacter->GetItem( iEquipType ) )
			{
				const ITEM_DATA *pItemData = pCharacter->GetDBItemData( iEquipType );
				if( pItemData && pItemData->m_item_code > 0 )
				{
					ioItem *pNewItem = m_pMyRoom->CreateItem( *pItemData, GetPublicID() );
					if( pNewItem )
					{
						ioItem *pPreItem = pCharacter->EquipItem( iEquipType, pNewItem );
						iGameIndex = pNewItem->GetGameIndex();
						iNewItemCode = pItemData->m_item_code;
						iNewReinforce = pItemData->m_item_reinforce;
						dwNewMaleCustom = pItemData->m_item_male_custom;
						dwNewFemaleCustom = pItemData->m_item_female_custom;

						SAFEDELETE( pPreItem );
					}
				}
				else
				{
					// 예외상황 DB Item이 없는 상황
					SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
					PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
					PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
					PACKET_GUARD_VOID( kReturn.Write(6) );
					SendMessage( kReturn );
					return;
				}
			}

			// 해당룸에 있는 유저들에게 변경 정보 전달
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_OK) );
			PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
			PACKET_GUARD_VOID( kReturn.Write(iEquipType) );
			PACKET_GUARD_VOID( kReturn.Write(iNewIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iGameIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iNewItemCode) );
			PACKET_GUARD_VOID( kReturn.Write(iNewReinforce) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewMaleCustom) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewFemaleCustom) );

			m_pMyRoom->RoomSendPacketTcp( kReturn );
		}
		else			// 출전중이 아닌 용병
		{
			SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_OK) );
			PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
			PACKET_GUARD_VOID( kReturn.Write(iEquipType) );
			PACKET_GUARD_VOID( kReturn.Write(iNewIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iGameIndex) );
			PACKET_GUARD_VOID( kReturn.Write(iNewItemCode) );
			PACKET_GUARD_VOID( kReturn.Write(iNewReinforce) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewMaleCustom) );
			PACKET_GUARD_VOID( kReturn.Write(dwNewFemaleCustom) );

			SendMessage( kReturn );
		}

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharExtraItemUpdate( this, pCharacter->GetCharIndex(), iEquipType, iNewIndex );
		}
	}
	else
	{
		SP2Packet kReturn( STPK_EXTRAITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_CHANGE_FAIL) );
		PACKET_GUARD_VOID( kReturn.Write(7) );
		SendMessage( kReturn );
		return;
	}
}

void User::DeleteExtraItemPassedDate( bool bImmediately )
{
	static IntVec vDeletSlotVec;
	vDeletSlotVec.clear();

	m_UserExtraItem.DeleteExtraItemPassedDate( vDeletSlotVec );

	if( vDeletSlotVec.empty() )
		return;

	int iSize = vDeletSlotVec.size();
	int i = 0;

	// char extraitem
	for(int i=0; i < iSize; ++i )
	{
		int iSlotIndex = vDeletSlotVec[i];
		if( iSlotIndex <= 0 )
			continue;

		int iCharArray = FindExtraItemEquipChar( iSlotIndex );

		if( !COMPARE( iCharArray, 0, GetCharCount() ) )
			continue;

		const CHARACTER &charInfo = m_CharList[iCharArray]->GetCharInfo();
		CHARACTER kChar = charInfo;

		for( int j=0; j < MAX_CHAR_DBITEM_SLOT; ++j )
		{
			if( charInfo.m_extra_item[j] == iSlotIndex )
			{
				kChar.m_extra_item[j] = 0;
			}
		}

		m_CharList[iCharArray]->SetCharInfo( m_CharList[iCharArray]->GetCharIndex(), kChar, this );
	}

	int iListCnt = vDeletSlotVec.size();

	// send
	SP2Packet kPacket( STPK_DELETE_EXTRAITEM_DATE );

	PACKET_GUARD_VOID( kPacket.Write(iListCnt) );
	for (i = 0; i < iListCnt ; i++)
	{
		PACKET_GUARD_VOID( kPacket.Write(vDeletSlotVec[i]) );
	}
	PACKET_GUARD_VOID( kPacket.Write(bImmediately) );

	SendMessage( kPacket );
}

void User::OnExtraItemDisassemble( SP2Packet &rkPacket )
{
	int iSlotIndex;
	rkPacket >> iSlotIndex;

	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( !m_UserExtraItem.GetExtraItem( iSlotIndex, kSlot ) )
	{
		SP2Packet kPacket( STPK_EXTRAITEM_DISASSEMBLE );
		kPacket << EXTRAITEM_DISASSEMBLE_FAIL;
		kPacket << 1;
		SendMessage( kPacket );
		return;
	}

	int iGainCode = g_AlchemicMgr.GetDisassembleCode( ADT_EXTRAITEM, kSlot.m_iItemCode );
	int iGainCnt = 0;
	if( kSlot.m_PeriodType == ioUserExtraItem::EPT_MORTMAIN )
	{
		iGainCnt = g_AlchemicMgr.GetDisassembleCnt( ADT_EXTRAITEM, true, 0, kSlot.m_iReinforce );
	}
	else
	{
		CTime kCurTime = CTime::GetCurrentTime();
		CTime kLimitTime( Help::GetSafeValueForCTimeConstructor( kSlot.GetYear(),
																 kSlot.GetMonth(),
																 kSlot.GetDay(),
																 kSlot.GetHour(),
																 kSlot.GetMinute(),
																 0 ) );
		CTimeSpan kRemainTime = kLimitTime - kCurTime;
		DWORD dwTotalTime = 0;
		if( kRemainTime.GetTotalHours() > 0 )
			dwTotalTime = kRemainTime.GetTotalHours() / 24;

		iGainCnt = g_AlchemicMgr.GetDisassembleCnt( ADT_EXTRAITEM, false, dwTotalTime, kSlot.m_iReinforce );
	}

	if( iGainCnt <= 0 )
	{
		SP2Packet kPacket( STPK_EXTRAITEM_DISASSEMBLE );
		kPacket << EXTRAITEM_DISASSEMBLE_FAIL;
		kPacket << 2;
		SendMessage( kPacket );
		return;
	}

	if( m_UserExtraItem.DeleteExtraItem( iSlotIndex ) )
	{
		int iCheckType = 0;
		int iCurCount = m_AlchemicInventory.GetAlchemicItemCnt( iGainCode );
		if( iCurCount > 0 )		// 기존에 존재하던 것, 최대갯수 체크 필요
		{
			int iTotal = iCurCount + iGainCnt;
			if( iTotal > ioAlchemicInventory::MAX_SLOT_CNT )	// 받으면 최대갯수 초과하므로 받기 실패
				iCheckType = PRESENT_RECV_MAX_COUNT;
		}
		else					// 기존에 없던것, 빈칸 체크 필요
		{
			if( !m_AlchemicInventory.CheckEmptySlot() )			// 빈칸 없으므로 받기 실패
				iCheckType = PRESENT_RECV_MAX_SLOT;
		}

		bool bSendPresent = false;
		switch( iCheckType )
		{
		case PRESENT_RECV_MAX_COUNT:
		case PRESENT_RECV_MAX_SLOT:
			g_PresentHelper.SendPresentByAlchemicItem( this, iGainCode, iGainCnt );
			bSendPresent = true;
			break;
		}

		if( !bSendPresent )
			m_AlchemicInventory.GainAlchemicItem( iGainCode, iGainCnt );

		SP2Packet kPacket( STPK_EXTRAITEM_DISASSEMBLE );
		kPacket << EXTRAITEM_DISASSEMBLE_OK;
		kPacket << iSlotIndex;
		kPacket << iGainCode;
		kPacket << iGainCnt;
		kPacket << bSendPresent;
		SendMessage( kPacket );

		// 분해로그
		g_LogDBClient.OnInsertDisassemble( this, LogDBClient::DST_EXTRAITEM, kSlot.m_iItemCode, iGainCode, iGainCnt );
	}
	else
	{
		SP2Packet kPacket( STPK_EXTRAITEM_DISASSEMBLE );
		kPacket << EXTRAITEM_DISASSEMBLE_FAIL;
		kPacket << 3;
		SendMessage( kPacket );
	}

	SaveExtraItem();
	SaveAlchemicInventory();
}

int User::FindExtraItemEquipChar( int iSlotIndex )
{
	int iSize = GetCharCount();
	for(int i = 0;i < iSize;i++)
	{
		const CHARACTER &charInfo = m_CharList[i]->GetCharInfo();
		
		for( int j=0; j < MAX_CHAR_DBITEM_SLOT; ++j )
		{
			if( charInfo.m_extra_item[j] == iSlotIndex )
				return i;
		}
	}

	return -1;
}

void User::OnExtraItemBuy( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s (%d:%s) Billing Wait %s", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	bool bCash = false;
	bool bBonusCash = false;
	int  iMachineCode = 0, iArray = 0;
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	PACKET_GUARD_VOID( rkPacket.Read(iMachineCode) );
	PACKET_GUARD_VOID( rkPacket.Read(bCash) );
	PACKET_GUARD_VOID( rkPacket.Read(iArray) );

	if( iMachineCode == 0 )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_EXCEPTION;
		kReturn << 3;
		SendMessage( kReturn );
		return;
	}

	//장비 수량 체크
	if( m_UserExtraItem.IsSlotFull() )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_SLOT_FULL) );
		SendMessage( kReturn );
		return;
	}

	int iBuyCash = 0;
	if( bCash )
	{

		//HRYOON BONUS CASH 사용 가능 여부 파악
		//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
		//if( !IsEntryFormality() )
		if( GetEntryType() == ET_TERMINATION )
		{
			SP2Packet kPacket( STPK_EXTRAITEM_BUY );
			kPacket << EXTRAITEM_EXCEPTION;
			kPacket << 4;
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Entry Type Error - %s : %d",__FUNCTION__, GetPublicID().c_str(), GetEntryType() );
			return;
		}

		iBuyCash = g_ExtraItemInfoMgr.GetNeedCash( iMachineCode );
		if( iBuyCash <= 0 )
		{
			SP2Packet kPacket( STPK_EXTRAITEM_BUY );
			kPacket << EXTRAITEM_EXCEPTION;
			kPacket << 5;
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error - %s(%d) : %d :%d",__FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iMachineCode );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d",__FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			kReturn << EXTRAITEM_EXCEPTION;
			kReturn << 6;
			SendMessage( kReturn );
			return;
		}

		int iItemPrice = iBuyCash;

		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_EXTRAITEM_BUY, EXTRAITEM_CASH, iMachineCode, vConsumeInfo ) )
			return;

		int iSpendBonusCash	= 0;
		int iSize	= vConsumeInfo.size();

		for( int i = 0; i < iSize; i++ )
			iSpendBonusCash += vConsumeInfo[i].value2;

		//보너스 캐쉬로 장비 구매 가능 
		if( iSpendBonusCash >= iItemPrice )
			bBonusCash = true;

		if( iItemPrice != iSpendBonusCash )
		{
			iBuyCash = iItemPrice - iSpendBonusCash;

			char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
			Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
			m_szBillingGUID = szTempGUID;
			SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
			kBillingPacket << (int) GetChannelingType();
			kBillingPacket << m_szBillingGUID;
			kBillingPacket << iItemPrice;
			kBillingPacket << GetUserIndex();
			kBillingPacket << GetPublicID();
			kBillingPacket << GetPrivateID();
			kBillingPacket << GetPublicIP();
			kBillingPacket << iBuyCash;

			PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
			for( int i = 0; i < iSize; i++ )
			{
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
				PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
			}

			kBillingPacket << OUTPUT_CASH_EXTRA;
			kBillingPacket << iMachineCode;

			if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_EXTRAITEM_BUY, EXTRAITEM_BILLING_FAIL, NULL, NULL ) )
				return;

			ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
			if( pLocal )
				pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

			if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
				SP2Packet kReturn( STPK_EXTRAITEM_BUY );
				kReturn << EXTRAITEM_BILLING_DISCONNECT;
				SendMessage( kReturn );
				m_szBillingGUID.Clear();
			}
			else
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			return;
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnExtraItemBuy Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
		}
		return;
	}

	int iNeedLevel = g_ExtraItemInfoMgr.GetNeedLevel( iMachineCode );
	if( iNeedLevel > GetGradeLevel() )
	{
		// 예외처리
		SP2Packet kPacket( STPK_EXTRAITEM_BUY );
		kPacket << EXTRAITEM_LEVEL;
		kPacket << iNeedLevel;
		SendMessage( kPacket );
		return;
	}
	
	int iNeedPeso = g_ExtraItemInfoMgr.GetNeedPeso( iMachineCode, iArray );

	if( iNeedPeso <= 0 && vConsumeInfo.empty() )
	{
		// 예외처리
		SP2Packet kPacket( STPK_EXTRAITEM_BUY );
		kPacket << EXTRAITEM_EXCEPTION;
		kPacket << 7;
		SendMessage( kPacket );
		return;
	}
	else
	{

		if( GetMoney() < iNeedPeso && !bBonusCash )
		{
	
			// 예외처리
			SP2Packet kPacket( STPK_EXTRAITEM_BUY );
			kPacket << EXTRAITEM_PESO;
			SendMessage( kPacket );
			return;
		}
		
	}

	// 아래 구문이 수정되면 _OnBillingOutputCashExtra() 함수도 수정해야 함.
	bool bPackage = g_ExtraItemInfoMgr.IsPackage( iMachineCode );

	int iTradeTypeList = 0;
	int iItemCode = g_ExtraItemInfoMgr.GetRandomItemCode( iMachineCode, iTradeTypeList );
	
	// Period값이 -1이면 랜덤값으로 처리함
	int iPeriodTime = g_ExtraItemInfoMgr.GetPeriod( iMachineCode, iArray );
	if( iPeriodTime == -1 )
		iPeriodTime = g_ExtraItemInfoMgr.GetRandomPeriodTime( iMachineCode );

	bool bAlarm     = g_ExtraItemInfoMgr.IsAlarm( iMachineCode, iPeriodTime );
	int iReinforce = g_ExtraItemInfoMgr.GetRandomReinforce( iMachineCode, false );

	ioUserExtraItem::EXTRAITEMSLOT kExtraItem;
	kExtraItem.m_iItemCode = iItemCode;
	kExtraItem.m_iReinforce = iReinforce;
	kExtraItem.m_PeriodType = ioUserExtraItem::EPT_TIME;
	kExtraItem.m_iTradeState = ioUserExtraItem::EET_DISABLE;

	int iSlotIndex = 0;

	if( bPackage )
	{
		g_LogDBClient.OnInsertExtraItem( this, 0, 0, iMachineCode, 0, iNeedPeso, ioUserExtraItem::EPT_TIME, 0, 0, "NONE", LogDBClient::ERT_BUY );
		g_PresentHelper.SendExtraItemPackagePresent( this, iMachineCode );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "ExtraItemLOG : BuyPackageItem(%s:%d) : %d [%I64d:%d]", GetPublicID().c_str(), GetUserIndex(), iMachineCode, GetMoney(), iNeedPeso );
	}
	else // bPackage == false
	{
		if( iPeriodTime >= 0 )
		{
			CTime kLimiteTime = CTime::GetCurrentTime();
			CTimeSpan kAddTime( 0, iPeriodTime, 0, 0 );
			kLimiteTime += kAddTime;

			kExtraItem.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );

			if( iPeriodTime == 0 ) // 무제한
			{
				kExtraItem.m_PeriodType = ioUserExtraItem::EPT_MORTMAIN;

				int iTradeType = g_ExtraItemInfoMgr.GetRandomTradeType( iMachineCode, iTradeTypeList );
				kExtraItem.m_iTradeState = iTradeType;
			}
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail ExtraItem1 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );

			// 예외처리
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			kReturn << EXTRAITEM_PERIOD;
			SendMessage( kReturn );
			return;
		}

		DWORD dwIndex = 0;
		int iArrayIndex = 0;
		
		
		//보너스 캐시로 구매 하는 경우는 리얼캐시와 같은 조건으로 지급함
		iSlotIndex = m_UserExtraItem.AddExtraItem( kExtraItem, false, iNeedPeso, LogDBClient::ERT_BUY, iMachineCode, iPeriodTime, dwIndex, iArrayIndex );
		
		if( iSlotIndex > 0 )
		{
			char szItemIndex[MAX_PATH]="";

			//페소로 구입시에만 log_buy_item_equip 테이블에 로그 남김
			if( dwIndex != 0 && !bBonusCash )
			{
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayIndex+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertExtraItem( this, kExtraItem.m_iItemCode, kExtraItem.m_iReinforce, iMachineCode, iPeriodTime, iNeedPeso, kExtraItem.m_PeriodType, kExtraItem.m_dwMaleCustom, kExtraItem.m_dwFemaleCustom, szItemIndex, LogDBClient::ERT_BUY );
			}
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "ExtraItemLOG : AddItem(%s:%d) : %d-%d", GetPublicID().c_str(), GetUserIndex(), iMachineCode, kExtraItem.m_iItemCode );
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Extraitem2 : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );

			// 예외처리
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			kReturn << EXTRAITEM_EXCEPTION;
			kReturn << 8;
			SendMessage( kReturn );
			return;
		}
	} // bPackage == false

	if( vConsumeInfo.empty() )
	{
		RemoveMoney( iNeedPeso );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_EXTRAITEM, PRESENT_EXTRAITEM, kExtraItem.m_iItemCode, iNeedPeso, NULL);
	}
	else
	{

		if( bBonusCash )
		{


			if(m_szBillingGUID.IsEmpty())
			{
				char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
				Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
				m_szBillingGUID = szTempGUID;
			}
			for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
			{
				//보너스 캐쉬 사용.
				if ( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_EXTRAITEM, kExtraItem.m_iItemCode, kExtraItem.m_iValue1) )
				{
					SP2Packet kReturn( STPK_EXTRAITEM_BUY );
					PACKET_GUARD_VOID( kReturn.Write(EXTRAITEM_EXCEPTION) );
					kReturn << 5;
					SendMessage( kReturn );

					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error : publicID:%s(userIndex:%d)guid:%s, index:%d,money:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2 );
					ClearBillingGUID();

					return;
				}
			}
			ClearBillingGUID();
			//보너스캐쉬로 구매한 경우 장비 수치 높은걸로 지급
			iReinforce = g_ExtraItemInfoMgr.GetRandomReinforce( iMachineCode, true );
			iPeriodTime = g_ExtraItemInfoMgr.GetRandomPeriodTime( iMachineCode );
			if( iPeriodTime >= 0 )
			{
				CTime kLimiteTime = CTime::GetCurrentTime();
				CTimeSpan kAddTime( 0, iPeriodTime, 0, 0 );
				kLimiteTime += kAddTime;
				kExtraItem.SetDate( kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute() );
			}

			kExtraItem.m_iReinforce = iReinforce;
			kExtraItem.m_PeriodType = ioUserExtraItem::EPT_TIME;
			/*
			int iTradeTypeList = 0;
			int iItemCode = g_ExtraItemInfoMgr.GetRandomItemCode( iMachineCode, iTradeTypeList );
			int iPeriodTime = g_ExtraItemInfoMgr.GetRandomPeriodTime( iMachineCode );
			bool bAlarm     = g_ExtraItemInfoMgr.IsAlarm( iMachineCode, iPeriodTime );
			int iReinforce = g_ExtraItemInfoMgr.GetRandomReinforce( iMachineCode, true );

			ioUserExtraItem::EXTRAITEMSLOT kExtraItem;
			kExtraItem.m_iItemCode = iItemCode;
			kExtraItem.m_iReinforce = iReinforce;
			kExtraItem.m_PeriodType = ioUserExtraItem::EPT_TIME;
			kExtraItem.m_iTradeState = ioUserExtraItem::EET_DISABLE;
			*/

			int iBonusPeso = g_ExtraItemInfoMgr.GetBonusPeso( iMachineCode );
			if( iBonusPeso > 0 )
			{
				AddMoney( iBonusPeso );
				g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
				g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_EXTRAITEM, kExtraItem.m_iItemCode, iBonusPeso, NULL);
			}

			//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
			g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);
		}
		else
		{
			SP2Packet kPacket( STPK_EXTRAITEM_BUY );
			kPacket << EXTRAITEM_EXCEPTION;
			kPacket << 5;
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Shortage - %s(%d) : %d :%d",__FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iMachineCode );
			return;
		}
	}

	if( bPackage )
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_PACKAGE_BUY_OK;
		kReturn << GetMoney();
		kReturn << GetCash();
		kReturn << GetChannelingCash();
		kReturn << iMachineCode;				// MachineCode
		SendMessage( kReturn );
	}
	else
	{
		SP2Packet kReturn( STPK_EXTRAITEM_BUY );
		kReturn << EXTRAITEM_BUY_OK;
		kReturn << kExtraItem.m_iItemCode;
		kReturn << kExtraItem.m_iReinforce;
		kReturn << iSlotIndex;
		kReturn << kExtraItem.m_iTradeState;
		kReturn << kExtraItem.m_PeriodType;
		kReturn << kExtraItem.m_iValue1;
		kReturn << kExtraItem.m_iValue2;
		kReturn << kExtraItem.m_dwMaleCustom;
		kReturn << kExtraItem.m_dwFemaleCustom;
		kReturn << iPeriodTime;
		kReturn << GetMoney();
		kReturn << GetCash();
		kReturn << GetChannelingCash();
		kReturn << iMachineCode;				// MachineCode
		kReturn << bAlarm;
		kReturn << 0;							// BonusPeso
		SendMessage( kReturn );
	}

	SaveExtraItem();
	SaveUserData();

	// 구매 선물
	IntVec vEventTypeVec;
	vEventTypeVec.reserve(10);
	m_EventUserMgr.GetSameClassEventTypeVec( EVT_BUY_ITEM, vEventTypeVec );
	int iSize = vEventTypeVec.size();
	for (int i = 0; i < iSize ; i++)
	{
		BuyItemEventUserNode *pEventNode = static_cast< BuyItemEventUserNode* > ( m_EventUserMgr.GetEventUserNode( (EventType)vEventTypeVec[i] ) );
		if( pEventNode )
			pEventNode->SendBuyPresent( this, true, ioPresentHelper::BT_EXTRA_BOX, iMachineCode, 0, iBuyCash);
	}

	//미션 처리
	static DWORDVec vValues;
	vValues.clear();

	vValues.push_back(PRESENT_EXTRAITEM_BOX);	//보급상자 구매
	vValues.push_back(iMachineCode);
	vValues.push_back(1);
	g_MissionMgr.DoTrigger(MISSION_CLASS_ITEM_BUY, this, vValues);

	vValues.clear();
	vValues.push_back(PRESENT_EXTRAITEM);		//아이템 구매
	vValues.push_back(kExtraItem.m_iItemCode);
	vValues.push_back(1);
	g_MissionMgr.DoTrigger(MISSION_CLASS_ITEM_BUY, this, vValues);
}

// Medal Item
void User::OnMedalItemSell( SP2Packet &rkPacket )
{
	int iMedalIndex = 0;
	ioUserMedalItem::MEDALITEMSLOT kSlot;
	int iMedalListArrayIndex = 0;

	PACKET_GUARD_VOID( rkPacket.Read(iMedalIndex) );

	if( !m_UserMedalItem.GetNotEquipMedalItem( iMedalIndex, kSlot, iMedalListArrayIndex ) )
	{
		SP2Packet kPacket( STPK_MEDALITEM_SELL );
		PACKET_GUARD_VOID( kPacket.Write(MEDALITEM_SELL_FAIL) );
		PACKET_GUARD_VOID( kPacket.Write(1) );
		SendMessage( kPacket );
		return;
	}
	
	int iItemType = kSlot.m_iItemType;
	
	float fReturnPeso = 0.0f;
	if( kSlot.m_iPeriodType == ioUserMedalItem::PT_MORTMAIN )
	{
		fReturnPeso = g_MedalItemMgr.GetSellPeso( iItemType );
	}
	else
	{
		fReturnPeso = g_MedalItemMgr.GetSellPeso( iItemType );
		fReturnPeso = fReturnPeso / g_MedalItemMgr.GetSellPesoByMinute();

		CTime kCurTime = CTime::GetCurrentTime();
		CTime kLimitTime( Help::GetSafeValueForCTimeConstructor( kSlot.GetYear(),
																 kSlot.GetMonth(),
																 kSlot.GetDay(),
																 kSlot.GetHour(),
																 kSlot.GetMinute(),
																 0 ) );
		CTimeSpan kRemainTime = kLimitTime - kCurTime;
		DWORD dwTotalTime = 0;
		if( kRemainTime.GetTotalMinutes() > 0 )
			dwTotalTime = kRemainTime.GetTotalMinutes();

		fReturnPeso = dwTotalTime * fReturnPeso;
		fReturnPeso = min( fReturnPeso, g_MedalItemMgr.GetSellPeso( iItemType ) );
	}

	__int64 iPeso = static_cast<__int64>(fReturnPeso);
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal && pLocal->IsMileage() )
	{
		SendBillingAddMileage( PRESENT_MEDALITEM, iItemType, 0, static_cast<int>(iPeso), true );
		iPeso = 0;
	}

	if( m_UserMedalItem.DeleteMedalItem( iItemType, iMedalListArrayIndex ) )
	{
		AddMoney( iPeso );
		g_LogDBClient.OnInsertPeso( this, static_cast<int>(iPeso), LogDBClient::PT_SELL_MEDALITEM );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_MEDALITEM, PRESENT_MEDALITEM, kSlot.m_iItemType, iPeso, NULL);
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "MedalItemLOG : SellMedalItem(%s) : %d, %I64d", GetPublicID().c_str(), kSlot.m_iItemType, iPeso );

		SP2Packet kPacket( STPK_MEDALITEM_SELL );
		PACKET_GUARD_VOID( kPacket.Write(MEDALITEM_SELL_OK) );
		PACKET_GUARD_VOID( kPacket.Write(kSlot.m_iItemType) );
		PACKET_GUARD_VOID( kPacket.Write(iPeso) );
		PACKET_GUARD_VOID( kPacket.Write(GetMoney()) );
		SendMessage( kPacket );
	}
	else
	{
		SP2Packet kPacket( STPK_MEDALITEM_SELL );
		PACKET_GUARD_VOID( kPacket.Write(MEDALITEM_SELL_FAIL) );
		PACKET_GUARD_VOID( kPacket.Write(2) );
		SendMessage( kPacket );
	}

	SaveMedalItem();
	SaveUserData();
}

//
void User::IncreaseMyVictories( bool bIncrease )
{
	if( bIncrease )
		m_iMyVictories++;
	else
		m_iMyVictories = 0;
}

float User::GetModeConsecutivelyBonus()
{
	float fBonus = (float)m_iModeConsecutivelyCnt * Help::GetModeConsecutivelyBonus();	
	return min( fBonus, Help::GetModeConsecutivelyMaxBonus() );
}

void User::SetModeConsecutively( ModeType eModeType )
{
	if( eModeType == MT_NONE )
	{
		m_iModeConsecutivelyCnt = 0;
	}
	else
	{
		m_iModeConsecutivelyCnt++;
	}	
}

bool User::OnItemCompound( SP2Packet &rkPacket, DWORD dwType )
{
	int iTargetSlot, iVictimSlot;
	rkPacket >> iTargetSlot >> iVictimSlot;

	int iResult = g_CompoundMgr.CheckCompoundSuccess( iTargetSlot, iVictimSlot, this, dwType );
	if( iResult > 0 )
	{
		SP2Packet kPacket( STPK_ITEM_COMPOUND );
		kPacket << ITEM_COMPOUND_ERROR;
		kPacket << iResult;
		SendMessage( kPacket );

		return false;
	}
	return true;
}

bool User::OnItemMaterialCompound( SP2Packet &rkPacket, DWORD dwType )
{
	int iTargetSlot;
	int iMaterialCode;

	PACKET_GUARD_bool( rkPacket.Read( iTargetSlot ) );
	PACKET_GUARD_bool( rkPacket.Read( iMaterialCode ) );

	int iResult = g_CompoundMgr.CheckMaterialCompound( iTargetSlot, iMaterialCode, this, dwType );

	if( iResult > 0 )
	{
		SP2Packet kPacket( STPK_ITEM_MATERIAL_COMPOUND );
		PACKET_GUARD_bool( kPacket.Write( ITEM_COMPOUND_ERROR ) );
		PACKET_GUARD_bool( kPacket.Write( iResult ) );
		SendMessage( kPacket );

		return false;
	}

	return true;
}

bool User::OnMultipleItemCompound( SP2Packet &rkPacket, DWORD dwType )
{
	int iItem1, iItem2, iItem3;
	rkPacket >> iItem1 >> iItem2 >> iItem3;
	return g_CompoundMgr.CheckMultipleCompound( iItem1, iItem2, iItem3, this, dwType );
}

bool User::OnItemGrowthCatalyst( SP2Packet &rkPacket, DWORD dwType )
{
	int iTargetSlot;
	rkPacket >> iTargetSlot;

	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( !m_UserExtraItem.GetExtraItem( iTargetSlot, kSlot ) )
	{
		// 아이템 없음
		SP2Packet kPacket( STPK_EXTRAITEM_GROWTH_CATALYST );
		kPacket << EXTRAITEM_GROWTH_CATALYST_NONE_ITEM;
		SendMessage( kPacket );
		return false;
	}

	if( kSlot.m_PeriodType != ioUserExtraItem::EPT_GROW_TIME )
	{
		// 성장 아이템이 아니다.
		SP2Packet kPacket( STPK_EXTRAITEM_GROWTH_CATALYST );
		kPacket << EXTRAITEM_GROWTH_CATALYST_NONE_TYPE;
		SendMessage( kPacket );
		return false;
	}

	// 성공 여부
	bool bGrowthOK = g_ExtraItemGrowthCatalystMgr.IsGrowthCatalyst( kSlot.m_iReinforce );
	if( bGrowthOK )
	{
		bool bMortmainLevel = g_ExtraItemGrowthCatalystMgr.IsMortmainLevel( kSlot.m_iReinforce + 1 );
		if( bMortmainLevel )
		{
			// 메인 서버에 요청하여 영구장비 가능한지 확인한다.
			//kSlot.m_PeriodType = ioUserExtraItem::EPT_MORTMAIN;     // 영구 장비로 변경
			//kSlot.m_iReinforce = g_ExtraItemGrowthCatalystMgr.GetGrowthCatalystReinforce( kSlot.m_iReinforce + 1 );
			SP2Packet kPacket( MSTPK_EXTRAITEM_GROWTH_MORTMAIN_CHECK );
			kPacket << EXTRAITEM_GROWTH_MORTMAIN_CHECK;
			kPacket << GetUserIndex() << (int)dwType << iTargetSlot << kSlot.m_iItemCode << kSlot.m_iReinforce;
			g_MainServer.SendMessage( kPacket );
			RateCheckLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnItemGrowthCatalyst Growth Mortmain Check: %s - %d - %d - %d - %d", GetPublicID().c_str(), kSlot.m_iIndex, kSlot.m_iItemCode, kSlot.m_iReinforce + 1, (int)kSlot.m_PeriodType );
			return true;   // STPK_EXTRAITEM_GROWTH_CATALYST 패킷은 메인 서버에 갔다와서 전송한다.
		}
		else
		{
			// 성장 성공
			kSlot.m_iReinforce++;
			m_UserExtraItem.SetExtraItem( kSlot );
			SaveExtraItem();

			// 로그를 남기자
			RateCheckLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnItemGrowthCatalyst Growth OK: %s - %d - %d - %d - %d", GetPublicID().c_str(), kSlot.m_iIndex, kSlot.m_iItemCode, kSlot.m_iReinforce, (int)kSlot.m_PeriodType );
		}
	}
	else
	{
		// 성장 실패
		RateCheckLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnItemGrowthCatalyst Growth Fail: %s - %d - %d - %d - %d", GetPublicID().c_str(), kSlot.m_iIndex, kSlot.m_iItemCode, kSlot.m_iReinforce, (int)kSlot.m_PeriodType  );
	}

	SP2Packet kPacket( STPK_EXTRAITEM_GROWTH_CATALYST );
	kPacket << EXTRAITEM_GROWTH_CATALYST_OK;
	kPacket << (int)dwType;
	kPacket << bGrowthOK;
	kPacket << iTargetSlot;
	kPacket << kSlot.m_iReinforce;
	kPacket << (int)kSlot.m_PeriodType;
	SendMessage( kPacket );
	return true;
}

bool User::OnItemCompoundEx( SP2Packet &rkPacket, DWORD dwType, int iRandValue )
{
	int iTargetSlot;
	PACKET_GUARD_bool( rkPacket.Read(iTargetSlot) );

	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( !m_UserExtraItem.GetExtraItem( iTargetSlot, kSlot ) )
	{
		// 아이템 없음
		SP2Packet kPacket( STPK_ETCITEM_ITEM_COMPOUNDEX_RESULT );
		PACKET_GUARD_bool( kPacket.Write(EXTRAITEM_COMPOUNDEX_NONE_ITEM) );
		SendMessage( kPacket );
		return false;
	}

	if( kSlot.m_PeriodType != ioUserExtraItem::EPT_MORTMAIN )
	{
		// 영구 아이템이 아니다.
		SP2Packet kPacket( STPK_ETCITEM_ITEM_COMPOUNDEX_RESULT );
		PACKET_GUARD_bool( kPacket.Write(EXTRAITEM_COMPOUNDEX_NONE_TYPE) );
		SendMessage( kPacket );
		return false;
	}

	if( iRandValue <= 0 ) 
	{
		// 랜덤값 오류
		SP2Packet kPacket( STPK_ETCITEM_ITEM_COMPOUNDEX_RESULT );
		PACKET_GUARD_bool( kPacket.Write(EXTRAITEM_COMPOUNDEX_EXCEPTION) );
		SendMessage( kPacket );
		return false;
	}

	if( kSlot.m_iReinforce >= g_CompoundMgr.GetMaxCompoundInfo() )
	{
		// 레벨업 불가능
		SP2Packet kPacket( STPK_ETCITEM_ITEM_COMPOUNDEX_RESULT );
		PACKET_GUARD_bool( kPacket.Write(EXTRAITEM_COMPOUNDEX_REINFORCE_LIMIT) );
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnItemCompoundEx : %d >= %d", kSlot.m_iReinforce, g_CompoundMgr.GetMaxCompoundInfo() );
		return false;
	}

	bool bSuccess = false;
	int iRand = rand()%100;
	if( iRand < iRandValue )
	{
		// 성공
		bSuccess = true;
		kSlot.m_iReinforce++;
		kSlot.m_dwFailExp = 0;
		m_UserExtraItem.SetExtraItem( kSlot );
		SaveExtraItem();

		// 로그를 남기자
		RateCheckLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnItemCompoundEx Level UP : %s - %d - %d - %d - %d", GetPublicID().c_str(), kSlot.m_iIndex, kSlot.m_iItemCode, kSlot.m_iReinforce, (int)kSlot.m_PeriodType );
	}

	SP2Packet kPacket( STPK_ETCITEM_ITEM_COMPOUNDEX_RESULT );
	PACKET_GUARD_bool( kPacket.Write(EXTRAITEM_COMPOUNDEX_OK) );
	PACKET_GUARD_bool( kPacket.Write((int)dwType) );
	PACKET_GUARD_bool( kPacket.Write(bSuccess) );
	PACKET_GUARD_bool( kPacket.Write(iTargetSlot) );
	PACKET_GUARD_bool( kPacket.Write(kSlot.m_iReinforce) );
	SendMessage( kPacket );
	return true;
}

bool User::OnExpandMedalSlotOpen( SP2Packet &rkPacket, DWORD dwType )
{
	int iClassType;
	DWORD dwLimitTime;
	BYTE iSlotNumber;

	rkPacket >> iClassType;
	rkPacket >> iSlotNumber;
	rkPacket >> dwLimitTime;

	ioEtcItemExpandMedalSlot *pItem = static_cast<ioEtcItemExpandMedalSlot*> ( g_EtcItemMgr.FindEtcItem(dwType) );
	if( !pItem )
		return false;

	if( pItem->GetUseSlotNumber() != iSlotNumber ||
		pItem->GetLimitTime() != dwLimitTime )
		return false;
	
	ioUserExpandMedalSlot::ExpandMedalSlot kExMedalSlot;
	kExMedalSlot.Init();
	kExMedalSlot.m_iSlotNumber = iSlotNumber;
	kExMedalSlot.m_iClassType = iClassType;
	kExMedalSlot.m_dwLimitTime = dwLimitTime;

	// 기간이 남아있는 슬롯이 있을 경우 kExMedalSlot 기간값이 바뀐다.
	if( !m_UserExpandMedalSlot.AddExpandMedalSlot( kExMedalSlot, LogDBClient::EMT_USE ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Exist. : %s(%d)",__FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		return false;
	}

	SP2Packet kReturn( STPK_EXPAND_MEDAL_SLOT_OPEN );
	kReturn << kExMedalSlot.m_iClassType;
	kReturn << kExMedalSlot.m_iSlotNumber;
	kReturn << kExMedalSlot.m_dwLimitTime;
	SendMessage( kReturn );

	SaveExpandMedalSlot();

	return true;
}

void User::DeleteExMedalSlotPassedDate()
{
	static IntVec vDeletTypeVec;
	vDeletTypeVec.clear();
	ioUserExpandMedalSlot::ExpandMedalSlotVec vDelExMedalSlotVec;
	m_UserExpandMedalSlot.DeleteExMedalSlotPassedDate( vDelExMedalSlotVec );

	if( vDelExMedalSlotVec.empty() )
		return;

	// send
	int iSize = vDelExMedalSlotVec.size();

	SP2Packet kPacket( STPK_EXPAND_MEDAL_SLOT_DELETE_BY_DATE );
	PACKET_GUARD_VOID( kPacket.Write(iSize) );

	for( int i=0; i<iSize; i++ )
	{
		PACKET_GUARD_VOID( kPacket.Write(vDelExMedalSlotVec[i].m_iClassType) );
		PACKET_GUARD_VOID( kPacket.Write(vDelExMedalSlotVec[i].m_iSlotNumber) );
	}
	SendMessage( kPacket );
}

void User::OnQuestOccur( SP2Packet &rkPacket )
{
	DWORD dwMainIndex = 0, dwSubIndex = 0;
	PACKET_GUARD_VOID(rkPacket.Read(dwMainIndex));
	PACKET_GUARD_VOID(rkPacket.Read(dwSubIndex));

	if( m_Quest.IsQuestComplete( dwMainIndex, dwSubIndex ) ) 
	{
		// 이미 완료한 퀘스트 인가?
		SP2Packet kPacket( STPK_QUEST_OCCUR );
		PACKET_GUARD_VOID(kPacket.Write(QUEST_OCCUR_ALREADY_COMPLETE));
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestOccur: %s(QUEST_OCCUR_ALREADY_COMPLETE) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
	}
	else if( m_Quest.IsQuestIndexCheck( dwMainIndex, dwSubIndex ) )
	{
		// 이미 보유중인 퀘스트 인가?
		SP2Packet kPacket( STPK_QUEST_OCCUR );
		PACKET_GUARD_VOID(kPacket.Write(QUEST_OCCUR_ALREADY_PROGRESS));
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestOccur: %s(QUEST_OCCUR_ALREADY_PROGRESS) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
	}
	else if( !g_QuestMgr.IsSameChanneling( this, dwMainIndex, dwSubIndex ) )
	{
		SP2Packet kPacket( STPK_QUEST_OCCUR );
		PACKET_GUARD_VOID(kPacket.Write(QUEST_OCCUR_CHANNELING_FAIL));
		SendMessage( kPacket );

		QuestParent *pQuestParent = g_QuestMgr.GetQuest( dwMainIndex, dwSubIndex );
		if( pQuestParent )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestOccur: %s(QUEST_OCCUR_CHANNELING_FAIL) : %d - %d - ( %d != %d )", 
									GetPublicID().c_str(), dwMainIndex, dwSubIndex, (int)GetChannelingType(), (int)pQuestParent->GetChannelingType() );
		}
		else
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestOccur: %s(QUEST_OCCUR_CHANNELING_FAIL) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
	}
	else
	{
		// 계급 등업 퀘스트의 경우 등급 확인 하드 코딩 추가.
		if( dwMainIndex == 800 && 
		(g_QuestMgr.GetQuest( dwMainIndex, dwSubIndex )->GetCustomValue( QuestGradeUP::LIMIT_GRADE )) > (GetGradeLevel()) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnQuestOccur Quest Insert Try. Grade Quest Cheat User: %s : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
			return;
		}
		
		// Insert!! 한번더 완료, 보유중 퀘스트 체크.....
		QuestData kQuestData = m_Quest.AddQuestData( dwMainIndex, dwSubIndex );
		if( kQuestData.GetMainIndex() == 0 )
		{
			// 없는 퀘스트.
			SP2Packet kPacket( STPK_QUEST_OCCUR );
			kPacket << QUEST_OCCUR_UNKNOWN_TYPE;
			//PACKET_GUARD_VOID(kPacket.Write(QUEST_OCCUR_UNKNOWN_TYPE));
			SendMessage( kPacket );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestOccur: %s(QUEST_OCCUR_UNKNOWN_TYPE) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
		}
		else
		{
			SP2Packet kPacket( STPK_QUEST_OCCUR );
			PACKET_GUARD_VOID(kPacket.Write(QUEST_OCCUR_OK));
			PACKET_GUARD_VOID(kPacket.Write(1));
			PACKET_GUARD_VOID(kPacket.Write(kQuestData.GetIndexData()));
			PACKET_GUARD_VOID(kPacket.Write(kQuestData.GetValueData()));
			PACKET_GUARD_VOID(kPacket.Write(kQuestData.GetMagicData()));
			PACKET_GUARD_VOID(kPacket.Write(kQuestData.GetDateData()));

			SendMessage( kPacket );

			// 로그 DB에 기록
			g_LogDBClient.OnInsertQuest( this, kQuestData.GetMainIndex(), kQuestData.GetSubIndex(), LogDBClient::QT_PROGRESS );

			if( kQuestData.GetMainIndex() == 321 )
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][campquest]  quest occur : id:%s, main:%d, sub:%d", GetPublicID().c_str(), kQuestData.GetMainIndex(), kQuestData.GetSubIndex() );
		}
	}
}

void User::OnQuestAttain( SP2Packet &rkPacket )
{
	QuestData kQuestData;
	kQuestData.ApplyData( rkPacket );
	QuestData kCompareData = m_Quest.GetQuestData( kQuestData.GetMainIndex(), kQuestData.GetSubIndex() );

	if( kCompareData.GetMainIndex() == 0 )
	{
		// 없는 퀘스트 - 리스트에서 삭제
		SP2Packet kPacket( STPK_QUEST_ATTAIN );
		kPacket << QUEST_ATTAIN_UNKNOWN_TYPE;
		//PACKET_GUARD_VOID(kPacket.Write(QUEST_ATTAIN_UNKNOWN_TYPE));
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestAttain: %s(QUEST_ATTAIN_UNKNOWN_TYPE) : %d, %d - %d", GetPublicID().c_str(), kQuestData.GetMainIndex(), kQuestData.GetSubIndex() );
	}
	else if( kCompareData.GetState() == QS_COMPLETE )
	{
		// 이미 완료한 퀘스트 - 보상을 또 받지 않게 클라이언트에서 막는다.
		SP2Packet kPacket( STPK_QUEST_ATTAIN );
		kPacket << QUEST_ATTAIN_ALREADY_COMPLETE << 1 << kCompareData.GetIndexData() << kCompareData.GetValueData() << kCompareData.GetDateData();

		/*PACKET_GUARD_VOID(kPacket.Write(QUEST_ATTAIN_ALREADY_COMPLETE));
		PACKET_GUARD_VOID(kPacket.Write(1));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetIndexData()));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetValueData()));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetDateData()));*/

		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestAttain: %s(QUEST_ATTAIN_ALREADY_COMPLETE) : %d - %d", GetPublicID().c_str(), kQuestData.GetMainIndex(), kQuestData.GetSubIndex() );
	}
	else
	{
		QuestData kResultData = m_Quest.SetQuestCurrentData( kQuestData ); //어뷰즈 체크
		
		SP2Packet kPacket( STPK_QUEST_ATTAIN );
		kPacket << QUEST_ATTAIN_OK << 1 << kResultData.GetIndexData() << kResultData.GetValueData() << kResultData.GetMagicData() << kResultData.GetDateData();
		SendMessage( kPacket );		

		if( kResultData.GetState() == QS_ATTAIN )
		{
			// 로그 DB에 기록
			g_LogDBClient.OnInsertQuest( this, kResultData.GetMainIndex(), kResultData.GetSubIndex(), LogDBClient::QT_ATTAIN );

			if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND ||
				ioLocalManager::GetLocalType() == ioLocalManager::LCT_TAIWAN   &&
				g_App.GetUseQuestEvent() == 1 )
			{
				//HRYOON 20150130 웹 이벤트 해당하면 빌링 호출
				/*if( kResultData.GetMainIndex() == g_App.GetEventMainIDX() && 
					kResultData.GetSubIndex() == g_App.GetEventSubIDX() )*/
				for(int i = 0; i < g_App.GetEventMaxMainCount(); i++ )
				{
					if( kResultData.GetMainIndex() == g_App.GetEventMainIDX(i) && 
						kResultData.GetSubIndex() == g_App.GetEventSubIDX() )
					{
						//rkPacket >> szBillingGUID >> dwApiType >> szPrivateID >> szPublicID >> szUserIP >> dwUserIndex >> dwReturnMsgType;
						char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
						Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
						m_szBillingGUID = szTempGUID;

						SP2Packet kBillingPacket( BSTPK_GA_WEB_EVENT );
						int dwType = 1;
						PACKET_GUARD_VOID( kBillingPacket.Write(m_szBillingGUID) );
						PACKET_GUARD_VOID( kBillingPacket.Write(dwType) );
						PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
						PACKET_GUARD_VOID( kBillingPacket.Write( GetPublicID()) );
						PACKET_GUARD_VOID( kBillingPacket.Write (GetPublicIP()) );
						PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
						PACKET_GUARD_VOID( kBillingPacket.Write( BSTPK_GA_WEB_EVENT_RESULT) );

						if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
						{
							LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Garena Web Event Send Fail : %d : %s", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
						}
						else
						{
							LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GARENA_EVENT]%s Garena Web Event Send %d : %s", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
						}
		}
				}
			}
		}
		
		// 진영전 퀘스트 관련 하드 코딩
		if( kQuestData.GetMainIndex() == 321 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][campquest] camp quest attain info : [id:%s, mainIndex:%d %d, subIndex:%d %d, magic:%d %d, value: %d %d]", GetPublicID().c_str(), kQuestData.GetMainIndex(), kResultData.GetMainIndex(), 
																																kQuestData.GetSubIndex(), kResultData.GetSubIndex(), kQuestData.GetMagicData(), kResultData.GetMagicData(),
																																kQuestData.GetValueData(), kResultData.GetValueData());
		}
	}
}

void User::OnQuestAlarm( SP2Packet &rkPacket )
{
	bool bAlarm;
	DWORD dwMainIndex, dwSubIndex;
	rkPacket >> dwMainIndex >> dwSubIndex >> bAlarm;
	m_Quest.SetQuestAlarm( dwMainIndex, dwSubIndex, bAlarm );	
}

void User::OnQuestReward( SP2Packet &rkPacket )
{
	bool isRewardSelectStyle = false;
	DWORD dwMainIndex, dwSubIndex;
	rkPacket >> dwMainIndex >> dwSubIndex >> isRewardSelectStyle;
	/*PACKET_GUARD_VOID(rkPacket.Read(dwMainIndex));
	PACKET_GUARD_VOID(rkPacket.Read(dwSubIndex));
	PACKET_GUARD_VOID(rkPacket.Read(isRewardSelectStyle));*/

	std::vector<BYTE> SelIndexes; // 선택한 보상 인덱스
	if ( isRewardSelectStyle ) // 선택방식 Quest인지 확인한다.
	{
		int numSel = 0;
		rkPacket >> numSel;
		//PACKET_GUARD_VOID(rkPacket.Read(numSel));
		for ( int i = 0; i < numSel; ++i ) 
		{
			BYTE index = 0;
			rkPacket >> index;
			SelIndexes.push_back( index );
		}
	}

	QuestData kCompareData = m_Quest.GetQuestData( dwMainIndex, dwSubIndex );
	if( kCompareData.GetMainIndex() == 0 )	
	{
		// 없는 퀘스트 - 리스트에서 삭제
		SP2Packet kPacket( STPK_QUEST_REWARD );
		kPacket << QUEST_REWARD_UNKNOWN_TYPE;
		//PACKET_GUARD_VOID(kPacket.Write(QUEST_REWARD_UNKNOWN_TYPE));
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestReward: %s(QUEST_REWARD_UNKNOWN_TYPE) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
	}
	else if( kCompareData.GetState() == QS_PROGRESS )
	{
		// 아직 달성하지 못한 퀘스트이다..
		SP2Packet kPacket( STPK_QUEST_REWARD );
		kPacket << QUEST_REWARD_NOT_ATTAIN << 1 << kCompareData.GetIndexData() << kCompareData.GetValueData() << kCompareData.GetDateData();
		/*PACKET_GUARD_VOID(kPacket.Write(QUEST_REWARD_NOT_ATTAIN));
		PACKET_GUARD_VOID(kPacket.Write(1));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetIndexData()));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetValueData()));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetDateData()));*/

		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestReward: %s(QUEST_REWARD_NOT_ATTAIN) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
	}
	else if( kCompareData.GetState() == QS_COMPLETE )
	{
		// 이미 완료한 퀘스트 - 보상을 또 받지 않게 클라이언트에서 막는다.
		SP2Packet kPacket( STPK_QUEST_REWARD );
		kPacket << QUEST_REWARD_ALREADY_COMPLETE << 1 << kCompareData.GetIndexData() << kCompareData.GetValueData() << kCompareData.GetDateData();
		/*
		PACKET_GUARD_VOID(kPacket.Write(QUEST_REWARD_ALREADY_COMPLETE));
		PACKET_GUARD_VOID(kPacket.Write(1));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetIndexData()));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetValueData()));
		PACKET_GUARD_VOID(kPacket.Write(kCompareData.GetDateData()));
		*/
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnQuestAttain: %s(QUEST_REWARD_ALREADY_COMPLETE) : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
	}
	else
	{
		
		QuestParent *pQuestParent = kCompareData.GetLinkQuest();
		bool bRet = pQuestParent->IsCheckQuestCompeleteUser( this );
		if( bRet )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnQuestAlarm Quest Insert Try. Grade Quest Cheat User: %s : %d - %d", GetPublicID().c_str(), dwMainIndex, dwSubIndex );
			return;
		}

		if( pQuestParent && pQuestParent->GetPerformType() == QP_EVENT)
		{
			if( !pQuestParent->IsCheckAlive() )
			{
				//TODO : 해킹으로 생긴 결과 logdb 에 기록을 남기자.

				// 개발자 계정은 스킵	JCLEE 140418
				if( IsDeveloper() )
					return;
			}
		}

		SP2Packet kPacket( STPK_QUEST_REWARD );
		kPacket << QUEST_REWARD_OK << 1;
		//PACKET_GUARD_VOID(kPacket.Write(QUEST_REWARD_OK));
		//PACKET_GUARD_VOID(kPacket.Write(1));
		m_Quest.SetQuestReward( dwMainIndex, dwSubIndex, isRewardSelectStyle, SelIndexes, kPacket );
		SendMessage( kPacket );
		
		// 둘다 저장
		SaveQuest();
		SaveUserData();

		// 로그 DB에 기록
		g_LogDBClient.OnInsertQuest( this, dwMainIndex, dwSubIndex, LogDBClient::QT_COMPLETE );
//		QuestParent *pQuestParent = kCompareData.GetLinkQuest();
		if( pQuestParent )
		{
			// 보상 받은 후 처리
			pQuestParent->ProcessRewardComplete( this );

			// 알림 
			if( !IsDeveloper() )
			{
				if( pQuestParent->IsCompleteWebAlarm() )
				{
					// DB 전송
					g_DBClient.OnInsertQuestWebAlarm( GetUserDBAgentID(), GetAgentThreadID(), GetPublicID(), GetUserIndex(), 
													  GetGradeLevel(), kCompareData.GetIndexData(), GetPublicIP() );
				}

				if( pQuestParent->IsCompleteGameAlarm() )
				{
					// 전체 서버 전송
					SP2Packet kPacket( SUPK_SERVER_ALARM_MENT );
					kPacket << UDP_SERVER_ALARM_QUEST_COMPLETE << GetPublicID() << pQuestParent->GetMainIndex() << pQuestParent->GetSubIndex();
					g_UserNodeManager.SendAllServerAlarmMent( kPacket );
				}
			}
		}
	}
}

bool User::_OnQuestDirectReward( int iPresentType, int iPresentValue1, int iPresentValue2, int iPresentValue3, int iPresentValue4, int iMentType )
{
	switch( iPresentType )
	{
	case PRESENT_SOLDIER:
		{
			int iResult = SetPresentChar( iPresentValue1, iPresentValue2 );
			if( iResult == PRESENT_RECV_OK )
			{
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward Character OK : %s - %d - %d", GetPublicID().c_str(), iPresentValue1, iPresentValue2 );
				return true;
			}
		}
		break;	
	case PRESENT_DECORATION:
		{
			ITEMSLOT kSlot;
			kSlot.m_item_type = iPresentValue1;
			kSlot.m_item_code = iPresentValue2;
			// 없는 치장만 받음
			if( !m_Inventory.IsSlotItem( kSlot ) )   
			{
				DWORD dwSlotIndex = 0;
				int   iSlotArray  = 0;
				m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_PRESENT, dwSlotIndex, iSlotArray );

				if( dwSlotIndex != 0 && dwSlotIndex != ioInventory::NEW_INDEX )
				{
					char szItemIndex[MAX_PATH]="";
					StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwSlotIndex, iSlotArray+1 ); // db field는 1부터 이므로 +1
					g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, 0, szItemIndex, LogDBClient::DT_PRESENT );
				}

				// 종족 치장을 구매하면 랜덤 치장 아이템을 지급한다.
				if( kSlot.m_item_type % 1000 == UID_KINDRED )
				{
					CHARACTER kCharInfo;
					kCharInfo.m_class_type = kSlot.m_item_type/100000;
					kCharInfo.m_sex        = 2; // 1남자, 2여자
					kCharInfo.m_face       = g_DecorationPrice.GetDefaultDecoCode( 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type ); // 0남자, 1여자
					kCharInfo.m_hair       = g_DecorationPrice.GetDefaultDecoCode( 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
					kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
					kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
					kCharInfo.m_underwear  = g_DecorationPrice.GetDefaultDecoCode( 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	
					SetDefaultDecoItem( kCharInfo );
				}
				m_UserGrowthLevel.AddCharGrowthPointByDecoWoman( kSlot.m_item_type, kSlot.m_item_code );
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward Deco : %s - %d - %d", GetPublicID().c_str(), kSlot.m_item_type, kSlot.m_item_code );
				return true;
			}			
		}
		break;
	case PRESENT_ETC_ITEM:
		{	
			int iResult = SetPresentEtcItem( iPresentValue1, iPresentValue2 );
			if( iResult == PRESENT_RECV_OK )
			{
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward EtcItem OK : %s - %d - %d", GetPublicID().c_str(), iPresentValue1, iPresentValue2 );
				return true;
			}
		}
		break;
	case PRESENT_PESO:
		{
			__int64 iPrevMoney = GetMoney();
			AddMoney( iPresentValue1 );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward Peso : %s - %I64d < - > %I64d", GetPublicID().c_str(), iPrevMoney, GetMoney() );
			g_LogDBClient.OnInsertPeso( this, iPresentValue1, LogDBClient::PT_RECV_PRESENT );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_RECV_PRESENT, PRESENT_PESO, 0, iPresentValue1, NULL);
			return true;
		}
		break;
	case PRESENT_EXTRAITEM:
		{
			int iResult = SetPresentExtraItem( iPresentValue1, 
											   ( iPresentValue2 % PRESENT_EXTRAITEM_DIVISION_1 ) / PRESENT_EXTRAITEM_DIVISION_2, 
											   iPresentValue2 % PRESENT_EXTRAITEM_DIVISION_2,
											   iPresentValue2 / PRESENT_EXTRAITEM_DIVISION_1, iPresentValue3, iPresentValue4, iMentType );
			if( iResult == PRESENT_RECV_OK )
			{
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward ExttraItem OK : %s - %d - %d - %d - %d", GetPublicID().c_str(), iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4 );
				return true;
			}
		}
		break;
	case PRESENT_EXTRAITEM_BOX:
		{
			int  iPesoArray = ( ( iPresentValue2/100 )%100 ) - 1;
			bool bCash = false;
			if( ( iPresentValue2%100 ) == 1 )
				bCash = true;
			int iResult = SetPresentExtraItemBox( iPresentValue1, iPesoArray, bCash  );	// 장비보급함 번호
			if( iResult == PRESENT_RECV_OK )
			{
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward ExtraItemBox OK : %s - %d - %d", GetPublicID().c_str(), iPresentValue1, iPresentValue2 );
				return true;
			}
		}
		break;
	case PRESENT_RANDOM_DECO:
		break;
	case PRESENT_GRADE_EXP:
		{
			int iPrevGradeLevel = GetGradeLevel();
			int iPrevGradeExp   = GetGradeExpert();
			if( AddGradeExp( iPresentValue1 ) )
				SendGradeSync();

			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward Grade Exp : %s - (%d)%d < - > (%d)%d", GetPublicID().c_str(), 
									iPrevGradeLevel, iPrevGradeExp, GetGradeLevel(), GetGradeExpert() );	
			return true;
		}
		break;
	case PRESENT_MEDALITEM:
		{
			int iResult = SetPresentMedalItem( iPresentValue1, iPresentValue2 );
			if( iResult == PRESENT_RECV_OK )
			{
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward MedalItem OK : %s - %d - %d", GetPublicID().c_str(), iPresentValue1, iPresentValue2 );
				return true;
			}
		}
		break;
	case PRESENT_ALCHEMIC_ITEM: 
		{
			int iResult = SetPresentAlchemicItem( iPresentValue1, iPresentValue2 );
			if( iResult == PRESENT_RECV_OK )
			{
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward AlchemicItem OK : %s - %d - %d", GetPublicID().c_str(), iPresentValue1, iPresentValue2 );
				return true;
			}
		}
		break;
	}
	return false;
}

bool User::_OnQuestRewardPresent( const ioHashString &rkSendID, int iPresentType, int iPresentValue1, int iPresentValue2, int iPresentValue3, int iPresentValue4, 
								  int iPresentState, int iPresentMent, int iPresentPeriod, bool bDirectPresent )
{
	if( !bDirectPresent || !_OnQuestDirectReward( iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, iPresentMent ) )
	{
		CTimeSpan cPresentGapTime( iPresentPeriod, 0, 0, 0 );
		CTime kPresentTime = CTime::GetCurrentTime() + cPresentGapTime;
/*		g_DBClient.OnInsertPresentData( GetUserDBAgentID(), rkSendID, GetPublicID(), iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, 
										iPresentMent, kPresentTime, iPresentState );
*/		AddPresentMemory( rkSendID, iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, 
					 	  iPresentMent, kPresentTime, iPresentState );
		g_LogDBClient.OnInsertPresent( 0, rkSendID, g_App.GetPublicIP().c_str(), GetUserIndex(), iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, LogDBClient::PST_RECIEVE, "QuestReward" );

		if( bDirectPresent )
		{
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnQuestDirectReward 즉시 지급이 되지 않아 선물로 지급 : %s - %d - %d - %d - %d - %d", GetPublicID().c_str(), iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4 );
		}
		return false;
	}

	return true;
}

void User::OnQuestAllDelete( SP2Packet &rkPacket )
{
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnQuestAllDelete : %s", GetPublicID().c_str() );
	if( IsDeveloper() )
	{
		m_Quest.InitQuestData();
	}
}

void User::OnPresentAllDelete( SP2Packet &rkPacket )
{
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnPresentAllDelete : %s", GetPublicID().c_str() );
	if( IsDeveloper() )
	{
		m_UserPresent.AllDeleteData();

		// 일괄 삭제
		g_DBClient.OnAllDeletePresentData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex() );

		if( m_dwPCRoomNumber != 0 )
			m_dwPCRoomNumber = 0;
		else
			m_dwPCRoomNumber = 1;

		SP2Packet kPacket( STPK_PCROOM_AUTHORITY );
		PACKET_GUARD_VOID( kPacket.Write( GetPCRoomNumber() ) );
		PACKET_GUARD_VOID( kPacket.Write( m_UserPcRoom.GetPcRoomCharMax() ) );
		SendMessage( kPacket );
	}
}

void User::OnHeroTop100Data( SP2Packet &rkPacket )
{
	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_HeroRankManager.SendCurTop100Data( this, iCurPage, iMaxCount );
}

void User::OnHeroMatchOtherInfo( SP2Packet &rkPacket )
{
	ioHashString kNickName;
	rkPacket >> kNickName;

	UserParent *pUserInfo = g_UserNodeManager.GetGlobalUserNode( kNickName );
	if( pUserInfo )
	{
		if( pUserInfo->IsUserOriginal() )
		{
			User *pUser = (User*)pUserInfo;
			SP2Packet kPacket( STPK_HERO_MATCH_OTHER_INFO );
			pUser->FillHeroMatchInfo( kPacket );
			SendMessage( kPacket );	
		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserInfo;
			SP2Packet kPacket( SSTPK_HERO_MATCH_OTHER_INFO );
			kPacket << pUser->GetUserIndex() << GetUserIndex();
			pUser->SendMessage( kPacket );
		}
	}
}

void User::EquipSlotItem( SP2Packet &rkPacket )
{
	int iSelectArray;
	ITEMSLOT kSlot;
	rkPacket >> iSelectArray >> kSlot.m_item_type >> kSlot.m_item_code;

	if( !COMPARE( iSelectArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::EquipSlotItem Array Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
		//
	}

	if( !m_Inventory.IsSlotItem( kSlot ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::EquipSlotItem Not Item Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
	}
	// 장착
	if( m_CharList[iSelectArray]->SetCharDecoration( kSlot.m_item_type, kSlot.m_item_code ) )
	{
		m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code);

		// 종족 치장을 착용하면 해당 성별에 맞는 치장으로 갈아입힌다.
		if( kSlot.m_item_type % 1000 == UID_KINDRED )
		{
			const CHARACTER &rkCharInfo = m_CharList[iSelectArray]->GetCharInfo();
			CHARACTER rkChangeInfo = rkCharInfo;
			m_Inventory.GetEquipItemCode( rkChangeInfo );
			m_CharList[iSelectArray]->SetChangeKindred( rkChangeInfo, GetPrivateID().GetHashCode() );
		}

		// 
		SP2Packet kPacket( STPK_EQUIP_SLOT_ITEM );
		kPacket << EQUIP_SLOT_ITEM_OK;
		kPacket << kSlot.m_item_type << kSlot.m_item_code << m_CharList[iSelectArray]->GetCharIndex() << (CHARACTER)m_CharList[iSelectArray]->GetCharInfo();
		SendMessage( kPacket );	

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharDecoUpdate( this, m_CharList[iSelectArray] );
		}
	}	
}

void User::ReleaseSlotItem( SP2Packet &rkPacket )
{
	int iSelectArray;
	ITEMSLOT kSlot;
	rkPacket >> iSelectArray >> kSlot.m_item_type >> kSlot.m_item_code;

	if( !COMPARE( iSelectArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ReleaseSlotItem Array Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
		//
	}

	if( !m_Inventory.IsSlotItem( kSlot ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::ReleaseSlotItem Not Item Fail %s) %d - %d - %d",GetPublicID().c_str(), iSelectArray, kSlot.m_item_type, kSlot.m_item_code );
		return;
	}

	// 같은 타입의 다른 아이템 검색.. 검색실패하면 예외처리
	ITEMSLOT rkSlot;
	if( !m_Inventory.FindOtherSlotItem( kSlot, rkSlot ) )
	{
		// 예외처리
		SP2Packet kPacket( STPK_EQUIP_SLOT_ITEM );
		kPacket << EQUIP_SLOT_ITEM_FAIL;
		SendMessage( kPacket );	
		return;
	}

	if( m_CharList[iSelectArray]->SetCharDecoration( rkSlot.m_item_type, rkSlot.m_item_code ) )
	{
		m_Inventory.SetEquipItem( rkSlot.m_item_type, rkSlot.m_item_code);

		// 종족 치장을 착용하면 해당 성별에 맞는 치장으로 갈아입힌다.
		if( kSlot.m_item_type % 1000 == UID_KINDRED )
		{
			const CHARACTER &rkCharInfo = m_CharList[iSelectArray]->GetCharInfo();
			CHARACTER rkChangeInfo = rkCharInfo;
			m_Inventory.GetEquipItemCode( rkChangeInfo );
			m_CharList[iSelectArray]->SetChangeKindred( rkChangeInfo, GetPrivateID().GetHashCode() );
		}

		// 
		SP2Packet kPacket( STPK_EQUIP_SLOT_ITEM );
		kPacket << EQUIP_SLOT_ITEM_OK;
		kPacket << rkSlot.m_item_type << rkSlot.m_item_code << m_CharList[iSelectArray]->GetCharIndex() << (CHARACTER)m_CharList[iSelectArray]->GetCharInfo();
		SendMessage( kPacket );	
	}	
}

void User::OnMedalItemChange(SP2Packet &rkPacket)
{
	int iCharArray = 0;
	int iItemType  = 0;
	bool bEquip    =   false;

	PACKET_GUARD_VOID( rkPacket.Read(iCharArray) );
	PACKET_GUARD_VOID( rkPacket.Read(iItemType) );
	PACKET_GUARD_VOID( rkPacket.Read(bEquip) );

	if( m_pMyRoom && GetPlayingMode() == MT_UNDERWEAR )
	{
		Mode* pMode = m_pMyRoom->GetModeInfo();
		if( pMode )
		{
			if( pMode->GetState() == Mode::MS_READY || pMode->GetState() == Mode::MS_PLAY )
			{
				SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
				PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
				PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_SKIP) );
				SendMessage( kReturn );
				return;
			}
		}
	}

	if( !COMPARE( iCharArray, 0, GetCharCount() ) )
	{
		SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s CharArray is wrong.[%d/%s]", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	ioCharacter *rkChar = m_CharList[iCharArray];
	if(rkChar == NULL)
	{
		SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Char == NULL.[%d/%s]", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	//동일한 매달을 장착중
	if( bEquip )
	{
		if( m_UserMedalItem.IsEquipMedalByChar( rkChar->GetClassType(), iItemType ) )
		{
			SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_ALREADY_EQUIPPED) );
			SendMessage( kReturn );
			return;
		}

	}

	ioUserMedalItem::MEDALITEMSLOT kSlot;
	if( !m_UserMedalItem.GetMedalItem( rkChar->GetClassType(), iItemType, bEquip, kSlot ) )
	{
		SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s he didn't have a medal.[%d/%s]", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	if( !bEquip )	
	{
		kSlot.m_iEquipClass = 0; // 0: 착용해제
		m_UserMedalItem.SetMedalItemDueToTakeOff( rkChar->GetClassType(), iItemType, kSlot );
		//m_UserMedalItem.SetMedalItem( kSlot );
	}
	else					
	{
		int iCurLevel      = GetClassLevel( iCharArray, true );
		int iEnableLevel   = g_MedalItemMgr.GetLevelLimit( iItemType );
		if( iCurLevel < iEnableLevel )
		{
			SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s he need more level.[%d/%s](%d/%d/%d)", __FUNCTION__, GetUserIndex(), GetPublicID().c_str() , iItemType, iCurLevel, iEnableLevel );
			return;
		}	

		int iClassType = rkChar->GetCharInfo().m_class_type;
		if( !g_MedalItemMgr.IsRight( iItemType, iClassType ) )
		{
			SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s class is wrong.[%d/%s](%d/%d)", __FUNCTION__ , GetUserIndex(), GetPublicID().c_str(), iItemType, iClassType );
			return;
		}

		int iCurEquipNum   = m_UserMedalItem.GetEquipNum( iClassType );
		int iEnableSlotNum = g_MedalItemMgr.GetSlotNum( iCurLevel );
		int iExpandMedalSlotNum = m_UserExpandMedalSlot.GetExpandMedalSlotNum( iClassType );
		if( iCurEquipNum >= iEnableSlotNum + iExpandMedalSlotNum )
		{
			SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s slot is wrong.[%d/%s](%d/%d/%d/%d)", __FUNCTION__ , GetUserIndex(), GetPublicID().c_str(), iItemType, iClassType, iCurEquipNum, iEnableSlotNum );
			return;
		}	

		kSlot.m_iEquipClass = iClassType; // 착용
		m_UserMedalItem.SetMedalItemDueToEquip( iItemType, kSlot );
		//m_UserMedalItem.SetMedalItem( kSlot );
	}

	if( GetModeType() != MT_NONE && !m_pMyRoom )
	{
		SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_FAIL) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s position is worng.[%d/%s]", __FUNCTION__ , GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	SP2Packet kReturn( STPK_MEDALITEM_CHANGE );
	PACKET_GUARD_VOID( kReturn.Write(GetPublicID()) );
	PACKET_GUARD_VOID( kReturn.Write(MEDALITEM_CHANGE_OK) );
	PACKET_GUARD_VOID( kReturn.Write(iCharArray) );
	PACKET_GUARD_VOID( kReturn.Write(iItemType) );
	PACKET_GUARD_VOID( kReturn.Write(bEquip) );

	if( m_pMyRoom && !m_pMyRoom->IsRoundEndState() && m_select_char == iCharArray )
		m_pMyRoom->RoomSendPacketTcp( kReturn );
	else
		SendMessage( kReturn );

	if( m_pMyRoom && rkChar )
		m_pMyRoom->OnModeCharMedalUpdate( this, rkChar->GetCharIndex(), iItemType, bEquip );
}

void User::DeleteMedalItemPassedDate( bool bImmediately )
{
	IntVec vDeletTypeVec;
	m_UserMedalItem.DeleteMedalItemPassedDate( vDeletTypeVec );

	if( vDeletTypeVec.empty() )
		return;

	// send
	int iSize = vDeletTypeVec.size();

	SP2Packet kPacket( STPK_DELETE_MEDALITEM_DATE );

	PACKET_GUARD_VOID( kPacket.Write(iSize) );
	for (int i = 0; i < iSize ; i++)
	{
		PACKET_GUARD_VOID( kPacket.Write(vDeletTypeVec[i]) );
	}
	PACKET_GUARD_VOID( kPacket.Write(bImmediately) );

	SendMessage( kPacket );
}

void User::FillEquipMedalItem( SP2Packet &rkPacket )
{
	PACKET_GUARD_VOID( rkPacket.Write(GetPublicID()) );

	if( (GetPlayingMode() == MT_UNDERWEAR) || (GetPlayingMode() == MT_CBT) )
	{
		for( int i=0 ; i< ioMedalItemInfoManager::MAX_SLOT_NUM ; i++ )
			PACKET_GUARD_VOID( rkPacket.Write(0) );

		return;
	}

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		bool bRoom = false;
		if( m_pMyRoom )
			bRoom = true;
		for( int i=0 ; i< ioMedalItemInfoManager::MAX_SLOT_NUM ; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write(0) );
		}
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s [%d/%s] : %d >= %d(IsRoom(%d)IsParty(%d)IsLadderTeam(%d))",__FUNCTION__, GetUserIndex(), GetPublicID().c_str(), m_select_char, GetCharCount(), bRoom, IsBattleRoom(), IsLadderTeam() );
		return;
	}

	ioCharacter *rkChar = m_CharList[m_select_char];
	if(rkChar == NULL)
	{
		for( int i=0 ; i< ioMedalItemInfoManager::MAX_SLOT_NUM ; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write(0) );
		}
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Char == NULL.[%d/%s]",__FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}
	FillEquipMedalItemByClassType( rkChar->GetCharInfo().m_class_type, rkPacket );
}

void User::FillEquipMedalItemByClassType( IN int iClassType, OUT SP2Packet &rkPacket )
{
	for(int i = 0;i < (int)m_CharList.size();i++)
	{
		if( m_CharList[i]->GetCharInfo().m_class_type != iClassType ) continue;
		if( m_CharList[i]->HasExerciseStyle( EXERCISE_RENTAL ) == false ) continue;

		// 대여 용병 메달
		IntVec vMedal;
		m_CharRentalData.GetEquipMedal( m_CharList[i]->GetCharIndex(), vMedal );
		for(int k = 0;k < ioMedalItemInfoManager::MAX_SLOT_NUM;k++)
		{
			if( k < (int)vMedal.size() )
			{
				PACKET_GUARD_VOID( rkPacket.Write(vMedal[k]) );
			}
			else
			{
				PACKET_GUARD_VOID( rkPacket.Write(0) );
			}
		}
		return;
	}
	// 아래 ioMedalItemInfoManager::MAX_SLOT_NUM 개선할 때 대여 용병 메달 필히 수정 요망
	m_UserMedalItem.FillEquipClass( iClassType, ioMedalItemInfoManager::MAX_SLOT_NUM, rkPacket );
}

void User::FillExMedalSlotByClassType( IN int iClassType, OUT SP2Packet &rkPacket )
{
	PACKET_GUARD_VOID( rkPacket.Write(GetPublicID()) );

	m_UserExpandMedalSlot.FillUseClass( iClassType, rkPacket );
}

void User::FillGrowthLevelData( SP2Packet &rkPacket )
{
	PACKET_GUARD_VOID( rkPacket.Write(GetPublicID()) );

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		bool bRoom = false;
		if( m_pMyRoom )
			bRoom = true;
		for( int i=0 ; i< MAX_CHAR_GROWTH + MAX_ITEM_GROWTH; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write((BYTE)0) ) ;
		}
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s [%d/%s] : %d >= %d(IsRoom(%d)IsParty(%d)IsLadderTeam(%d))",__FUNCTION__, GetUserIndex(), GetPublicID().c_str(), m_select_char, GetCharCount(), bRoom, IsBattleRoom(), IsLadderTeam() );
		return;
	}

	ioCharacter *rkChar = m_CharList[m_select_char];
	if(rkChar == NULL)
	{
		for( int i=0 ; i< MAX_CHAR_GROWTH + MAX_ITEM_GROWTH ; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write((BYTE)0) ) ;
		}
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Char == NULL.[%d/%s]",__FUNCTION__, GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	if( rkChar->HasExerciseStyle( EXERCISE_RENTAL ) && rkChar->GetRentalLimitTime() != 0 )
	{
		if( m_CharRentalData.FillGrowthData( rkChar->GetCharIndex(), rkPacket ) == false )
		{
			for( int i=0 ; i< MAX_CHAR_GROWTH + MAX_ITEM_GROWTH ; i++ )
			{
				PACKET_GUARD_VOID( rkPacket.Write((BYTE)0) ) ;
			}
		}
	}
	else
	{
		FillGrowthLevelDataByClassType( rkChar->GetCharInfo().m_class_type, rkPacket );
	}
}

void User::FillGrowthLevelDataByClassType( int iClassType, SP2Packet &rkPacket )
{
	if( m_UserGrowthLevel.FillGrowthLevelDataByClassType( iClassType, rkPacket ) == false )
	{
		for( int i=0 ; i< MAX_CHAR_GROWTH + MAX_ITEM_GROWTH ; i++ )
		{
			PACKET_GUARD_VOID( rkPacket.Write((BYTE)0) ) ;
		}
	}
}

void User::FillTotalGrowthLevelDataByClassType( IN int iSelectClassType, OUT SP2Packet &rkPacket )
{
	ioCharacter *pRentalCheckChar = GetCharacter( m_select_char );

	const int iArraySize = MAX_CHAR_GROWTH+MAX_ITEM_GROWTH;
	int iGrowthLevelArray[iArraySize];
	ZeroMemory( iGrowthLevelArray, sizeof( iGrowthLevelArray ) );

	int i = 0;
	int iArrayCnt = 0;
	for(i = 0; i < MAX_CHAR_GROWTH ; i++)
	{
		iGrowthLevelArray[iArrayCnt] = m_UserGrowthLevel.GetCharGrowthLevel( iSelectClassType, i, false );	
		iArrayCnt++;
	}

	for(i = 0; i < MAX_ITEM_GROWTH ; i++)
	{
		iGrowthLevelArray[iArrayCnt] = m_UserGrowthLevel.GetItemGrowthLevel( iSelectClassType, i, false );
		iArrayCnt++;
	}

	IntVec vMedalItemTypeVec;	
	if( pRentalCheckChar && pRentalCheckChar->HasExerciseStyle( EXERCISE_RENTAL ) )
	{
		m_CharRentalData.GetEquipMedal( pRentalCheckChar->GetCharIndex(), vMedalItemTypeVec );
	}

	if( vMedalItemTypeVec.empty() )
	{
		m_UserMedalItem.GetMedalItemTypeVec( vMedalItemTypeVec, iSelectClassType );
	}

	int iMedalSize = vMedalItemTypeVec.size();
	for(i = 0; i < iMedalSize ; i++)
	{
		int j = 0;
		for (j = 0; j < MAX_CHAR_GROWTH; j++)
		{
			if( COMPARE( j, 0, iArraySize ) )
				iGrowthLevelArray[j] += g_MedalItemMgr.GetMedalItemGrowth( vMedalItemTypeVec[i], true, j );
		}

		for (j = 0; j < MAX_ITEM_GROWTH; j++)
		{
			int iCurArry = j+MAX_CHAR_GROWTH;
			if( COMPARE( iCurArry, 0, iArraySize ) )
				iGrowthLevelArray[iCurArry] += g_MedalItemMgr.GetMedalItemGrowth( vMedalItemTypeVec[i], false, j );
		}	
	}

	if( !COMPARE( m_select_char, 0, GetCharCount() ) )
	{
		for (i = 0; i < iArraySize ; i++)
			PACKET_GUARD_BREAK( rkPacket.Write( iGrowthLevelArray[i] ) );
			//rkPacket << iGrowthLevelArray[i];
		return;
	}

	ioCharacter *rkChar = m_CharList[m_select_char];
	if(rkChar == NULL)
	{
		for (i = 0; i < iArraySize ; i++)
			PACKET_GUARD_BREAK( rkPacket.Write( iGrowthLevelArray[i] ) );
			//rkPacket << iGrowthLevelArray[i];
		return;
	}

	for(i = 0; i < iArraySize ; i++)
	{
		PACKET_GUARD_BREAK( rkPacket.Write( iGrowthLevelArray[i] ) );
		//rkPacket << iGrowthLevelArray[i];
	}
	
	for(i = 0; i < MAX_CHAR_DBITEM_SLOT ; i++)
	{
		const ITEM_DATA *pItemData = rkChar->GetDBItemData( i );
		if( pItemData && pItemData->m_item_code > 0 )
		{
			//rkPacket << pItemData->m_item_reinforce;
			PACKET_GUARD_BREAK( rkPacket.Write( pItemData->m_item_reinforce ) );
			/*if( COMPARE( i, 0, iArraySize ) )
				iGrowthLevelArray[i] += pItemData->m_item_reinforce;
			if( COMPARE( i+MAX_CHAR_GROWTH, 0, iArraySize ) )
				iGrowthLevelArray[i+MAX_CHAR_GROWTH] += pItemData->m_item_reinforce;
			*/
		}
		else
		{
			PACKET_GUARD_BREAK( rkPacket.Write( 0 ) );
			//rkPacket << 0 ;
	}
	}
	
}

void User::FillHeroMatchInfo( SP2Packet &rkPacket )
{
	rkPacket << GetPublicID() << GetGradeLevel();
	rkPacket << m_UserHeroData.m_iHeroTodayRank << GetHeroTitle();
	rkPacket << ( m_UserRecord.GetRecordWin( RECORD_HEROMATCH ) / 30 );
	rkPacket << ( m_UserRecord.GetRecordLose( RECORD_HEROMATCH ) / 10 );

	// 캐릭터 정보
	int iClassType = GetCharClassType( m_select_char );
	if( iClassType > 0 )
	{		
		FillClassData( iClassType, false, rkPacket );
	}
}

void User::FillUserCharListInfo( SP2Packet &rkPacket, int iStartArray, int iSyncCount )
{
	rkPacket << GetPublicID();

	int i = 0;
	vCharList SyncCharList;	
	for(i = 0;i < (int)m_CharList.size();i++)
	{
		if( m_CharList[i] == NULL ) continue;
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;        // 구매 용병만 동기화 - 체험/대여/PC방 용병 제외

		SyncCharList.push_back( m_CharList[i] );
	}

	int iMaxSize = (int)SyncCharList.size();
	int iCurSize  = max( 0, min( iMaxSize - iStartArray, iSyncCount ) );

	rkPacket << iStartArray << iMaxSize << iCurSize;
	if( iStartArray == 0 )  // 대표 용병
	{
		ioCharacter *pLeaderChar = GetLeaderCharacter();
		if( pLeaderChar )
		{
			rkPacket << true;

			// 모션 아이템
			rkPacket << GetEtcMotionAni( ioEtcItemMotion::MOTION_OPTION_10 );

			// 캐릭터 정보
			const CHARACTER &rkCharInfo = pLeaderChar->GetCharInfo();
			CHARACTER rkChangeInfo = rkCharInfo;
			rkPacket << rkChangeInfo << GetClassLevelByType( rkChangeInfo.m_class_type, false );

			// 캐릭터 장착 장비 정보
			pLeaderChar->FillDBExtraItemInfo( rkPacket, this, true );
		}
		else
		{
			rkPacket << false;      // Exception Error
		}
	}

	// 용병 리스트 정렬 - 대표 용병 -> 슬롯 위치
	std::sort( SyncCharList.begin(), SyncCharList.end(), CharInfoSort() );

	// 용병 리스트
	for(i = iStartArray; i < iStartArray + iCurSize;i++)
	{
		if( i >= iMaxSize )
		{
			rkPacket << false;      // Exception Error
		}
		else
		{
			rkPacket << true;

			// 캐릭터 정보
			const CHARACTER &rkCharInfo = SyncCharList[i]->GetCharInfo();
			CHARACTER rkChangeInfo = rkCharInfo;
			rkPacket << rkChangeInfo << GetClassLevelByType( rkChangeInfo.m_class_type, false );
			
			// 캐릭터 장착 장비 정보
			SyncCharList[i]->FillDBExtraItemInfo( rkPacket, this, true );
		}
	}
	SyncCharList.clear();
}

void User::FillUserCharSubInfo( SP2Packet &rkPacket, int iClassType )
{
	rkPacket << GetPublicID() << iClassType;

	// 용병 성장 정보
	m_UserGrowthLevel.FillClassTypeGrowthInfo( rkPacket, iClassType );

	int iArray = GetCharArrayByClass( iClassType );
	if( iArray == -1 )
	{
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::FillUserCharSubInfo Get Char Array None ( %s, class Type %d )", GetPublicID().c_str(), iClassType );
		BYTE chAwakeType = AWAKE_NONE;
		PACKET_GUARD_VOID( rkPacket.Write( chAwakeType  ) );
	}
	else
	{
		BYTE chAwakeType = m_CharList[iArray]->GetAwakeType();
		PACKET_GUARD_VOID( rkPacket.Write( chAwakeType  ) );
	}

	// 용병 메달 정보
	int iMaxMedal = m_UserMedalItem.GetEquipNum( iClassType );
	rkPacket << iMaxMedal;
	if( iMaxMedal > 0 )
		m_UserMedalItem.FillEquipClass( iClassType, iMaxMedal, rkPacket );
}

void User::OnTradeCreate( SP2Packet &rkPacket )
{
	DWORD dwItemType, dwItemMagicCode, dwItemValue, dwRegisterPeriod, dwItemMaleCustom, dwItemFemaleCustom;
	int iType, iExtraValue;
	__int64 iItemPrice;

	rkPacket >> iType >> iExtraValue >> iItemPrice;

	// 넘어온 아이템이 등록 가능한 아이템인지 체크후 아래 처리.
	if( iType == PRESENT_EXTRAITEM )
	{
		ioUserExtraItem::EXTRAITEMSLOT rkExtraItem;
		if( !m_UserExtraItem.GetExtraItem( iExtraValue, rkExtraItem ) )
		{
			// Not Find Error
			SP2Packet kPacket( STPK_TRADE_CREATE );
			kPacket << TRADE_CREATE_NO_ITEM;
			SendMessage( kPacket );
			return;
		}

		if( rkExtraItem.m_iTradeState != ioUserExtraItem::EET_ENABLE )
		{
			// Disable trade Error
			SP2Packet kPacket( STPK_TRADE_CREATE );
			kPacket << TRADE_CREATE_DISABLE;
			SendMessage( kPacket );
			return;
		}

		// Level Check
		if( GetGradeLevel() < g_TradeInfoMgr.GetRegisterLimitLv() )
		{
			SP2Packet kPacket( STPK_TRADE_CREATE );
			kPacket << TRADE_CREATE_LEVEL;
			SendMessage( kPacket );
			return;
		}

		// Peso Check
		__int64 iTexPrice = 0;
		if( IsPCRoomAuthority() )
			iTexPrice = iItemPrice * g_TradeInfoMgr.GetPCRoomRegisterTexRate();
		else
			iTexPrice = iItemPrice * g_TradeInfoMgr.GetRegisterTexRate();

		if( GetMoney() < iTexPrice )
		{
			SP2Packet kPacket( STPK_TRADE_CREATE );
			kPacket << TRADE_CREATE_PESO;
			SendMessage( kPacket );
			return;
		}

		// 등록 수수료 차감
		RemoveMoney( iTexPrice );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_TRADE_TEX, PRESENT_EXTRAITEM, rkExtraItem.m_iItemCode, iTexPrice, NULL);
		TradeLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "TradeCreate(%d:%s) - [RegisterPeso] %I64d", GetUserIndex(), GetPublicID().c_str(), iTexPrice );

		dwItemType			= PRESENT_EXTRAITEM;
		dwItemMagicCode		= rkExtraItem.m_iItemCode;
		dwItemValue			= rkExtraItem.m_iReinforce;
		dwRegisterPeriod	= (DWORD)g_TradeInfoMgr.GetTradePeriod();
		dwItemMaleCustom	= rkExtraItem.m_dwMaleCustom;
		dwItemFemaleCustom	= rkExtraItem.m_dwFemaleCustom;

		TradeLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "TradeCreate(%d:%s) - [DeleteItem] ExtraItemSlotIndex: %d", GetUserIndex(), GetPublicID().c_str(), iExtraValue );
		m_UserExtraItem.DeleteExtraItem( iExtraValue );
		m_UserExtraItem.SaveData();

		SP2Packet kPacket( STPK_TRADE_CREATE );
		kPacket << TRADE_CREATE_DEL;
		kPacket << iExtraValue;
		kPacket << GetMoney();
		SendMessage( kPacket );

		g_DBClient.OnSelectCreateTrade( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(),
										dwItemType, dwItemMagicCode, dwItemValue, iItemPrice, dwRegisterPeriod, dwItemMaleCustom, dwItemFemaleCustom );
	}
	else
	{
		// fail
		SP2Packet kPacket( STPK_TRADE_CREATE );
		kPacket << TRADE_CREATE_ERROR;
		SendMessage( kPacket );
		return;
	}
}

void User::OnTradeList( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TRADE_LIST );
	PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTradeItem( SP2Packet &rkPacket )
{
	DWORD dwTradeIndex;
	rkPacket >> dwTradeIndex;

	// Level Check
	if( GetGradeLevel() < g_TradeInfoMgr.GetItemBuyLimitLv() )
	{
		SP2Packet kSuccess( STPK_TRADE_ITEM_COMPLETE );
		kSuccess << TRADE_BUY_LEVEL;
		SendMessage( kSuccess );
		return;
	}

	TradeLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "TradeItem - [Request] [User:%s] [Index:%d]", GetPublicID().c_str(), dwTradeIndex );

	float fRate	= 0.0f;

	if( IsPCRoomAuthority() )
		fRate = g_TradeInfoMgr.GetPCRoomBuyTexRate();
	else
		fRate	= g_TradeInfoMgr.GetBuyTexRate();

	SP2Packet kPacket( MSTPK_TRADE_ITEM_TRADE );
	kPacket << TRADE_ITEM_GET_INFO;
	kPacket << GetUserIndex();
	kPacket << dwTradeIndex << GetMoney();
	kPacket << fRate;
	g_MainServer.SendMessage( kPacket );
}

void User::OnTradeCancel( SP2Packet &rkPacket )
{
	DWORD dwTradeIndex;
	rkPacket >> dwTradeIndex;

	TradeLOG.PrintTimeAndLog( LOG_TEST_LEVEL, "TradeCancel - [Request] [User:%s] [Index:%d]", GetPublicID().c_str(), dwTradeIndex );

	SP2Packet kPacket( MSTPK_TRADE_ITEM_CANCEL );
	kPacket << TRADE_ITEM_CANCEL_GET_INFO;
	kPacket << GetUserIndex();
	kPacket << dwTradeIndex;
	g_MainServer.SendMessage( kPacket );
}

void User::OnEventShopGoodsList( SP2Packet &rkPacket )
{
	// 메인 서버에 물품 목록 요청
	SP2Packet kPacket( MSTPK_EVENT_SHOP_GOODS_LIST );
	kPacket << GetUserIndex();
	g_MainServer.SendMessage( kPacket );
}

void User::_OnEventShopGoodsBuy( int iBuyState, SP2Packet &rkPacket )
{
	// 메인 서버로 부터 받은 정보
	switch( iBuyState )
	{
	case EVENT_SHOP_GOODS_BUY_RESERVE:
		{
			DWORD dwGoodsIndex, dwNeedEtcItemType;
			int iNeedEtcItemCount;
			rkPacket >> dwGoodsIndex >> dwNeedEtcItemType >> iNeedEtcItemCount;

			// 구매 가능 여부 판단
			ioUserEtcItem::ETCITEMSLOT kNeedCoinSlot;
			m_UserEtcItem.GetEtcItem( dwNeedEtcItemType, kNeedCoinSlot );
			if( kNeedCoinSlot.GetUse() < iNeedEtcItemCount )
			{
				// 구매 조건 안됨
				SP2Packet kPacket( STPK_EVENT_SHOP_GOODS_BUY );
				kPacket << EVENT_SHOP_GOODS_BUY_TERMS_FAILED << dwNeedEtcItemType;
				SendMessage( kPacket );

				// 메인 서버에 실패 알림
				SP2Packet kMainPacket( MSTPK_EVENT_SHOP_GOODS_BUY_RESULT );
				kMainPacket << EVENT_SHOP_GOODS_BUY_RESULT_CANCEL << dwGoodsIndex;
				g_MainServer.SendMessage( kMainPacket );
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Event Shop Use Etc Item Failed!!!! (%s/%d/%d)", GetPublicID().c_str(), kNeedCoinSlot.m_iType, kNeedCoinSlot.m_iValue1 );
			}
			else
			{
				// 코인 감소
				kNeedCoinSlot.AddUse( -iNeedEtcItemCount );
				m_UserEtcItem.SetEtcItem( kNeedCoinSlot );
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "Use Etc Item (%s/%d/%d)", GetPublicID().c_str(), kNeedCoinSlot.m_iType, kNeedCoinSlot.m_iValue1 );

				// 선물로 지급할 정보
				short iPresentType;
				ioHashString szSendID;
				bool  bPresentAlarm, bPresentDirect;
				int   iPresentMent, iPresentPeriod, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4;				
				rkPacket >> szSendID >> iPresentType >> iPresentValue1 >> iPresentValue2 >> iPresentValue3 >> iPresentValue4;
				rkPacket >> bPresentAlarm >> bPresentDirect >> iPresentMent >> iPresentPeriod;

				CTimeSpan cPresentGapTime( iPresentPeriod, 0, 0, 0 );
				CTime kPresentTime = CTime::GetCurrentTime() + cPresentGapTime;

				// 유저에게 결과 전송
				SP2Packet kPacket( STPK_EVENT_SHOP_GOODS_BUY );
				kPacket << EVENT_SHOP_GOODS_BUY_OK << dwGoodsIndex << dwNeedEtcItemType << iNeedEtcItemCount;
				SendMessage( kPacket );

				AddPresentMemory( szSendID, iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, 
								  iPresentMent, kPresentTime, (short)bPresentAlarm );
				SendPresentMemory();

				if( dwNeedEtcItemType == ioEtcItem::EIT_ETC_CLOVER )
				{
					g_LogDBClient.OnInsertPresent( 0, szSendID, g_App.GetPublicIP().c_str(), GetUserIndex(), iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, LogDBClient::PST_CLOVERSHOP, "CloverShopBuy" );
				}
				else if( dwNeedEtcItemType == ioEtcItem::EIT_ETC_MILEAGE_COIN )
				{
					g_LogDBClient.OnInsertPresent( 0, szSendID, g_App.GetPublicIP().c_str(), GetUserIndex(), iPresentType, iPresentValue1, 
						iPresentValue2, iPresentValue3, iPresentValue4, LogDBClient::PST_MILEAGESHOP, "EventShopBuy" );
				}
				else
				{
					g_LogDBClient.OnInsertPresent( 0, szSendID, g_App.GetPublicIP().c_str(), GetUserIndex(), iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, LogDBClient::PST_EVENTSHOP, "EventShopBuy" );
				}
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "_OnEventShopGoodsBuy Ok : %s - %d/%d/%d/%d/%d/%d/%d/%d/%d", GetPublicID().c_str(), iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4,
										(int)bPresentAlarm, (int)bPresentDirect, iPresentMent, iPresentPeriod );				

				// 메인 서버에 구매 완료 알림
				SP2Packet kMainPacket( MSTPK_EVENT_SHOP_GOODS_BUY_RESULT );
				kMainPacket << EVENT_SHOP_GOODS_BUY_RESULT_OK << dwGoodsIndex << GetUserIndex();
				g_MainServer.SendMessage( kMainPacket );
			}
		}
		break;
	default:
		{
			SP2Packet kPacket( STPK_EVENT_SHOP_GOODS_BUY );
			kPacket << iBuyState;
			SendMessage( kPacket );
		}
		break;
	}
}

void User::OnEventShopGoodsBuy( SP2Packet &rkPacket )
{
	DWORD dwGoodsIndex;
	rkPacket >> dwGoodsIndex;

	SP2Packet kPacket( MSTPK_EVENT_SHOP_GOODS_BUY );
	kPacket << GetUserIndex() << dwGoodsIndex;
	g_MainServer.SendMessage( kPacket );
}

void User::OnEventShopState( SP2Packet &rkPacket )
{
	if( !IsDeveloper() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - 개발자가 아닌데 OnEventShopState 신호 보냄!", GetPublicID().c_str() );
		return;
	}

	int iShopState;
	rkPacket >> iShopState;
	SP2Packet kPacket( MSTPK_EVENT_SHOP_STATE );
	kPacket << iShopState;
	g_MainServer.SendMessage( kPacket );
}

void User::OnEventNpcClose( SP2Packet &rkPacket )
{
	if( !IsDeveloper() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - 개발자가 아닌데 OnEventNpcClose 신호 보냄!", GetPublicID().c_str() );
		return;
	}

	int nNpc;
	rkPacket >> nNpc;
	SP2Packet kPacket( MSTPK_EVENT_NPC_CLOSE );
	kPacket << nNpc;
	g_MainServer.SendMessage( kPacket );
}


void User::OnEventShopBuyUserClear( SP2Packet &rkPacket )
{
	if( !IsDeveloper() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - 개발자가 아닌데 OnEventShopState 신호 보냄!", GetPublicID().c_str() );
		return;
	}

	SP2Packet kPacket( MSTPK_EVENT_SHOP_BUY_USER_CLEAR );
	g_MainServer.SendMessage( kPacket );
}

void User::OnCustomItemSkinUniqueIndex( SP2Packet &rkPacket )
{
	// DB 요청
	g_DBClient.OnSelectItemCustomUniqueIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex() );
}

void User::OnCustomCostumeSkinUniqueIndex( SP2Packet &rkPacket )
{
	// DB 요청
	g_DBClient.OnSelectCustomCostumeUniqueIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex() ); //일단 요걸로 그대로 사용하자~
}

void User::PowerUpItemSkinDelete( ioUserExtraItem::EXTRAITEMSLOT& kSlot )
{
	if( kSlot.m_dwMaleCustom == 0 && kSlot.m_dwFemaleCustom == 0 )
		return;

	SP2Packet kPacket( STPK_CUSTOM_ITEM_SKIN_DELETE );
	int iSlotIndex = kSlot.m_iIndex;

	if( iSlotIndex <= 0 )
	{
		PACKET_GUARD_VOID(kPacket.Write(false));
	}
	else
	{
		kSlot.m_dwMaleCustom = 0;
		kSlot.m_dwFemaleCustom = 0;
		m_UserExtraItem.SetExtraItem( kSlot );
		SaveExtraItem();

		char szItemIndex[MAX_PATH]="";
		if( iSlotIndex != 0 )
		{
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", iSlotIndex, 0 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertExtraItem( this, kSlot.m_iItemCode, kSlot.m_iReinforce, 0, 0, 0, kSlot.m_PeriodType, kSlot.m_dwMaleCustom, kSlot.m_dwFemaleCustom, szItemIndex, LogDBClient::ERT_CUSTOM_DEL );

		}
		PACKET_GUARD_VOID( kPacket.Write(true) );
	}
	
	PACKET_GUARD_VOID(kPacket.Write(iSlotIndex));
	PACKET_GUARD_VOID(kPacket.Write((BYTE)SDT_POWERUP));
	SendMessage( kPacket );
}

void User::CustomItemSkinDelete( int iSlotIndex, BYTE byDeleteType )
{
	SP2Packet kPacket( STPK_CUSTOM_ITEM_SKIN_DELETE );

	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	if( m_UserExtraItem.GetExtraItem( iSlotIndex, kSlot ) )
	{
		//
		if( byDeleteType == SDT_ALL )
		{
			kSlot.m_dwMaleCustom = 0;
			kSlot.m_dwFemaleCustom = 0;
		}
		else if( byDeleteType == SDT_MALE )
			kSlot.m_dwMaleCustom = 0;
		else if( byDeleteType == SDT_FEMALE )
			kSlot.m_dwFemaleCustom = 0;

		m_UserExtraItem.SetExtraItem( kSlot );
		SaveExtraItem();

		char szItemIndex[MAX_PATH]="";
		if( iSlotIndex != 0 )
		{
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", iSlotIndex, 0 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertExtraItem( this, kSlot.m_iItemCode, kSlot.m_iReinforce, 0, 0, 0, kSlot.m_PeriodType, kSlot.m_dwMaleCustom, kSlot.m_dwFemaleCustom, szItemIndex, LogDBClient::ERT_CUSTOM_DEL );
		}

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "OnCustomItemSkinDelete OK : %s - %d", GetPublicID().c_str(), iSlotIndex );
		PACKET_GUARD_VOID( kPacket.Write(true) );
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnCustomItemSkinDelete Failed : %s - %d", GetPublicID().c_str(), iSlotIndex );
		PACKET_GUARD_VOID(kPacket.Write(false));
	}

	PACKET_GUARD_VOID(kPacket.Write(iSlotIndex));
	PACKET_GUARD_VOID(kPacket.Write(byDeleteType));
	SendMessage( kPacket );
}

void User::OnCustomItemSkinDelete( SP2Packet &rkPacket )
{
	int iSlotIndex;
	BYTE byDeleteType;
	PACKET_GUARD_VOID( rkPacket.Read(iSlotIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(byDeleteType) );

	CustomItemSkinDelete(iSlotIndex,byDeleteType);
}

void User::OnCustomCostumeSkinDelete( SP2Packet &rkPacket )
{
	int		iSlotIndex		= 0;
	BYTE	byDeleteType	= 0;

	PACKET_GUARD_VOID( rkPacket.Read(iSlotIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(byDeleteType) );
	
	ioUserExtraItem::EXTRAITEMSLOT kSlot;
	Costume* pEquipCostume = m_UserCostume.GetCostume( iSlotIndex );
	if( pEquipCostume && m_UserCostume.DeleteCostumeSkin(pEquipCostume->GetCostumeIndex(),byDeleteType) )
	{
		LOG.PrintTimeAndLog( 0, "[SUCCESS] %s - Delete Costume Skin id : %s, Slot : %d", __FUNCTION__, GetPublicID().c_str(), iSlotIndex );
		SP2Packet kPacket(STPK_CUSTOM_COSTUME_SKIN_DELETE);
		PACKET_GUARD_VOID(kPacket.Write((BOOL) TRUE));
		PACKET_GUARD_VOID(kPacket.Write( iSlotIndex ));
		PACKET_GUARD_VOID(kPacket.Write((BYTE) byDeleteType ));
		SendMessage(kPacket);
		return;
	}
	else
	{
		LOG.PrintTimeAndLog( 0, "[FAIL] %s - Delete Costume Skin id : %s, Slot : %d", __FUNCTION__, GetPublicID().c_str(), iSlotIndex );
		SP2Packet kPacket(STPK_CUSTOM_COSTUME_SKIN_DELETE);
		PACKET_GUARD_VOID(kPacket.Write((BOOL) FALSE));
		PACKET_GUARD_VOID(kPacket.Write((INT)  iSlotIndex ));
		PACKET_GUARD_VOID(kPacket.Write((BYTE) byDeleteType ));
		SendMessage(kPacket);
		return;
	}
}

void User::OnHeadquartersOptionCmd( SP2Packet &rkPacket )
{
	int iCommand;
	rkPacket >> iCommand;
	
	switch( iCommand )
	{
	case HEADQUARTERS_OPTION_LOCK:
		{
			bool bLock;
			rkPacket >> bLock;
			m_UserHeadquartersData.m_sLock = (short)bLock;
			m_UserHeadquartersData.m_bChangeOption = true;

			if( m_pMyRoom )
			{
				m_pMyRoom->OnModeJoinLockUpdate( this, bLock );
			}
		}
		break;
	case HEADQUARTERS_OPTION_DISPLAY_SET:
		{
			int iXPos, iZPos;
			DWORD dwCharIndex;
			rkPacket >> dwCharIndex >> iXPos >> iZPos;

			int i = 0;
			bool bNewSlot = true;
			for(i = 0;i < MAX_DISPLAY_CNT;i++)
			{
				if( m_UserHeadquartersData.m_dwCharacterIndex[i] == dwCharIndex )
				{
					m_UserHeadquartersData.m_iCharacterXPos[i] = iXPos;
					m_UserHeadquartersData.m_iCharacterZPos[i] = iZPos;
					bNewSlot = false;
					break;
				}
			}

			if( bNewSlot )
			{
				for(i = 0;i < MAX_DISPLAY_CNT;i++)
				{
					int iCharArray = GetCharArray( m_UserHeadquartersData.m_dwCharacterIndex[i] );
					if( iCharArray != -1 ) continue;

					m_UserHeadquartersData.m_dwCharacterIndex[i] = dwCharIndex;
					m_UserHeadquartersData.m_iCharacterXPos[i] = iXPos;
					m_UserHeadquartersData.m_iCharacterZPos[i] = iZPos;
					break;
				}
			}
			m_UserHeadquartersData.m_bChangeOption = true;

			if( m_pMyRoom )
			{
				m_pMyRoom->OnModeCharDisplayUpdate( this, dwCharIndex );
			}
		}
		break;
	case HEADQUARTERS_OPTION_DISPLAY_DEL:
		{
			DWORD dwCharIndex;
			rkPacket >> dwCharIndex;

			int i = 0;
			for(i = 0;i < MAX_DISPLAY_CNT;i++)
			{
				if( m_UserHeadquartersData.m_dwCharacterIndex[i] == dwCharIndex )
				{
					m_UserHeadquartersData.m_dwCharacterIndex[i] = 0;
					m_UserHeadquartersData.m_iCharacterXPos[i] = 0;
					m_UserHeadquartersData.m_iCharacterZPos[i] = 0;
					break;
				}
			}			
			m_UserHeadquartersData.m_bChangeOption = true;

			if( m_pMyRoom )
			{
				m_pMyRoom->OnModeCharDisplayUpdate( this, dwCharIndex );
			}
		}
		break;
	}
}

void User::OnHeadquartersCommand( SP2Packet &rkPacket )
{
	if( !m_pMyRoom ) return;
	if( m_pMyRoom->GetModeType() != MT_HEADQUARTERS ) return;

	int iCommand;
	rkPacket >> iCommand;

	switch( iCommand )
	{
	case HEADQUARTERS_CMD_MAXPLAYER_CHANGE:
		{
			int iMaxPlayer;
			rkPacket >> iMaxPlayer;
			m_pMyRoom->SetMaxPlayer( iMaxPlayer );

			SP2Packet kPacket( STPK_HEADQUARTERS_COMMAND );
			kPacket << HEADQUARTERS_CMD_MAXPLAYER_CHANGE << m_pMyRoom->GetMaxPlayer();
			m_pMyRoom->RoomSendPacketTcp( kPacket );
		}
		break;
	case HEADQUARTERS_CMD_KICK_OUT:
		{
			ioHashString szKickOutUser;
			rkPacket >> szKickOutUser;
			m_pMyRoom->RoomKickOut( szKickOutUser );
		}
		break;
	}
}

void User::OnDisconnectAlreadyID( SP2Packet &rkPacket )
{
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - lv1", __FUNCTION__ );
	// 게임서버 종료 처리 중
	if(g_App.IsReserveLogOut())
	{
		SP2Packet kPacket( STPK_DISCONNECT_ALREADY_ID );
		kPacket << DISCONNECT_ALREADY_ID_EXCEPT;
		SendMessage( kPacket );
		return;
	}

	ioHashString szEncLoginKeyAndID, szPrivateIP;
	rkPacket >> szEncLoginKeyAndID >> szPrivateIP;
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - %s", __FUNCTION__, szEncLoginKeyAndID.c_str() );
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( !pLocal )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - pLocal == NULL. %d", __FUNCTION__, (int)ioLocalManager::GetLocalType() );
		SP2Packet kPacket( STPK_DISCONNECT_ALREADY_ID );
		kPacket << DISCONNECT_ALREADY_ID_EXCEPT;
		SendMessage( kPacket );
		return;
	}

	ioHashString sPrivateID;
	char szLoginKey[MAX_PATH]="";

	
	if( pLocal->IsDecryptID() )
	{
		char szDecryptID[DATA_LEN]="";
		if(!pLocal->ParseLoginData( szEncLoginKeyAndID, szLoginKey, sizeof( szLoginKey ), szDecryptID, sizeof( szDecryptID ) ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - ParseLoginData() - false :%s", __FUNCTION__, szPrivateIP.c_str());
			SP2Packet kPacket( STPK_DISCONNECT_ALREADY_ID );
			kPacket << DISCONNECT_ALREADY_ID_EXCEPT;
			SendMessage( kPacket );
			return;
		}

		sPrivateID = szDecryptID;
	}
	
	else
	{
		sPrivateID = szEncLoginKeyAndID;
	}

	if( pLocal->IsPrivateLowerID() )
	{
		sPrivateID.MakeLower();
	}

	if( !pLocal->IsRightID( sPrivateID.c_str() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - Wrong ID :%s", __FUNCTION__, sPrivateID.c_str());
		SP2Packet kPacket( STPK_DISCONNECT_ALREADY_ID );
		kPacket << DISCONNECT_ALREADY_ID_EXCEPT;
		SendMessage( kPacket );
		return;
	}

	//실제 서버에 접속하고 있는 유저인지 확인
	if( !g_UserNodeManager.IsConnectUser( sPrivateID ) )   
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"%s - %s -connect", __FUNCTION__, sPrivateID.c_str() );
		SP2Packet kPacket( STPK_DISCONNECT_ALREADY_ID );
		kPacket << DISCONNECT_ALREADY_ID_EXCEPT;
		SendMessage( kPacket );

		//[HRYOON 중복접속]
		//실제 서버에 접속하고 있지는 않지만 gameserverID 가 0이 아니므로 초기화 시킨다
		g_DBClient.OnUpdateUserLogout( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), sPrivateID );

		return;
	}

	ioHashString sLoginKey = szLoginKey;

	SetIPMapping( szPrivateIP.c_str() );
	SetPrivateID( GetGUID() ); // 이미 중복된 상태이므로 PrivateID에 GUID 설정
	m_dwDBAgentID = Help::GetUserDBAgentID( GetPrivateID() );	

	SAFEDELETE(m_pEncLoginKey);
	m_pEncLoginKey = new ioHashString;
	*m_pEncLoginKey = szLoginKey;

	g_DBClient.OnSelectDisconnectCheck( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), sPrivateID );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "DisconnectAlreadyID[1]-%s-%s-%s-%s-%s", szEncLoginKeyAndID.c_str(), sLoginKey.c_str(), szPrivateIP.c_str(), GetGUID().c_str(), sPrivateID.c_str() );
}

void User::OnPCInfo( SP2Packet &rkPacket )
{
	ioHashString sOS;
	ioHashString sDXVersion;
	ioHashString sCPU;
	int iMemory = 0;
	ioHashString sGPU;
	ioHashString sWebBrowser;
	ioHashString sDesktopWH;
	ioHashString sGameWH;
	bool bFullScreen = false;

	rkPacket >> sOS;
	rkPacket >> sDXVersion;
	rkPacket >> sCPU;
	rkPacket >> iMemory;
	rkPacket >> sGPU;
	rkPacket >> sWebBrowser;
	rkPacket >> sDesktopWH;
	rkPacket >> sGameWH;
	rkPacket >> bFullScreen;

	g_LogDBClient.OnInsertPCInfo( this, sOS, sWebBrowser, sDXVersion, sCPU, sGPU, iMemory, sDesktopWH, sGameWH, bFullScreen );
}

void User::OnCheckBaseValue( SP2Packet &rkPacket )
{
	// 국내는 일단 기능 사용하지 않음.
	return;

	// base char start
	float fDefaultHP, fDefaultSpeed;
	rkPacket >> fDefaultHP >> fDefaultSpeed;

	DWORD dwBlowProtectionTime, dwNoInputDelayTime, dwStartProtectionTime, dwStartProtectionTime2;
	rkPacket >> dwBlowProtectionTime >> dwNoInputDelayTime >> dwStartProtectionTime >> dwStartProtectionTime2;

	float fDefaultRecoveryGauge;
	DWORD dwDefaultRecoveryGaugeTic;
	float fDelayRunGaugeRate, fEtcGaugeRate;
	rkPacket >> fDefaultRecoveryGauge >> dwDefaultRecoveryGaugeTic >> fDelayRunGaugeRate >> fEtcGaugeRate;

	float fDefaultRecover;
	DWORD dwDefaultRecoveryTick;
	rkPacket >> fDefaultRecover >> dwDefaultRecoveryTick;

	bool bCheckBaseCharInfo =  g_ItemInfoMgr.CheckBaseCharInfo( this,
																fDefaultHP, fDefaultSpeed,
																dwBlowProtectionTime, 
																dwNoInputDelayTime,
																dwStartProtectionTime,
																dwStartProtectionTime2,
																fDefaultRecoveryGauge,
																dwDefaultRecoveryGaugeTic,
																fDelayRunGaugeRate,
																fEtcGaugeRate,
																fDefaultRecover,
																dwDefaultRecoveryTick );
	if( !bCheckBaseCharInfo )
	{
		if( m_pMyRoom )
			m_pMyRoom->SetExitRoomByCheckValue( this );

		return;
	}
	// base char end

	// item start
	bool bWeapon;
	rkPacket >> bWeapon;
	if( bWeapon )
	{
		DWORD dwCode;
		rkPacket >> dwCode;

		float fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass;
		rkPacket >> fBaseMaxGauge >> fBaseArmorClass >> fBaseSpeedClass;

		bool bCheckBaseItemInfo =  g_ItemInfoMgr.CheckBaseItemInfo( this, dwCode, fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass );
		if( !bCheckBaseItemInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}

	bool bArmor;
	rkPacket >> bArmor;
	if( bArmor )
	{
		DWORD dwCode;
		rkPacket >> dwCode;

		float fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass;
		rkPacket >> fBaseMaxGauge >> fBaseArmorClass >> fBaseSpeedClass;

		bool bCheckBaseItemInfo =  g_ItemInfoMgr.CheckBaseItemInfo( this, dwCode, fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass );
		if( !bCheckBaseItemInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}

	bool bHelmet;
	rkPacket >> bHelmet;
	if( bHelmet )
	{
		DWORD dwCode;
		rkPacket >> dwCode;

		float fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass;
		rkPacket >> fBaseMaxGauge >> fBaseArmorClass >> fBaseSpeedClass;

		bool bCheckBaseItemInfo =  g_ItemInfoMgr.CheckBaseItemInfo( this, dwCode, fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass );
		if( !bCheckBaseItemInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}

	bool bCloak;
	rkPacket >> bCloak;
	if( bCloak )
	{
		DWORD dwCode;
		rkPacket >> dwCode;

		float fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass;
		rkPacket >> fBaseMaxGauge >> fBaseArmorClass >> fBaseSpeedClass;

		bool bCheckBaseItemInfo =  g_ItemInfoMgr.CheckBaseItemInfo( this, dwCode, fBaseMaxGauge, fBaseArmorClass, fBaseSpeedClass );
		if( !bCheckBaseItemInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}
	// item end

	// skill start
	bool bWeaponSkill;
	rkPacket >> bWeaponSkill;
	if( bWeaponSkill )
	{
		ioHashString szSkillName;
		float fNeedGauge;
		rkPacket >> szSkillName >> fNeedGauge;

		bool bCheckBaseSkillInfo =  g_ItemInfoMgr.CheckBaseSkillInfo( this, szSkillName, fNeedGauge );
		if( !bCheckBaseSkillInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}

	bool bArmorSkill;
	rkPacket >> bArmorSkill;
	if( bArmorSkill )
	{
		ioHashString szSkillName;
		float fNeedGauge;
		rkPacket >> szSkillName >> fNeedGauge;

		bool bCheckBaseSkillInfo =  g_ItemInfoMgr.CheckBaseSkillInfo( this, szSkillName, fNeedGauge );
		if( !bCheckBaseSkillInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}

	bool bHelmetSkill;
	rkPacket >> bHelmetSkill;
	if( bHelmetSkill )
	{
		ioHashString szSkillName;
		float fNeedGauge;
		rkPacket >> szSkillName >> fNeedGauge;

		bool bCheckBaseSkillInfo =  g_ItemInfoMgr.CheckBaseSkillInfo( this, szSkillName, fNeedGauge );
		if( !bCheckBaseSkillInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}

	bool bCloakSkill;
	rkPacket >> bCloakSkill;
	if( bCloakSkill )
	{
		ioHashString szSkillName;
		float fNeedGauge;
		rkPacket >> szSkillName >> fNeedGauge;

		bool bCheckBaseSkillInfo =  g_ItemInfoMgr.CheckBaseSkillInfo( this, szSkillName, fNeedGauge );
		if( !bCheckBaseSkillInfo )
		{
			if( m_pMyRoom )
				m_pMyRoom->SetExitRoomByCheckValue( this );

			return;
		}
	}
	// skill end
}

void User::OnShutdownDate( SP2Packet &rkPacket )
{
	if( GetChannelingType() != CNT_MGAME )
		return;

	int iYear  = 0;
	int iMonth = 0;
	int iDay   = 0;
	int iHour  = 0;
	
	rkPacket >> iYear;
	rkPacket >> iMonth;
	rkPacket >> iDay;
	rkPacket >> iHour;

	DBTIMESTAMP dts;
	dts.year  = iYear;
	dts.month = iMonth;
	dts.day   = iDay;
	dts.hour  = iHour;
	dts.minute= 0; 
	dts.second= 0;

	m_UserSelectShutDown.SetSelectShutDown( 1, dts );

	CTime CurrentTime = CTime::GetCurrentTime();
	if( !m_UserSelectShutDown.IsShutDown( CurrentTime ) )
		return;

	// shutdown
	SP2Packet kPacket( STPK_RESERVE_LOGOUT );
	kPacket << RESERVE_LOGOUT_SELECT_SHUT_DOWN;
	SendMessage( kPacket );
}

void User::OnAlchemicFunc( SP2Packet &rkPacket )
{
	int iFuncType;
	rkPacket >> iFuncType;

	int iResult = ALCHEMIC_SOLDIER_SUCC;

	switch( iFuncType )
	{
	case ALCHEMIC_FUNC_SOLDIER:
		{
			int iCode;
			int iPiece1, iValue1;
			int iPiece2, iValue2;
			int iPiece3, iValue3;
			int iPiece4, iValue4;
			int iAdditive, iAddValue;

			rkPacket >> iCode
					 >> iPiece1 >> iValue1
					 >> iPiece2 >> iValue2
					 >> iPiece3 >> iValue3
					 >> iPiece4 >> iValue4
					 >> iAdditive >> iAddValue;

			iResult = g_AlchemicMgr.AlchemicSoldierFunc( this, iCode,
														 iPiece1, iValue1,
														 iPiece2, iValue2,
														 iPiece3, iValue3,
														 iPiece4, iValue4,
														 iAdditive, iAddValue );
		}
		break;
	case ALCHEMIC_FUNC_ITEM:
		{
			int iCode;
			int iPiece1, iValue1;
			int iPiece2, iValue2;
			int iPiece3, iValue3;
			int iPiece4, iValue4;
			int iAdditive, iAddValue;

			rkPacket >> iCode
					 >> iPiece1 >> iValue1
					 >> iPiece2 >> iValue2
					 >> iPiece3 >> iValue3
					 >> iPiece4 >> iValue4
					 >> iAdditive >> iAddValue;

			iResult = g_AlchemicMgr.AlchemicItemFunc( this, iCode,
													  iPiece1, iValue1,
													  iPiece2, iValue2,
													  iPiece3, iValue3,
													  iPiece4, iValue4,
													  iAdditive, iAddValue );
		}
		break;
	case ALCHEMIC_FUNC_CHANGE:
		{
			int iCode;
			int iPiece1, iValue1;
			int iPiece2, iValue2;
			int iPiece3, iValue3;
			int iPiece4, iValue4;

			rkPacket >> iCode
					 >> iPiece1 >> iValue1
					 >> iPiece2 >> iValue2
					 >> iPiece3 >> iValue3
					 >> iPiece4 >> iValue4;

			iResult = g_AlchemicMgr.AlchemicChangeFunc( this, iCode,
														iPiece1, iValue1,
														iPiece2, iValue2,
														iPiece3, iValue3,
														iPiece4, iValue4 );
		}
		break;
	case ALCHEMIC_FUNC_EXCHANGE:
		{
			int iCode;
			int iPiece1, iValue1;
			int iPiece2, iValue2;
			int iAdditive, iAddValue;

			rkPacket >> iCode
					 >> iPiece1 >> iValue1
					 >> iPiece2 >> iValue2
					 >> iAdditive >> iAddValue;

			iResult = g_AlchemicMgr.AlchemicExchangeFunc( this, iCode,
														  iPiece1, iValue1,
														  iPiece2, iValue2,
														  iAdditive, iAddValue );
		}
		break;
	case ALCHEMIC_FUNC_SELL:
		{
			int iCode;
			int iPiece1, iValue1;
			int iPiece2, iValue2;
			int iPiece3, iValue3;
			int iPiece4, iValue4;

			rkPacket >> iCode
					 >> iPiece1 >> iValue1
					 >> iPiece2 >> iValue2
					 >> iPiece3 >> iValue3
					 >> iPiece4 >> iValue4;

			iResult = g_AlchemicMgr.AlchemicSellFunc( this, iCode,
													  iPiece1, iValue1,
													  iPiece2, iValue2,
													  iPiece3, iValue3,
													  iPiece4, iValue4 );
		}
		break;
	case ALCHEMIC_FUNC_NEW_SOLDIER:
		{
			int iCode;
			int iClassType;
			int iPiece1, iValue1;
			int iAdditive, iAddValue;

			rkPacket >> iCode
					 >> iClassType
					 >> iPiece1 >> iValue1
					 >> iAdditive >> iAddValue;

			iResult = g_AlchemicMgr.NewAlchemicSoldierFunc( this, iCode,
															iClassType,											
															iPiece1, iValue1,
															iAdditive, iAddValue );
		}
		break;
	case ALCHEMIC_FUNC_NEW_ITEM:
		{
			int iCode;
			int iItemCode;
			int iPiece1, iValue1;
			int iAdditive, iAddValue;

			rkPacket >> iCode
					 >> iItemCode
					 >> iPiece1 >> iValue1
					 >> iAdditive >> iAddValue;

			iResult = g_AlchemicMgr.NewAlchemicItemFunc( this, iCode,
														 iItemCode,
														 iPiece1, iValue1,
														 iAdditive, iAddValue );
		}
		break;
	}

	if( iResult == ART_SUCCESS || iResult == ART_FAIL )
	{
		// 성공, 실패는 각 함수 내부에서 전송처리 이루어짐
		return;
	}

	// 예외적 실패에 대한 정보 전송
	SP2Packet kReturn( STPK_ALCHEMIC_RESULT );
	kReturn << ALCHEMIC_EXCEPTION_FAIL;
	kReturn << iResult;
	SendMessage( kReturn );
	
	return;
}

void User::SetAllCharAllDecoration()
{
	for( int i=0 ; i<GetCharCount() ; i++ )
	{
		ioCharacter *rkChar = m_CharList[i];
		if( rkChar )
		{
			rkChar->SetCharAllDecoration( m_Inventory );
		}
	}

	return;
}

void User::AddPresentMemory( const ioHashString &szSendName, short iPresentType, int iPresentValue1, int iPresentValue2, int iPresentValue3, 
							 int iPresentValue4, short iPresentMent, CTime &rkLimitTime, short iPresentState )
{
	m_UserPresent.AddPresentMemory( szSendName, iPresentType, iPresentValue1, iPresentValue2, iPresentValue3, iPresentValue4, 
									iPresentMent, rkLimitTime, iPresentState );
}

void User::SendPresentMemory()
{
	m_UserPresent.SendPresentMemory();
}

void User::LogoutMemoryPresentInsert()
{
	m_UserPresent.LogoutMemoryPresentInsert();
}

void User::OnGetMileage( SP2Packet &rkPacket )
{
	SP2Packet kBillingPacket( BSTPK_GET_MILEAGE );

	PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		SP2Packet kReturn( STPK_GET_MILEAGE );

		PACKET_GUARD_VOID( kReturn.Write(GET_MILEAGE_EXCEPTION) );

		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %d : %s", __FUNCTION__,  GetUserIndex(), GetPublicID().c_str() );
	}
}

bool User::SendBillingAddMileage( int iPresentType, int iPresentValue1, int iPresentValue2, int iResellPeso, bool bPresent )
{
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( !pLocal )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pLocal == NULL.", __FUNCTION__ );
		return false;
	}

	if( !pLocal->IsMileage() )
		return false;

	if( iResellPeso <= 0 )
		return false;

	SP2Packet kBillingPacket( BSTPK_ADD_MILEAGE );

	PACKET_GUARD_bool( kBillingPacket.Write(GetUserIndex()) );
	PACKET_GUARD_bool( kBillingPacket.Write(GetPrivateID()) );
	PACKET_GUARD_bool( kBillingPacket.Write(GetPublicID()) );
	PACKET_GUARD_bool( kBillingPacket.Write(GetPublicIP()) );
	PACKET_GUARD_bool( kBillingPacket.Write(iPresentType) );
	PACKET_GUARD_bool( kBillingPacket.Write(iPresentValue1) );
	PACKET_GUARD_bool( kBillingPacket.Write(iPresentValue2) );
	PACKET_GUARD_bool( kBillingPacket.Write(iResellPeso) );
	PACKET_GUARD_bool( kBillingPacket.Write(bPresent) );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail : %s:%d:%s:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetPrivateID().c_str(), iResellPeso, iPresentType, iPresentValue1, iPresentValue2, (int)bPresent );
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Success : %s:%d:%s:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetPrivateID().c_str(), iResellPeso, iPresentType, iPresentValue1, iPresentValue2, (int)bPresent );
	}

	return true;
}

void User::SendBilligLogOut()
{
	if( !IsSessionDestroySave() )
		return;

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( !pLocal )
		return;

	if( !pLocal->IsIPBonus() )
		return;

	if( GetPrivateID().IsEmpty() )
		return;

	if( strcmp( GetPublicIP(), "" ) == 0  )
		return;

	if( !m_bSendCheckPCRoom )
		return;

	SP2Packet kBillingPacket( BSTPK_IPBONUS_OUT );

	PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicIP()) );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send Fail : %s:%s", __FUNCTION__, GetPrivateID().c_str(), GetPublicIP() );
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Send : %s:%s", __FUNCTION__, GetPrivateID().c_str(), GetPublicIP() );
	}
}

void User::SavePlayTimeLog()
{
	if( !m_bSessionDestroySave )
		return;
	
	if( m_cLoginTime == 0 )
		return;	

#ifdef SRC_LATIN
	//jal 로그아웃 되면 'G' 메시지를 apex item server 에 보낸다. InitData 하기 전에 해야함.
	// 로그아웃 용 G 메세지 전송 구문. OnSessionDestroy() 에 있던 구문을 이쪽으로 옮김. 
	// OnSessionDestroy() 는 서버 이동 간에도 계속 타는 함수라 실질적 로그아웃용으로 사용하기 위해 옮김.	JCLEE 130313
	LOG.PrintTimeAndLog( 0, "Apex G Msg Send, UserLogout" );
	g_ioApex.NoticeApexProxy_UserLogout(GetUserIndex(), GetPrivateID());
#endif


	//라틴 일 경우 로그아웃 패킷 보냄
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN )
	{
		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
		{
			pLocal->SendLogoutData( this );
			
		}
	}
	////유럽
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_EU )
	{
		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
		{
			pLocal->DecreaseCountryCCU( GetCountry() );	//삭제
		}
	}
	InsertLogoutRecord();
}


ioUserSelectShutDown &User::GetUserSelectShutDown()
{
	return m_UserSelectShutDown;
}

bool User::GetPeerIP(char* remoteIP, const int size, int& remotePort)
{
	SOCKADDR_IN sockAddr;
	int len = sizeof(SOCKADDR_IN);

	int result = getpeername( GetSocketHandle(), (SOCKADDR *)&sockAddr, &len );
	if( SOCKET_ERROR != result )
	{
		sprintf_s(remoteIP, size, "%s", inet_ntoa(sockAddr.sin_addr) );
		remotePort = ntohs(sockAddr.sin_port);
		return true;
	}
	return false;
}

void User::EventProcessTime()
{
	m_EventUserMgr.ProcessTime(this);
}

void User::OnCharDisassemble( SP2Packet &packet )
{
	DWORD dwCharIndex;
	packet >> dwCharIndex;

	int i = 0;
	int iCharArray = -1;
	for(i = 0;i < GetCharCount();i++)
	{
		if( m_CharList[i]->GetCharIndex() == dwCharIndex )
		{
			iCharArray = i;
			break;
		}
	}
	
	int iResult = DELETE_CHAR_OK;
	int iGainCode = 0;
	int iGainCnt = 0;
	int iResellLimitDate = 0;
	bool bSendPresent = false;
	int iSoulStoneCnt = 0;

	if( iCharArray == -1 )
	{
		iResult = DELETE_EXCEPTION;

		SP2Packet kPacket( STPK_SOLDIER_DISASSEMBLE );
		kPacket << iResult << dwCharIndex << iGainCode << iGainCnt;
		kPacket << bSendPresent;
		SendMessage( kPacket );
		return;
	}

	if( m_pMyRoom && iCharArray == m_select_char )
		iResult = DELETE_SELECT_CHAR;

	if( iResult == DELETE_CHAR_OK )
	{
		int iClassType = 0;

		if( m_CharList[iCharArray]->HasExerciseStyle( EXERCISE_NONE ) )
		{
			const CHARACTER &rkCharInfo = m_CharList[iCharArray]->GetCharInfo();

			/*if( GetMyRoom() )
			{*/
			Room* pMyRoom	= GetMyRoom();
			int iSoldierType	= GetSpecialSoldierType(m_CharList[iCharArray]->GetClassType());

			if( iSoldierType != SST_END )
			{
				if( m_CharList[iCharArray]->IsMortmain() )
				{
					if( SST_RSOLDIER == iSoldierType )
					{
						//해당 방 유저에게 R용병 분해 했다구 통지.
						SP2Packet kPacket(STPK_RSOLDIER_STATUS);
						PACKET_GUARD_VOID( kPacket.Write(RSOLDIER_DISASSEMBLE) );
						PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

						if( pMyRoom )
							pMyRoom->RoomSendPacketTcp(kPacket);
						else
							SendMessage(kPacket);
					}
					else
					{
						SP2Packet kPacket(STPK_SOLDIER_SET_STATUS);
						PACKET_GUARD_VOID( kPacket.Write(RSOLDIER_DISASSEMBLE) );
						PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
						PACKET_GUARD_VOID( kPacket.Write(m_CharList[iCharArray]->GetClassType()) );

						if( pMyRoom )
							pMyRoom->RoomSendPacketTcp(kPacket);
						else
							SendMessage(kPacket);
					}
				}
			}
			/*}*/

			// 용병 남은시간 사전체크
			int iGapLimitTime = m_CharList[iCharArray]->GetGapLimitTime();
			int iCheckLimitTime = (rkCharInfo.m_iLimitSecond-iGapLimitTime) / 60 / 60;
			if( !m_CharList[iCharArray]->IsMortmain() && iCheckLimitTime < 1 )
			{
				iResult = DELETE_LIMIT_TIME_FAIL;

				SP2Packet kPacket( STPK_SOLDIER_DISASSEMBLE );
				kPacket << iResult << dwCharIndex << iGainCode << iGainCnt;
				kPacket << bSendPresent;
				SendMessage( kPacket );
				return;
			}

			// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
			if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
			{
				m_CharList[iCharArray]->UpdateLimitTimer();
			}
			
			iResellLimitDate = rkCharInfo.m_iLimitSecond / 60 / 60;

			iClassType = rkCharInfo.m_class_type;

			iGainCode = g_AlchemicMgr.GetDisassembleCode( ADT_SOLDIER, rkCharInfo.m_class_type );

			if( m_CharList[iCharArray]->IsMortmain() )
			{
				iGainCnt = g_AlchemicMgr.GetDisassembleCnt( ADT_SOLDIER, true, 0, 0 );
				iSoulStoneCnt = g_AlchemicMgr.GetSouleStoneGainCnt( iClassType );
			}
			else
				iGainCnt = g_AlchemicMgr.GetDisassembleCnt( ADT_SOLDIER, false, iResellLimitDate, 0 );

			char szItemIndex[MAX_PATH]="";
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", m_CharList[iCharArray]->GetCharIndex() );
			g_LogDBClient.OnInsertChar( this, rkCharInfo.m_class_type, rkCharInfo.m_iLimitSecond, 0, szItemIndex, LogDBClient::CT_DISASSEMBLE ); // 페소는 혼동되지 않게하기 위해서 0으로 보낸다.
		}

		_OnCharDelete( iCharArray );

		if( m_select_char > iCharArray )
			m_select_char = max( 0, m_select_char - 1 );
		else if( m_select_char == iCharArray )
		{
			m_select_char = 0;
			for(i = 0;i < GetCharCount();i++)
			{
				if( m_CharList[i]->IsActive() )
				{
					m_select_char = i;
					break;
				}
			}
		}

		int iCheckType = 0;
		int iCurCount = m_AlchemicInventory.GetAlchemicItemCnt( iGainCode );
		if( iCurCount > 0 )		// 기존에 존재하던 것, 최대갯수 체크 필요
		{
			int iTotal = iCurCount + iGainCnt;
			if( iTotal > ioAlchemicInventory::MAX_SLOT_CNT )	// 받으면 최대갯수 초과하므로 받기 실패
				iCheckType = PRESENT_RECV_MAX_COUNT;
		}
		else					// 기존에 없던것, 빈칸 체크 필요
		{
			if( !m_AlchemicInventory.CheckEmptySlot() )			// 빈칸 없으므로 받기 실패
				iCheckType = PRESENT_RECV_MAX_SLOT;
		}

		switch( iCheckType )
		{
		case PRESENT_RECV_MAX_COUNT:
		case PRESENT_RECV_MAX_SLOT:
			g_PresentHelper.SendPresentByAlchemicItem( this, iGainCode, iGainCnt );
			bSendPresent = true;
			break;
		}

		if( !bSendPresent )
		{
			if( iGainCode > 0 && iGainCnt > 0 )
				m_AlchemicInventory.GainAlchemicItem( iGainCode, iGainCnt );
		}

		if( iSoulStoneCnt > 0 )
		{
			m_UserEtcItem.GainSpendTypeEtcItem(ioEtcItem::EIT_ETC_SOUL_STONE,iSoulStoneCnt);
			g_LogDBClient.OnInsertDisassemble( this, LogDBClient::DST_SOLDIER, iClassType, ioEtcItem::EIT_ETC_SOUL_STONE, iSoulStoneCnt );
		}
		// 분해로그
		g_LogDBClient.OnInsertDisassemble( this, LogDBClient::DST_SOLDIER, iClassType, iGainCode, iGainCnt );
	}


	SP2Packet kPacket( STPK_SOLDIER_DISASSEMBLE );
	PACKET_GUARD_VOID( kPacket.Write(iResult) );
	PACKET_GUARD_VOID( kPacket.Write(dwCharIndex) );
	PACKET_GUARD_VOID( kPacket.Write(iGainCode) );
	PACKET_GUARD_VOID( kPacket.Write(iGainCnt) );
	PACKET_GUARD_VOID( kPacket.Write(bSendPresent) );
	PACKET_GUARD_VOID( kPacket.Write(ioEtcItem::EIT_ETC_SOUL_STONE) );				//소울스톤 코드
	PACKET_GUARD_VOID( kPacket.Write(iSoulStoneCnt) );								//획득 갯수
	
	SendMessage( kPacket );
}

bool User::OnEtcItemPreSetPackage( int iClassType, int iLimitTime, ITEMSLOTVec vItemSlot, DWORD dwEtcItemType, bool bPresent )
{
	SP2Packet kReturn( STPK_ETCITEM_USE );

	// 이미 영구 용병이 있는지 확인
	int iExtendCharArray = -1;
	int i = 0;
	for(i = 0;i < GetCharCount();i++)
	{
		const CHARACTER &rkCharInfo = m_CharList[i]->GetCharInfo();
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		
		if( rkCharInfo.m_class_type == iClassType )
		{
			if( rkCharInfo.m_ePeriodType == CPT_MORTMAIN )       // 영구 용병
			{
				kReturn << ETCITEM_USE_ALREADY_CHAR;
				SendMessage( kReturn );
				return false;
			}
			iExtendCharArray = i;
			break;
		}
	}

	// check active
	DWORD dwSetItemCode = iClassType + SET_ITEM_CODE;
	const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
	if( !pSetInfo )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s %s %d [%d] pSetInfo == NULL [%d]", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iClassType, dwEtcItemType );
		return false;
	}

	// 동일한 용병을 DB에서 가져 오는 중인지 확인
	for(i = 0;i < (int)m_vLevelUpAndPresentCreateClass.size();i++)
	{
		if( (int)m_vLevelUpAndPresentCreateClass[i] == iClassType )
		{
			kReturn << ETCITEM_USE_CHAR_BEGINNING;
			SendMessage( kReturn );
			return false;
		}
	}
	
	if( iLimitTime > 0 && iExtendCharArray != -1 )	// 용병시간연장
	{
		ioCharacter *pExtendChar = m_CharList[iExtendCharArray];
		const CHARACTER &rkCharInfo = pExtendChar->GetCharInfo();
		// 시간 증가
		// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->UpdateLimitTimer();
		}	
		// 플레이 연장
		if(pExtendChar->GetCharInfo().m_ePeriodType == CPT_DATE)
			pExtendChar->SetCharLimitExtendDate( iLimitTime );
		else
		pExtendChar->SetCharLimitExtend( iLimitTime );
		// 플레이중이면 연장한 시간부터 세팅한다. 
		pExtendChar->SetActive( true );
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->StartLimitTimer( m_pMyRoom->GetCharLimitCheckTime() );
		}		
			
		SP2Packet kPacket( STPK_CHAR_EXTEND );
		kPacket << CHAR_EXTEND_OK << GetMoney() << GetCash() << GetChannelingCash() << iExtendCharArray << 0;
		kPacket << pExtendChar->IsActive() << pExtendChar->GetCharLimitDate() << pExtendChar->GetLimitCheckSecond();
		SendMessage( kPacket );

		// Decoration 
		int iDecoKeepPeso = _OnEtcItemPreSetDecoInsert( rkCharInfo, vItemSlot, dwEtcItemType );
		if( iDecoKeepPeso > 0 )
		{
			AddMoney( iDecoKeepPeso );
			g_LogDBClient.OnInsertPeso( this, iDecoKeepPeso, LogDBClient::PT_PACKAGE_DECO );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_PACKAGE_DECO, PRESENT_DECORATION, dwEtcItemType, iDecoKeepPeso, NULL);
		}

		// 캐릭터에 모든 치장 적용
		pExtendChar->SetCharAllDecoration( m_Inventory );

		// 변경된 정보 저장
		SaveCharacter();  
		SaveUserData();

		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", pExtendChar->GetCharIndex() );
		g_LogDBClient.OnInsertChar( this, iClassType, iLimitTime, 0, szItemIndex, LogDBClient::CT_PRESENT );

		// 권한 아이템 삭제
		if( !bPresent )
			m_UserEtcItem.DeleteEtcItem( dwEtcItemType, LogDBClient::ET_DEL );

		//
		kReturn << ETCITEM_USE_OK;
		kReturn << dwEtcItemType;
		kReturn << (CHARACTER)pExtendChar->GetCharInfo() << iDecoKeepPeso << GetMoney();
		kReturn << iLimitTime;
		SendMessage( kReturn );

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharDecoUpdate( this, pExtendChar );
		}
	}
	else if( iLimitTime == 0 && iExtendCharArray != -1 )        // 시간제 용병을 영구 용병으로 변경
	{
		ioCharacter *pExtendChar = m_CharList[iExtendCharArray];
		
		const CHARACTER &rkCharInfo = pExtendChar->GetCharInfo();	
		// 플레이중이면 현재까지 플레이한 시간만큼 깍는다.
		if( m_pMyRoom && m_pMyRoom->IsCharLimitCheck( this ) )
		{
			pExtendChar->UpdateLimitTimer();
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemPreSetPackage Change Mortmain - UpdateLimitTimer %s - %d : %d", GetPublicID().c_str(), pExtendChar->GetCharIndex(), m_pMyRoom->GetCharLimitCheckTime() );
		}	

		int iResellLimitDate = pExtendChar->GetCharLimitDate();

		bool bResell = true;

		if(ioLocalManager::GetLocalType() == ioLocalManager::LCT_LATIN)
		{
			CTime cCharTime = Help::ConvertNumberToCTime(iResellLimitDate);
			CTime kCurTime = CTime::GetCurrentTime();

			if(kCurTime < cCharTime)
			{
				CTimeSpan cRemainTime = cCharTime - kCurTime;
				iResellLimitDate = cRemainTime.GetTotalMinutes();
			}
			else
			{
				bResell = false;
				iResellLimitDate = 1;
			}
		}

		int iResellPeso      = g_ItemPriceMgr.GetTimeCharResellPeso( rkCharInfo.m_class_type, iResellLimitDate  );

		if(!bResell)
			iResellPeso = 0;

		if( iResellPeso > 0 )
		{
			AddMoney( iResellPeso );
			g_LogDBClient.OnInsertPeso( this, iResellPeso, LogDBClient::PT_DEL_CHAR );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_DEL_CHAR, PRESENT_SOLDIER, rkCharInfo.m_class_type, iResellPeso, NULL);
		}

		pExtendChar->SetPeriodType( CPT_MORTMAIN );
		pExtendChar->SetCharLimitDate( 0 );
		pExtendChar->SetActive( true );

		{
			SP2Packet kPacket( STPK_CHAR_EXTEND );
			kPacket << CHAR_EXTEND_OK << GetMoney() << GetCash() << GetChannelingCash() << iExtendCharArray << 0;
			kPacket << pExtendChar->IsActive() << pExtendChar->GetCharLimitDate() << pExtendChar->GetLimitCheckSecond();
			SendMessage( kPacket );	
		}		

		// Decoration 
		int iDecoKeepPeso = _OnEtcItemPreSetDecoInsert( rkCharInfo, vItemSlot, dwEtcItemType );
		if( iDecoKeepPeso > 0 )
		{
			AddMoney( iDecoKeepPeso );
			g_LogDBClient.OnInsertPeso( this, iDecoKeepPeso, LogDBClient::PT_PACKAGE_DECO );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_PACKAGE_DECO, PRESENT_DECORATION, dwEtcItemType, iDecoKeepPeso, NULL);
		}

		// 캐릭터에 모든 치장 적용
		pExtendChar->SetCharAllDecoration( m_Inventory );

		// 변경된 정보 저장
		SaveCharacter();  
		SaveUserData();

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemPreSetPackage Change Mortmain %s - %d + %d = %I64d", GetPublicID().c_str(), iResellPeso, iDecoKeepPeso, GetMoney() );
		char szItemIndex[MAX_PATH]="";
		StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u", pExtendChar->GetCharIndex() );
		g_LogDBClient.OnInsertChar( this, rkCharInfo.m_class_type, pExtendChar->GetCharLimitDate(), 0, szItemIndex, LogDBClient::CT_PRESENT );

		// 권한 아이템 삭제
		if( !bPresent )
			m_UserEtcItem.DeleteEtcItem( dwEtcItemType, LogDBClient::ET_DEL );

		//
		kReturn << ETCITEM_USE_OK;
		kReturn << dwEtcItemType;
		kReturn << (CHARACTER)pExtendChar->GetCharInfo() << iResellPeso + iDecoKeepPeso << GetMoney();
		kReturn << iLimitTime;
		SendMessage( kReturn );

		if( m_pMyRoom )
		{
			m_pMyRoom->OnModeCharDecoUpdate( this, pExtendChar );
		}
	}
	else             // 용병 생성
	{
		if( IsClassTypeExerciseStyle( iClassType, EXERCISE_RENTAL ) == false ) 
		{
			if( ( (int)m_vLevelUpAndPresentCreateClass.size() + GetCharCount() ) >= m_iCurMaxCharSlot )
			{
				kReturn << ETCITEM_USE_CHAR_SLOT_FULL;
				SendMessage( kReturn );
				return false;
			}
		}

		// 신규 용병 추가.
		CHARACTER kCharInfo;
		kCharInfo.m_class_type   = iClassType;
		kCharInfo.m_iLimitSecond = iLimitTime;
		if( kCharInfo.m_iLimitSecond == 0 )       //영구 용병
			kCharInfo.m_ePeriodType  = CPT_MORTMAIN;

		// Decoration 
		int iDecoKeepPeso = _OnEtcItemPreSetDecoInsert( kCharInfo, vItemSlot, dwEtcItemType );
		if( iDecoKeepPeso > 0 )
		{
			AddMoney( iDecoKeepPeso );
			g_LogDBClient.OnInsertPeso( this, iDecoKeepPeso, LogDBClient::PT_PACKAGE_DECO );
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_PACKAGE_DECO, PRESENT_DECORATION, dwEtcItemType, iDecoKeepPeso, NULL);
		}
		
		// 캐릭터에 모든 치장 적용
		m_Inventory.GetEquipItemCode( kCharInfo );

		// 변경된 정보 저장
		SaveUserData();

		//캐릭터 생성.
		m_iCreateCharCount++;		
		g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );
		g_DBClient.OnSelectCharIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex(), CREATE_CHAR_OK_PACKAGE, 1, LogDBClient::CT_PACKAGE );
		m_vLevelUpAndPresentCreateClass.push_back( iClassType );

		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnEtcItemSoldierPackage Create %s - %d = %I64d", GetPublicID().c_str(), iDecoKeepPeso, GetMoney() );
		// 권한 아이템 삭제
		if( !bPresent )
			m_UserEtcItem.DeleteEtcItem( dwEtcItemType, LogDBClient::ET_DEL );

		//
		kReturn << ETCITEM_USE_OK;
		kReturn << dwEtcItemType;
		kReturn << kCharInfo << iDecoKeepPeso << GetMoney();
		kReturn << iLimitTime;
		SendMessage( kReturn );
	}

	return true;
}

int User::_OnEtcItemPreSetDecoInsert( CHARACTER kCharInfo, ITEMSLOTVec vItemSlot, DWORD dwEtcItemType )
{
	bool bAddWomman = false;
	int iSelectDeco = vItemSlot.size();
	for( int i=0; i < iSelectDeco; ++i )
	{
		ITEMSLOT kSlot = vItemSlot[i];

		int iDecoType = kSlot.m_item_type%1000;
		if( iDecoType == UID_KINDRED && kSlot.m_item_code == RDT_HUMAN_WOMAN )
			bAddWomman = true;
	}

	int iDecoTypeList[5]={ UID_HAIR, UID_HAIR_COLOR, UID_FACE, UID_SKIN_COLOR, UID_UNDERWEAR };
	for( int i=0; i < 5; ++i )
	{
		ITEMSLOT kSlot;
		kSlot.m_item_type = (kCharInfo.m_class_type * 100000) + (RDT_HUMAN_MAN * 1000) + iDecoTypeList[i];
		kSlot.m_item_code = g_DecorationPrice.GetDefaultDecoCode( RDT_HUMAN_MAN, iDecoTypeList[i], GetPrivateID().GetHashCode() + kCharInfo.m_class_type + iDecoTypeList[i], kCharInfo.m_class_type );

		if( !m_Inventory.IsSlotItem( kSlot ) )
		{
			DWORD dwIndex = 0;
			int   iArray  = 0;
			m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_DEFAULT, dwIndex, iArray );
			if( dwIndex != 0 && dwIndex != ioInventory::NEW_INDEX )
			{
				char szItemIndex[MAX_PATH]="";
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, 0, szItemIndex, LogDBClient::DT_DEFAULT );
			}

			m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code );
		}

		// 유저가 여성을 구매한다면 여성 기본 치장도 지급한다.
		if( !bAddWomman ) continue;

		kSlot.m_item_type = (kCharInfo.m_class_type * 100000) + (RDT_HUMAN_WOMAN * 1000) + iDecoTypeList[i];
		kSlot.m_item_code = g_DecorationPrice.GetDefaultDecoCode( RDT_HUMAN_WOMAN, iDecoTypeList[i], GetPrivateID().GetHashCode() + kCharInfo.m_class_type + iDecoTypeList[i], kCharInfo.m_class_type );

		if( !m_Inventory.IsSlotItem( kSlot ) )
		{
			DWORD dwIndex = 0;
			int   iArray  = 0;
			m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_DEFAULT, dwIndex, iArray );
			if( dwIndex != 0 && dwIndex != ioInventory::NEW_INDEX )
			{
				char szItemIndex[MAX_PATH]="";
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, 0, szItemIndex, LogDBClient::DT_DEFAULT );
			}

			m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code );
		}
	}

	int iReturnPeso = 0;	
	{
		// 선택 치장 적용
		for( int i = 0; i < iSelectDeco ; i++ )
		{
			ITEMSLOT kSlot = vItemSlot[i];

			int iDecoType = kSlot.m_item_type%1000;
			if( !m_Inventory.IsSlotItem( kSlot ) )                // IsSlotItem 내부에서 인간 남자는 보유로 판단한다.
			{
				DWORD dwIndex = 0;
				int   iArray  = 0;
				m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_PACKAGE, dwIndex, iArray );
				if( dwIndex != 0 && dwIndex != ioInventory::NEW_INDEX )
				{
					char szItemIndex[MAX_PATH]="";
					StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArray+1 ); // db field는 1부터 이므로 +1
					g_LogDBClient.OnInsertDeco( this, kSlot.m_item_type, kSlot.m_item_code, 0, szItemIndex, LogDBClient::DT_PACKAGE );
				}

				m_UserGrowthLevel.AddCharGrowthPointByDecoWoman( kSlot.m_item_type, kSlot.m_item_code );

				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnEtcItemPreSetDecoInsert 선택 치장 추가 %s - %d : %d", GetPublicID().c_str(), kSlot.m_item_type, kSlot.m_item_code );
			}
			else 
			{
				// 보유중인 치장이라면 페소로 반환
				int iResellPeso = g_DecorationPrice.GetDecoPackageKeepPeso( kSlot.m_item_type );
				iReturnPeso += iResellPeso;
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::_OnEtcItemPreSetDecoInsert 보유 치장 보상 %s - %d : %d : %d", GetPublicID().c_str(), kSlot.m_item_type, kSlot.m_item_code, iResellPeso );
			}

			// 치장 착용
			int iEquipItemCode = m_Inventory.GetEquipItemCode( kSlot.m_item_type );
			if( iEquipItemCode != kSlot.m_item_code )
			{
				m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code );
			}
		}
	}

	SaveInventory();
	return iReturnPeso;
}

//
void User::OnTournamentRegularRequest( SP2Packet &rkPacket )
{
	SP2Packet kMainPacket( MSTPK_TOURNAMENT_REGULAR_INFO );
	PACKET_GUARD_VOID( kMainPacket.Write( GetUserIndex() ) );
	g_MainServer.SendMessage( kMainPacket );
}

void User::OnTournamentMainInfo( SP2Packet &rkPacket )
{
	DWORD dwIndex;
	rkPacket >> dwIndex;

	//
	SP2Packet kPacket( MSTPK_TOURNAMENT_MAIN_INFO );
	kPacket << GetUserIndex() << dwIndex;
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentListRequest( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_LIST_REQUEST );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentTeamCreate( SP2Packet &rkPacket )
{
	BYTE  MaxPlayer			= 0;
	DWORD dwTourIndex		= 0;
	ioHashString kTeamName;

	PACKET_GUARD_VOID( rkPacket.Read(dwTourIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(kTeamName) );
	PACKET_GUARD_VOID( rkPacket.Read(MaxPlayer) );

	// 해당 아이템을 가지고 있으면 팀 생성 불가. - 임시 유영재
	if( m_UserEtcItem.HaveAThisItem(1004067) )
	{
		//가입 불가능한 유저.
		SP2Packet kPacket(STPK_TOURNAMENT_TEAM_CREATE);
		PACKET_GUARD_VOID( kPacket.Write(TOURNAMENT_TEAM_CREATE_FAILED) );
		SendMessage(kPacket);
		return;
	}

	// 선물함에서도 검색.
	if( m_UserPresent.HaveAThisItem(PRESENT_ETC_ITEM, 1004067) )
	{
		SP2Packet kPacket(STPK_TOURNAMENT_TEAM_CREATE);
		PACKET_GUARD_VOID( kPacket.Write(TOURNAMENT_TEAM_CREATE_FAILED) );
		SendMessage(kPacket);
		return;
	}

	// 가입 대기 팀 리스트 전부 삭제
	g_DBClient.OnDeleteTournamentTeamAppList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIndex );

	// 팀 생성
	BYTE cCampType = CAMP_NONE;
	if( g_TournamentManager.IsRegularTournament( dwTourIndex ) )
		cCampType = (BYTE)GetUserCampPos();
	g_DBClient.OnInsertTournamentTeamCreate( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIndex, kTeamName, MaxPlayer, GetLadderPoint(), cCampType );
}

void User::OnTournamentTeamInfo( SP2Packet &rkPacket )
{
	DWORD dwTourIndex, dwTeamIndex;
	rkPacket >> dwTourIndex >> dwTeamIndex;

	SP2Packet kPacket( MSTPK_TOURNAMENT_TEAM_INFO );
	kPacket << GetUserIndex() << dwTourIndex << dwTeamIndex;
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentTeamUserList( SP2Packet &rkPacket )
{
	bool bEntryMemberCall;
	DWORD dwTourIndex, dwTeamIndex;
	rkPacket >> dwTourIndex >> dwTeamIndex >> bEntryMemberCall;
	g_DBClient.OnSelectTournamentTeamMember( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetUserIndex(), dwTeamIndex );

	if( bEntryMemberCall )
	{
		g_DBClient.OnSelectTournamentTeamAppList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIndex, dwTeamIndex );
	}
}

void User::OnTournamentTeamInvitation( SP2Packet &rkPacket )
{
	ioHashString kTargetName;
	rkPacket >> kTargetName;

	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kTargetName );
	if( pUserParent )
	{
		SP2Packet kPacket( STPK_TOURNAMENT_TEAM_INVITED );
		kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
		pUserParent->RelayPacket( kPacket );
	}
}

void User::OnTournamentTeamEntryDelayMember( SP2Packet &rkPacket )
{
	DWORD dwTourIndex, dwTeamIndex;
	rkPacket >> dwTourIndex >> dwTeamIndex;

	g_DBClient.OnSelectTournamentTeamAppList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIndex, dwTeamIndex );
}

void User::OnTournamentTeamEntryApp( SP2Packet &rkPacket )
{
	DWORD dwTourIndex, dwTeamIndex, dwMasterIndex;

	rkPacket >> dwTourIndex >> dwTeamIndex >> dwMasterIndex;

	int iResult = TOURNAMENT_TEAM_ENTRY_APP_OK;
	
	if( GetEntryType() == ET_TERMINATION )
	{
		iResult = TOURNAMENT_TEAM_ENTRY_APP_FAILED;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send : %s: TOURNAMENT_TEAM_ENTRY_APP_FAILED", __FUNCTION__, GetPublicID().c_str() );
	}
	else if( m_UserTournament.IsTourTeam( dwTourIndex ) )
	{
		iResult = TOURNAMENT_TEAM_ENTRY_APP_ALREADY_TEAM1;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send : %s: TOURNAMENT_TEAM_ENTRY_APP_ALREADY_TEAM1", __FUNCTION__, GetPublicID().c_str() );
	}
	else if( m_UserTournament.IsAlreadyTeam( dwTeamIndex ) )
	{
		iResult = TOURNAMENT_TEAM_ENTRY_APP_ALREADY_TEAM2;
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Send : %s: TOURNAMENT_TEAM_ENTRY_APP_ALREADY_TEAM2", __FUNCTION__, GetPublicID().c_str() );
	}
	else if( m_UserEtcItem.HaveAThisItem(1004067) )
	{
		// 해당 아이템을 가지고 있으면 팀 생성 불가. - 임시 유영재
		//가입 불가능한 유저.
		iResult = TOURNAMENT_TEAM_ENTRY_APP_BAN;
	}
	else if( m_UserPresent.HaveAThisItem(PRESENT_ETC_ITEM, 1004067) )
	{
		// 선물함에서도 검색.
		iResult = TOURNAMENT_TEAM_ENTRY_APP_BAN;
	}

	if( iResult == TOURNAMENT_TEAM_ENTRY_APP_OK )
	{
		g_DBClient.OnInsertTournamentTeamAppAdd( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIndex, dwTeamIndex, dwMasterIndex );
	}
	else
	{
		SP2Packet kPacket( STPK_TOURNAMENT_TEAM_ENTRY_APP );
		kPacket << iResult << dwTourIndex << dwTeamIndex;
		SendMessage( kPacket );
	}
}

void User::OnTournamentTeamEntryRefuse( SP2Packet &rkPacket )
{
	DWORD dwTableIndex;
	rkPacket >> dwTableIndex;

	g_DBClient.OnDeleteTournamentTeamAppDel( GetUserDBAgentID(), GetAgentThreadID(), dwTableIndex );
}

void User::OnTournamentTeamEntryAgree( SP2Packet &rkPacket )
{
	bool bCampCheck;
	DWORD dwTableIndex, dwAppUserIndex, dwTourIndex, dwTeamIndex;
	rkPacket >> dwTableIndex >> dwAppUserIndex >> dwTourIndex >> dwTeamIndex >> bCampCheck;

	// 해당 유저 체크
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( dwAppUserIndex );
	if( pUserParent )
	{
		if( bCampCheck )
		{
			if( GetUserCampPos() != pUserParent->GetUserCampPos() )
			{
				// 진영이 다르므로 동일 팀이 될 수 없다.
				SP2Packet kPacket( STPK_TOURNAMENT_TEAM_ENTRY_AGREE );
				kPacket << TOURNAMENT_TEAM_ENTRY_AGREE_CAMP_NONE;
				SendMessage( kPacket );

				// 대기자 삭제
				g_DBClient.OnDeleteTournamentTeamAppDel( pUserParent->GetUserDBAgentID(), pUserParent->GetAgentThreadID(), dwTableIndex );
				return;
			}
		}
	}
	
	if( g_TournamentManager.IsTournamentTeamEntryAgreeState( dwTourIndex ) )
	{
		BYTE CampPos = 0;
		if( bCampCheck )
		{
			CampPos = (BYTE)GetUserCampPos();
		}
		g_DBClient.OnUpdateTournamentTeamAppReg( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwAppUserIndex, dwTourIndex, dwTeamIndex, dwTableIndex, CampPos );
	}
	else
	{
		// 모집 기간 종료
		SP2Packet kPacket( STPK_TOURNAMENT_TEAM_ENTRY_AGREE );
		kPacket << TOURNAMENT_TEAM_ENTRY_AGREE_END_APP;
		SendMessage( kPacket );

		// 대기자 삭제
		g_DBClient.OnDeleteTournamentTeamAppDel( pUserParent->GetUserDBAgentID(), pUserParent->GetAgentThreadID(), dwTableIndex );
	}
}

void User::OnTournamentTeamLeave( SP2Packet &rkPacket )
{
	DWORD dwTourIndex, dwTeamIndex, dwTableIndex, dwMemberIndex;
	rkPacket >> dwTourIndex >> dwTeamIndex >> dwTableIndex >> dwMemberIndex;

	if( g_TournamentManager.IsTournamentTeamEntryAgreeState( dwTourIndex ) )
	{
		g_DBClient.OnDeleteTournamentTeamMember( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIndex, dwTeamIndex, dwTableIndex, dwMemberIndex );
	}
	else
	{
		// 탈퇴 가능 기간 아님
		SP2Packet kPacket( STPK_TOURNAMENT_TEAM_LEAVE );
		kPacket << TOURNAMENT_TEAM_LEAVE_FAILED_STATE;
		SendMessage( kPacket );
	}
}

void User::OnTournamentScheduleInfo( SP2Packet &rkPacket )
{
	DWORD dwTourIndex;
	rkPacket >> dwTourIndex;

	SP2Packet kPacket( MSTPK_TOURNAMENT_SCHEDULE_INFO );
	kPacket << GetUserIndex() << dwTourIndex;
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentRoundTeamData( SP2Packet &rkPacket )
{
	DWORD dwTourIndex;
	rkPacket >> dwTourIndex;

	int iStartRound, iTotalRoundCount;
	int iRoundTeamCount, iStartRountTeamArray;
	rkPacket >> iStartRound >> iTotalRoundCount >> iRoundTeamCount >> iStartRountTeamArray;

	SP2Packet kPacket( MSTPK_TOURNAMENT_ROUND_TEAM_DATA );
	kPacket << GetUserIndex() << dwTourIndex << iStartRound << iTotalRoundCount << iRoundTeamCount << iStartRountTeamArray;
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentRoomList( SP2Packet &rkPacket )
{
	DWORD dwTourIndex;
	rkPacket >> dwTourIndex;

	int iCurPage, iMaxCount;
	rkPacket >> iCurPage >> iMaxCount;

	g_TournamentManager.SendTournamentRoomList( this, dwTourIndex, iCurPage, iMaxCount );
}

void User::OnTournamentTeamAllocateList( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_TEAM_ALLOCATE_LIST );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentTeamAllocateData( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_TEAM_ALLOCATE_DATA );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentJoinConfirmCheck( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_JOIN_CONFIRM_CHECK );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentJoinConfirmRequest( SP2Packet &rkPacket )
{
	DWORD dwTourIndex, dwOwnerIndex;
	rkPacket >> dwTourIndex >> dwOwnerIndex;

	int iResult = TOURNAMENT_JOIN_CONFIRM_REQUEST_OK;
	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( dwOwnerIndex );
	if( pUserParent )
	{
		SP2Packet kPacket( STPK_TOURNAMENT_JOIN_CONFIRM_LIST );
		kPacket << dwTourIndex << GetUserIndex() << GetPublicID() << GetGradeLevel();
		pUserParent->RelayPacket( kPacket );
	}
	else
	{
		iResult = TOURNAMENT_JOIN_CONFIRM_REQUEST_OFFLINE;
	}

	SP2Packet kPacketResult( STPK_TOURNAMENT_JOIN_CONFIRM_REQUEST );
	kPacketResult << iResult << dwTourIndex;
	SendMessage( kPacketResult );
}

void User::OnTournamentJoinConfirmCommand( SP2Packet &rkPacket )
{
	int iCommand;
	rkPacket >> iCommand;

	DWORD dwTourIndex;
	rkPacket >> dwTourIndex;

	switch( iCommand )
	{
	case TOURNAMENT_JOIN_CONFIRM_COMMAND_AGREE:
		{
			int iRequestUserLevel;
			DWORD dwRequestUserIndex;
			ioHashString szRequestUserID;
			rkPacket >> dwRequestUserIndex >> szRequestUserID >> iRequestUserLevel;

			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( dwRequestUserIndex );
			if( pUserParent )
			{
				SP2Packet kPacket( STPK_TOURNAMENT_JOIN_CONFIRM_REQUEST );
				kPacket << TOURNAMENT_JOIN_CONFIRM_REQUEST_AGREE << dwTourIndex;
				pUserParent->RelayPacket( kPacket );
			}		

			// 메인 서버에 등록
			SP2Packet kMainPacket( MSTPK_TOURNAMENT_CONFIRM_REG );
			kMainPacket << dwTourIndex << GetUserIndex() << dwRequestUserIndex << szRequestUserID << iRequestUserLevel;
			g_MainServer.SendMessage( kMainPacket );
		}
		break;
	case TOURNAMENT_JOIN_CONFIRM_COMMAND_REJECT:
		{
			int iRequestUserLevel;
			DWORD dwRequestUserIndex;
			ioHashString szRequestUserID;
			rkPacket >> dwRequestUserIndex >> szRequestUserID >> iRequestUserLevel;

			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( dwRequestUserIndex );
			if( pUserParent )
			{
				SP2Packet kPacket( STPK_TOURNAMENT_JOIN_CONFIRM_REQUEST );
				kPacket << TOURNAMENT_JOIN_CONFIRM_REQUEST_REJECT << dwTourIndex;
				pUserParent->RelayPacket( kPacket );
			}
		}
		break;
	case TOURNAMENT_JOIN_CONFIRM_COMMAND_INVITE:
		{
			ioHashString szUserID, szTourTitle;
			rkPacket >> szUserID >> szTourTitle;

			UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szUserID );
			if( pUserParent )
			{
				// 메인 서버에 등록
				SP2Packet kMainPacket( MSTPK_TOURNAMENT_CONFIRM_REG );
				kMainPacket << dwTourIndex << GetUserIndex() << pUserParent->GetUserIndex() << pUserParent->GetPublicID() << pUserParent->GetGradeLevel();
				g_MainServer.SendMessage( kMainPacket );

				// 주최자에게 전송
				SP2Packet kOwnerPacket( STPK_TOURNAMENT_JOIN_CONFIRM_COMMAND );
				kOwnerPacket << TOURNAMENT_JOIN_CONFIRM_COMMAND_INVITE_OK << dwTourIndex << szUserID;
				SendMessage( kOwnerPacket );

				// 받는 유저에게 전송
				SP2Packet kPacket( STPK_TOURNAMENT_JOIN_CONFIRM_COMMAND );
				kPacket << TOURNAMENT_JOIN_CONFIRM_COMMAND_INVITED << dwTourIndex << szTourTitle;
				pUserParent->RelayPacket( kPacket );
			}
			else
			{
				// 오프라인 알림
				SP2Packet kPacket( STPK_TOURNAMENT_JOIN_CONFIRM_COMMAND );
				kPacket << TOURNAMENT_JOIN_CONFIRM_COMMAND_INVITE_OFFLINE << dwTourIndex << szUserID;
				SendMessage( kPacket );
			}
		}
		break;
	}
}

void User::OnTournamentAnnounceChange( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_ANNOUNCE_CHANGE );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentTotalTeamList( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_TOTAL_TEAM_LIST );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentCustomStateStart( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_CUSTOM_STATE_START );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentCustomRewardList( SP2Packet &rkPacket )
{
	SP2Packet kPacket( MSTPK_TOURNAMENT_CUSTOM_REWARD_LIST );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentCustomRewardBuy( SP2Packet &rkPacket )
{
	// 메인 서버에 등록 가능한지 먼저 체크
	SP2Packet kPacket( MSTPK_TOURNAMENT_CUSTOM_REWARD_REG_CHECK );
	kPacket << GetUserIndex();
	kPacket.SetDataAdd( (char*)rkPacket.GetData(), rkPacket.GetDataSize() );
	g_MainServer.SendMessage( kPacket );
}

void User::OnTournamentCheerDecision( SP2Packet &rkPacket )
{
	DWORD dwTourIdx;
	DWORD dwTeamIdx;

	rkPacket >> dwTourIdx;
	rkPacket >> dwTeamIdx;

	if( !g_TournamentManager.IsRegularTournament( dwTourIdx ) )
	{
		SP2Packet kPacket( STPK_TOURNAMENT_CHEER_DECISION );
		kPacket << TOURNAMENT_CHEER_DECISION_NOT_REGULAR;
		SendMessage( kPacket );
		return;
	}
		
	if( g_TournamentManager.GetTournamentState( dwTourIdx ) != TournamentManager::STATE_TEAM_DELAY )
	{
		SP2Packet kPacket( STPK_TOURNAMENT_CHEER_DECISION );
		kPacket << TOURNAMENT_CHEER_DECISION_NOT_TEAM_DELAY;
		SendMessage( kPacket );
		return;
	}

	ioUserTournament* pUserTournament = GetUserTournament();
	if( !pUserTournament )
	{
		SP2Packet kPacket( STPK_TOURNAMENT_CHEER_DECISION );
		kPacket << TOURNAMENT_CHEER_DECISION_FAIL;
		SendMessage( kPacket );
		return;
	}
	
	if( pUserTournament->IsCheerTeam( dwTourIdx ) )
	{
		SP2Packet kPacket( STPK_TOURNAMENT_CHEER_DECISION );
		kPacket << TOURNAMENT_CHEER_DECISION_ALREADY;
		SendMessage( kPacket );
		return;
	}

	g_DBClient.OnInsertTournamentCheerDecision( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), dwTourIdx, dwTeamIdx );
}

void User::OnTournamentCheerDecisionOK( SP2Packet &rkPacket )
{
	DWORD dwTourIdx, dwTeamIdx;
	int iCheerCnt;

	rkPacket >> dwTourIdx;
	rkPacket >> dwTeamIdx;
	rkPacket >> iCheerCnt;

	LOG.PrintTimeAndLog(0, "Tournament cheer decision sucess : %s, %d", GetPublicID().c_str(), iCheerCnt );

	SP2Packet kPacket( STPK_TOURNAMENT_CHEER_DECISION );
	kPacket << TOURNAMENT_CHEER_DECISION_OK;
	kPacket << iCheerCnt;
	kPacket << dwTourIdx;
	kPacket << dwTeamIdx;
	SendMessage( kPacket );
}

//! 클로버 리필.
void User::CloverRefill( CTime& CurrentTime )
{
	// Get Clover
	ioClover* pClover = GetClover();
	if( pClover == NULL )
		return;

	if( pClover->GetCloverCount() >= Help::GetCloverMaxCount() )
		return;

	// 클로버 리필.
	pClover->UpdateCloverInfo( ioClover::CLOVER_TYPE_REFILL, Help::GetCloverMaxCount(), CurrentTime );

	{
		// LOGDB : Clover Refill
		g_LogDBClient.OnInsertCloverInfo( GetUserIndex(), 0,
			ioClover::CLOVER_TYPE_REFILL, pClover->GetCloverCount() );
	}
	
	// Refill
	GiftCloverInfo( ioClover::GIFT_CLOVER_REFILL );
}

//! 클로버 정보 Send
void User::GiftCloverInfo( const int iType )
{
	ioClover* pClover = GetClover();

	SP2Packet kPacket( STPK_GIFTCLOVER_INFO );
	PACKET_GUARD_VOID( kPacket.Write(iType) );
	PACKET_GUARD_VOID( kPacket.Write(pClover->GetCloverCount()) );
	PACKET_GUARD_VOID( kPacket.Write(pClover->GetCloverRemainTime()) );
	
	SendMessage( kPacket );
}

void User::CloverFriendInfo( const DWORD dwFriendIndex, const int iType )
{
	ioFriend* pFriend = GetFriend();
	if( pFriend == NULL )
		return;
		
	// 친구리스트 정보를 구해서.
	FRIEND& rkFriend = pFriend->GetFriendToUserIndex( dwFriendIndex );

	// 클로버 받는 친구에게 알림. (ack) // 친구리스트의 A 관련
	SP2Packet kPacket( STPK_CLOVER_FRIEND_INFO );
	kPacket << rkFriend.m_dwUserIndex << iType << rkFriend.m_iCloverSendCount << rkFriend.m_iCloverSendDate
			<< rkFriend.m_iCloverReceiveCount << rkFriend.m_iCloverBeforeReceiveDate << rkFriend.m_iCloverBeforeReceiveCount;

	SendMessage( kPacket );
}

//! 클로버 시간 단위로 충전.
void User::OnCloverChargeReq( SP2Packet& kPacket )
{
	// Get Clover
	ioClover* pClover = GetClover();
	if( pClover == NULL )
		return;

	// Get Current My Info
	int iCloverCount = pClover->GetCloverCount();

	// Check : max 갯수를 넘을 수 없다.
	if( iCloverCount >= Help::GetCloverMaxCount() )
	{
		GiftCloverInfo( ioClover::GIFT_CLOVER_CHARGE_FAIL );
		return;
	}

	// Get : 현재 시간.
	CTime CurrentTime = CTime::GetCurrentTime();

	// Check
	if( pClover->IsValidCharge( CurrentTime ) == TRUE )
	{
		// 충전 시키고.
		pClover->UpdateCloverInfo( ioClover::CLOVER_TYPE_CHARGE, Help::GetCloverChargeCount(), CurrentTime );

		// 충전된 정보를 클라로 전송.
		GiftCloverInfo( ioClover::GIFT_CLOVER_CHARGE_SUCCESS );

		// LOGDB : Clover Charge
		g_LogDBClient.OnInsertCloverInfo( GetUserIndex(), 0, ioClover::CLOVER_TYPE_CHARGE, pClover->GetCloverCount() );
	}
	else
	{
		// 충전 시간 안됨.
		GiftCloverInfo( ioClover::GIFT_CLOVER_CHARGE_FAIL );
	}
}

void User::OnCloverSendReq( SP2Packet& kPacket )
{
	// declare
	DWORD dwTargetFriend;
	kPacket >> dwTargetFriend;
	
	// Get Friend / Clover
	ioFriend* pFriend = GetFriend();
	ioClover* pClover = GetClover();
	if( pFriend == NULL || pClover == NULL )
		return;

	// Check : 나의 클로버 갯수
	if( pClover->GetCloverCount() <= 0 )
	{
		// 가지고 있는 클로버 없다.
		GiftCloverInfo( ioClover::FRIEND_CLOVER_SEND_FAIL_NOT_ENOUGH_CLOVER );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : Nothing Clover... C.Count : %d ? ", __FUNCTION__, pClover->GetCloverCount() );
		return;
	}

	// Get : 친구정보
	FRIEND& kFriend = pFriend->GetFriendToUserIndex( dwTargetFriend );

	// Check
	if( kFriend.m_dwUserIndex == 0 )
	{
		// 친구 아닌듯..
		GiftCloverInfo( ioClover::FRIEND_CLOVER_SEND_FAIL_NOT_FRIEND );
		LOG.PrintTimeAndLog( 0, "%s : Not Friend... (%u)(%u)", __FUNCTION__, GetUserIndex(), dwTargetFriend );
		return;
	}

	// 친구 된 시간 체크.
	CTime CurrentTime = CTime::GetCurrentTime();
	CTime FriendTime( Help::GetSafeValueForCTimeConstructor( kFriend.GetYearRegTime(),
															kFriend.GetMonthRegTime(),
															kFriend.GetDayRegTime(),
															kFriend.GetHourRegTime(),
															kFriend.GetMinuteRegTime(),
															0 ) );

	// Check : 친구 맺고 바로 클로버 주기 블가.
	CTimeSpan Span = CurrentTime - FriendTime;
	if( Span.GetTotalMinutes() < Help::GetGiveCloverTimeMinute() - ioClover::MAGIC_TIME )
	{
		GiftCloverInfo( ioClover::FRIEND_CLOVER_SEND_FAIL_FRIEND_REG_TIME );
		LOG.PrintTimeAndLog( 0, "%s : FRIEND_CLOVER_SEND_FAIL_FRIEND_REG_TIME %d < %d - 2", __FUNCTION__, Span.GetTotalMinutes(), Help::GetGiveCloverTimeMinute() );
		return;
	}

	
	// 클로버를 보낸 마지막 시간 체크.
	CTime LastSendTime = pClover->ConvertNumberToCTime( kFriend.GetCloverSendDate() );
	CTimeSpan Span2 = CurrentTime - LastSendTime;

	// Check : 친구에게 클로버를 보낼 수 있는 시간 체크.
	if( Span2.GetTotalMinutes() < Help::GetCloverSendTimeMinute() - ioClover::MAGIC_TIME )
	{
		GiftCloverInfo( ioClover::FRIEND_CLOVER_SEND_FAIL_ALREADY_SEND );
		LOG.PrintTimeAndLog( 0, "%s : FRIEND_CLOVER_SEND_FAIL_ALREADY_SEND %d < %d - 2", __FUNCTION__, Span2.GetTotalMinutes(), Help::GetCloverSendTimeMinute() );
		return;
	}

	// 현재시간 컨버트
	DWORD dwCurrentTime = Help::ConvertYYMMDDHHMMToDate( CurrentTime.GetYear(),
														CurrentTime.GetMonth(),
														CurrentTime.GetDay(),
														CurrentTime.GetHour(),
														CurrentTime.GetMinute() );
	
	// 친구가 접속해 있는지.
	UserParent* pTargetParent = g_UserNodeManager.GetGlobalUserNode( dwTargetFriend );
	if( pTargetParent )
	{
		if( pTargetParent->IsUserOriginal() )
		{
			// 같은 서버.
			User* pFriendUser = dynamic_cast< User* >( pTargetParent );

			// Friend
			ioFriend* pTargetFriend = pFriendUser->GetFriend();
			pTargetFriend->SetFriendBeforeReceiveCloverData( GetUserIndex(), Help::GetCloverSendCount(), dwCurrentTime );

			// 친구의 B.Receive 세팅.
			pFriendUser->CloverFriendInfo( GetUserIndex(), ioClover::FRIEND_CLOVER_COME_TO_FRIEND );
		}
		else
		{
			// 다른 서버의 친구에게 알려줌.
			UserCopyNode* pCopyNodeFriend = (UserCopyNode*)pTargetParent;
						
			SP2Packet kPacket( SSTPK_CLOVER_SEND );
			kPacket << GetUserIndex() << dwTargetFriend << dwCurrentTime;
			pCopyNodeFriend->SendMessage( kPacket );
		}
	}
	else
	{
		// 친구 접속 안한 상태. DB 업데이트. 결과받아서 유저 접속했다면 데이터 씌워줌.
		g_DBClient.OnUpdateFriendReceiveCloverInfo( GetUserDBAgentID(),
													GetAgentThreadID(),
													GetUserIndex(),
													kFriend.m_dwUserIndex,
													static_cast< int >( dwCurrentTime ),
													Help::GetCloverSendCount() );
	}
	
	// 나의 클로버 정보 갱신
	pClover->UpdateCloverInfo( ioClover::CLOVER_TYPE_SEND, Help::GetCloverSendCount(), CurrentTime );

	// 나의 친구 목록 클로버 데이타 갱신.
	pFriend->SetFriendCloverSendData( dwTargetFriend,
									Help::GetCloverSendCount(),
									static_cast< int >( dwCurrentTime ) );

	// LOGDB : Clover Send
	g_LogDBClient.OnInsertCloverInfo( GetUserIndex(), static_cast< int >( dwTargetFriend ),
		ioClover::CLOVER_TYPE_SEND, pClover->GetCloverCount() );

	// 친구정보
	CloverFriendInfo( dwTargetFriend, ioClover::FRIEND_CLOVER_SEND_SUCCESS );

	// 클로버 정보.
	GiftCloverInfo( ioClover::FRIEND_CLOVER_SEND_SUCCESS );

	//미션 체크
	static DWORDVec vValue;
	vValue.clear();
	vValue.push_back(1);

	g_MissionMgr.DoTrigger(MISSION_CLASS_CLOVER, this, vValue);
}

void User::OnCloverReceiveReq( SP2Packet& kPacket )
{
	// declare
	DWORD dwTargetFriend;
	kPacket >> dwTargetFriend;

	// Get Friend / Clover
	ioFriend* pFriend = GetFriend();
	ioClover* pClover = GetClover();
	if( pFriend == NULL || pClover == NULL )
		return;
	
	// Check : 친구인가
	FRIEND kFriend = pFriend->GetFriendToUserIndex( dwTargetFriend );
	if( kFriend.m_dwUserIndex == 0 )
	{
		// 친구 아닌듯..
		GiftCloverInfo( ioClover::FRIEND_CLOVER_RECV_FAIL_NOT_FRIEND );
		LOG.PrintTimeAndLog( 0, "%s : (%u)(%u) is Friend ? ", __FUNCTION__, GetUserIndex(), kFriend.m_dwUserIndex );
		return;
	}

	// Check : 받은 클로버가 있는지.
	if( kFriend.m_iCloverBeforeReceiveCount < Help::GetCloverReceiveCount() )
	{
		// 친구에게 받은 클로버 없다.
		GiftCloverInfo( ioClover::FRIEND_CLOVER_RECV_FAIL_NOT_CLOVER );
		LOG.PrintTimeAndLog( 0, "%s : (%u) Not Received Clover... C.Count : %d ? ", __FUNCTION__, kFriend.m_dwUserIndex, kFriend.m_iCloverBeforeReceiveCount );
		return;
	}

	// Get : 현재시간.
	CTime CurrentTime = CTime::GetCurrentTime();

	// 친구에게 클로버 받기.
	pFriend->SetFriendReceiveCloverData( kFriend.m_dwUserIndex, Help::GetCloverSendCount() );
	
	// LOGDB : Clover Receive
	g_LogDBClient.OnInsertCloverInfo( GetUserIndex(), static_cast< int >( dwTargetFriend ),
		ioClover::CLOVER_TYPE_RECEIVE, pClover->GetCloverCount() );



	//----------------------
	// clover etc item
	//----------------------
	
	// Check Etc Item Type Clover
	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem( ioEtcItem::EIT_ETC_CLOVER );
	if( pEtcItem == NULL )
	{
		// LOG
		LOG.PrintTimeAndLog( 0, "%s : pEtcItem == NULL", __FUNCTION__ );
		return;
	}

	// Declare) etc item
	ioUserEtcItem::ETCITEMSLOT kEtcItemSlot;
	bool bExist = false;
	bool bNewMortmain = false;
	bool bExistMortmain = false;


	// Exist ?
	bExist = m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_CLOVER, kEtcItemSlot );
	
	if( bExist && g_EtcItemMgr.IsBlockEtcItem( ioEtcItem::EIT_ETC_CLOVER ) &&
		kEtcItemSlot.m_iValue1 == 0 &&
		kEtcItemSlot.m_iValue2 == 0 )
	{
		bExistMortmain = true;
	}

	int iMaxCheckResult = _OnEtcItemMaxCheck( pEtcItem, kEtcItemSlot, Help::GetCloverReceiveCount(), bExistMortmain );
	if( iMaxCheckResult != ETCITEM_BUY_OK )
	{
		LOG.PrintTimeAndLog( 0, "%s : iMaxCheckResult != ETCITEM_BUY_OK", __FUNCTION__ );
		return;
	}	
	
	// Check : Is Block ?
	if( g_EtcItemMgr.IsBlockEtcItem( ioEtcItem::EIT_ETC_CLOVER ) && Help::GetCloverReceiveCount() == 0 )
	{
		bNewMortmain = true;
	}
	
	// item setting
	_OnEtcItemSetting( pEtcItem, kEtcItemSlot, Help::GetCloverReceiveCount(), bNewMortmain );



	if( bExist == true )
	{
		// 존재하면 Set
		m_UserEtcItem.SetEtcItem( kEtcItemSlot );

		// etc item send
		SP2Packet kPacket( STPK_ETCITEM_CLOVER_UPDATE );
		kPacket << kEtcItemSlot.m_iType;
		kPacket << kEtcItemSlot.m_iValue1;
		kPacket << kEtcItemSlot.m_iValue2;

		SendMessage( kPacket );
	}
	else
	{
		// Declare) for log
		DWORD dwEtcIndex     = 0;
		int   iArrayInIndex  = 0;

		// 클로버 아이템을 add 시켜줌.
		bool bResult = m_UserEtcItem.AddEtcItem( kEtcItemSlot, false, 0, dwEtcIndex, iArrayInIndex );
		if( bResult == true )
		{
			// etc item send
			SP2Packet kPacket( STPK_ETCITEM_CLOVER_UPDATE );
			kPacket << kEtcItemSlot.m_iType;
			kPacket << kEtcItemSlot.m_iValue1;
			kPacket << kEtcItemSlot.m_iValue2;
			SendMessage( kPacket );
		}

		if( dwEtcIndex != 0 )
		{
			char szItemIndex[MAX_PATH]="";
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwEtcIndex, iArrayInIndex+1 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertEtc( this, kEtcItemSlot.m_iType, Help::GetCloverReceiveCount(), 0, szItemIndex, LogDBClient::ET_PRESENT );
			StartEtcItemTime(  __FUNCTION__ , kEtcItemSlot.m_iType );
		}
	}
	
	//미션 체크
	static DWORDVec vValue;
	vValue.clear();
	vValue.push_back(2);

	g_MissionMgr.DoTrigger(MISSION_CLASS_CLOVER, this, vValue);

	// ack
	CloverFriendInfo( dwTargetFriend, ioClover::FRIEND_CLOVER_RECV_SUCCESS );
}

void User::OnCloverReceiveDelete( SP2Packet& kPacket )
{
	DWORD dwFriendIndex = 0;
	kPacket >> dwFriendIndex;

	ioFriend* pFriend = GetFriend();
	if( pFriend == NULL )
		return;

	pFriend->SetFriendBeforeReceiveCloverDelete( dwFriendIndex );

	ioClover* pClover = GetClover();
	if( pClover == NULL )
		return;

	// LOGDB : Clover Send
	g_LogDBClient.OnInsertCloverInfo( GetUserIndex(), static_cast< int >( dwFriendIndex ),
		ioClover::CLOVER_TYPE_REMOVE, pClover->GetCloverCount() );
}

void User::OnBingoStart( SP2Packet& kPacket )
{	
	ioBingo* pBingo = GetBingo();
	if( pBingo )
		pBingo->OnBingoStart( this );
}

//! 초기화 버튼
void User::OnBingoNumberInitialize( SP2Packet& kPacket )
{

	ioBingo* pBingo = GetBingo();
	if( pBingo )
		pBingo->OnBingoNumberInitialize( this );
}

//! 올빙고 이후 다시 시작.
void User::OnBingoALLInitialize( SP2Packet& kPacket )
{
	ioBingo* pBingo = GetBingo();
	if( pBingo )
		pBingo->OnBingoALLInitialize( this );
}

void User::OnFillCashUrl( SP2Packet& kPacket )
{
	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Billing Wait : %s:%s", __FUNCTION__, GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_FILL_CASH_URL );
		kReturn << FILL_CASH_URL_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL : %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		SP2Packet kReturn( STPK_FILL_CASH_URL );
		kReturn << FILL_CASH_URL_EXCEPTION;
		SendMessage( kReturn );
		return;
	}

	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;
	
	int iBillingType =  0;
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_US )
	{
		if( GetChannelingType() == 0 )
		{
			return;
		}
		else
		{

			kPacket >> iBillingType;
		}
		
	}


	SP2Packet kBillingPacket( BSTPK_FILL_CASH_URL );
	kBillingPacket << (int) GetChannelingType();
	kBillingPacket << m_szBillingGUID;
	kBillingPacket << GetUserIndex();
	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_US )
	{
		kBillingPacket << iBillingType;
	}
	if( !pNode->AddRequestFillCashUrlPacket( this, kBillingPacket ) )
	{
		m_szBillingGUID.Clear();
		return;
	}

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
		SP2Packet kReturn( STPK_FILL_CASH_URL );
		kReturn << FILL_CASH_URL_DISCONNECT;
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
		return;
	}

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : Send : %s(%d)", __FUNCTION__, GetPublicID().c_str(), GetUserIndex() );
}

void User::OnPirateRouletteInfoRequest( SP2Packet& kPacket )
{
	// 해적룰렛 통 아이템 존재 여부 확인
	int iPirateRouletteItemType = ioEtcItem::EIT_ETC_OAK_DRUM_ITEM;
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( iPirateRouletteItemType, kSlot );

	if( kSlot.m_iType <= 0 || kSlot.m_iValue1 <= 0 )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_DONT_HAVE ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemUse Fail - %s) %d don't have value.",  GetPublicID().c_str(), iPirateRouletteItemType );
		return;
	}

	ioEtcItem *pEtcItem = g_EtcItemMgr.FindEtcItem( iPirateRouletteItemType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_EXCEPTION ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemUse Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), iPirateRouletteItemType );
		return;
	}

	ioPirateRoulette* pPirateRoulette = GetPirateRoulette();
	if( pPirateRoulette->IsFromDB() )
	{
		SP2Packet kReturn( STPK_OAK_INFO_REQUEST );
		pPirateRoulette->GetRouletteBoardData( kReturn );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info] OnPirateRouletteInfoRequest - Send Data to %s HP : %d.",  GetPublicID().c_str(), pPirateRoulette->GetHP());
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnPirateRouletteInfoRequest - Send Data From DB to %s).",  GetPublicID().c_str());
	}
	else
	{
		// DB Request New Roulette.
		g_DBClient.OnInsertPirateRouletteNumber( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex());
		g_DBClient.OnInsertPirateRoulettePresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex());

		ioPirateRoulette* pPirateRoulette = GetPirateRoulette();
		pPirateRoulette->InitAll();
		pPirateRoulette->SetFromDB(true);

		SP2Packet kReturn( STPK_OAK_INFO_REQUEST );
		pPirateRoulette->GetRouletteBoardData( kReturn );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info] OnPirateRouletteInfoRequest - Send Data to %s HP : %d.",  GetPublicID().c_str(), pPirateRoulette->GetHP());
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "OnPirateRouletteInfoRequest - Send Data and Insert to init data DB to %s).",  GetPublicID().c_str());
	}
}

void User::OnPirateRouletteUseSwordRequest( SP2Packet& kPacket )
{
	int iRoulettePosition = 0;
	int iSwordType = 0;
	kPacket >> iRoulettePosition;
	kPacket >> iSwordType;

	SP2Packet kReturn(STPK_OAK_USE_SWORD);

	DWORD dwEtcItemType = g_PirateRouletteMgr.GetSwordDummyCode( iSwordType );

	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( dwEtcItemType, kSlot );

	if( kSlot.m_iType <= 0 || kSlot.m_iValue1 <= 0 )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_DONT_HAVE ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemUse Fail - %s) %d don't have value.",  GetPublicID().c_str(), dwEtcItemType );
		return;
	}

	ioEtcItem *pEtcItem = g_EtcItemMgr.FindEtcItem( dwEtcItemType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		PACKET_GUARD_VOID( kReturn.Write( ETCITEM_USE_EXCEPTION ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemUse Fail - %s) %d pEtcItem == NULL.",  GetPublicID().c_str(), dwEtcItemType );
		return;
	}

//	bool OnUse( SP2Packet &rkPacket , User *pUser, ioUserEtcItem *pUserEtcItem, ioUserEtcItem::ETCITEMSLOT &rkSlot );
	pEtcItem->OnUse( kPacket, this, GetUserEtcItem(), kSlot);

	ioPirateRoulette* pPirateRoulette = GetPirateRoulette();
	if( pPirateRoulette )
	{
		pPirateRoulette->UseSword( iRoulettePosition, iSwordType, kReturn );
	}
	else
	{
		kReturn << 0 << 0 << 0 << 0;
	}

	SendMessage( kReturn );
}

void User::OnPirateRouletteResetRequest( SP2Packet& kPacket )
{
	ioPirateRoulette* pPirateRoulette = GetPirateRoulette();
	if( pPirateRoulette )
	{
		pPirateRoulette->OnRouletteStart(this);
	}
}


void User::SendUserLogOut()
{
	if(IsRelayUse())
	{
		//kyg 작업 
		SP2Packet kPacket(RSTPK_ON_CONTROL);

		int ctype = RS_DEL_USER; 
		DWORD userIndex = GetUserIndex();

		PACKET_GUARD_VOID( kPacket.Write(ctype) );
		PACKET_GUARD_VOID( kPacket.Write(userIndex) );

		ServerNode * node = g_Relay.GetRelayServer(m_iRelayServerID);//유저가 어느 릴레이에 붙어있는지 정함 
		if(node)
			node->SendMessage(kPacket);
		SetRelayServerID(0);
	}
}

bool User::TimeOutClose( int checkTime )
{
	if(IsRelayUse())
	{
		switch(checkTime)
		{
		case SEC_30:
			{
				Debug("SEC_30::%d초간 응답이 없어 접속 종료시킴(%d)", checkTime / 60000, GetUserIndex() );
			}
			break;
		case SEC_60:
			{
				//this->GetPlayingMode()
				
				if( m_pMyRoom )
				{
					if( m_pMyRoom->GetModeType() == MT_KING || m_pMyRoom->GetModeType() == MT_DOBULE_CROWN )
					{						
						m_iDropKing++;
					}
				}
			}
			break;
		case SEC_90:
			{
				if(m_pMyRoom)
				{
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "SEC_90::%d초간 응답이 없어 접속 종료시킴(%d)", checkTime / 60000, GetUserIndex() ); 
					ExceptionClose(0);
				}

			}
			break;
		case MIN_5:
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "MIN_5::%d초간 응답이 없어 접속 종료시킴(%d)", checkTime / 60000, GetUserIndex() ); 
				ExceptionClose(0);
				
			}

			break;

		}
	}
	return false;
}

void User::SetTransferAddress( ServerNode* &node, ioHashString &ipAddr, int &port )
{
	
	if(m_pMyRoom == NULL)
	{
		ipAddr = g_App.GetClientMoveIP();
		port = g_App.GetCSPort();
		SetRelayServerID(0);
		return;
	}
 	if(m_pMyRoom->RelayServerIndex() == 0)
	{
		ipAddr = g_App.GetClientMoveIP();
		port = g_App.GetCSPort();
		SetRelayServerID(0);
		return;
	}
	else
	{ //kyg 여기도 바꿈 어떤 포트로 줘야할지 정해야함 
		node = g_Relay.GetRelayServer(GetMyRoom()->RelayServerIndex());//릴레이 서버가 새로 할당될리 없음 
		if(node)
		{
			SetRelayServerID(node->RelayServerIndex());
			ipAddr = node->SZPublicIP();
			port = node->GetRelayServerPort(GetMyRoom()->GetRoomIndex());
		}
		else
		{ // 이게 맞는 것인지 
			Information("SetTransferAddress Error (%d)Relay Index is NULL",m_pMyRoom->RelayServerIndex());
			LOG.PrintTimeAndLog(0,"SetTransferAddress Error (%d)Relay Index is NULL",m_pMyRoom->RelayServerIndex());
			ipAddr = g_App.GetClientMoveIP();
			port = g_App.GetCSPort();
			SetRelayServerID(0);

		}
	}
}

void User::LeaveProcess()
{
	if(m_pMyRoom == NULL)
		return;
	RoomStyle eRoomStyle = m_pMyRoom->GetRoomStyle();
	LeaveRoom();
	switch( eRoomStyle )
	{
	case RSTYLE_BATTLEROOM:
		LeaveBattleRoom();
		break;
	case RSTYLE_PLAZA:
		break;
	case RSTYLE_LADDERBATTLE:
		LeaveLadderTeam();
		break;
	case RSTYLE_SHUFFLEROOM:
		LeaveShuffleRoom();
		break;
	default:
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::UserVoteRoomKickOut(%s) 알 수없는 룸 스타일 : %d", GetPublicID().c_str(), (int)eRoomStyle );
		break;
	}

	// 본부로 이탈
	ExitRoomToTraining( EXIT_ROOM_OK, false );

}

void User::SetClientAddressForRelay( char* szIpaddr,int iPort )
{
	LOG.PrintTimeAndLog(0,"SetClientAddressForRelay (%s:%d)\n",szIpaddr,iPort);
	strcpy_s(m_public_ip,szIpaddr);
	m_client_port = iPort;
}

void User::UpdateRelativeGrade( DWORD dwUniqueCode )
{
	if( m_user_relative_grade_data.m_init_code == dwUniqueCode )
		return;

	m_user_relative_grade_data.m_init_code = dwUniqueCode;
	int iReduceExp = m_user_data.m_grade_exp * g_RelativeGradeMgr.GetReduceRate() / 100;
	m_user_data.m_grade_exp -= iReduceExp;
	
	SP2Packet kPacket( STPK_UPDATE_RELATIVE_GRADE_EXP );
	kPacket << m_user_relative_grade_data.m_init_code;
	kPacket << m_user_data.m_grade_exp;
	SendMessage( kPacket );
}

void User::OnSendSuperGashponPackage( DWORD dwEtcItemType, DWORD dwPackageIndex, int iUseType )
{
	ioUserEtcItem::ETCITEMSLOT rkSlot;
	m_UserEtcItem.GetEtcItem( dwEtcItemType, rkSlot );
	if( rkSlot.m_iType <= 0 || rkSlot.m_iValue1 <= 0 )
	{
		SP2Packet kPacket( STPK_ETCITEM_USE );
		kPacket << ETCITEM_USE_EXCEPTION;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - pUserEtcItem == NULL.(%d)", __FUNCTION__, dwEtcItemType );
		return;
	}

	rkSlot.AddUse( -1 );
	if( rkSlot.GetUse() <= 0 )
	{
		m_UserEtcItem.DeleteEtcItem( rkSlot.m_iType, LogDBClient::ET_DEL );
	}
	else
	{
		m_UserEtcItem.SetEtcItem( rkSlot );
	}

	if( g_SuperGashaponMgr.SendSuperGashaponPackage( this, dwEtcItemType, dwPackageIndex ) )
	{
		SP2Packet kPacket( STPK_ETCITEM_USE );
		kPacket << ETCITEM_USE_OK;
		kPacket << rkSlot.m_iType;
		kPacket << rkSlot.m_iValue1;
		kPacket << rkSlot.m_iValue2;
		kPacket << (int)SUPER_GASHPON_MAIN;
		kPacket << dwPackageIndex;
		kPacket << iUseType;

		SendMessage( kPacket );
		SendPresentMemory();  // 메모리 선물 전송
	}
	else
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		kReturn << ETCITEM_USE_EXCEPTION;
		SendMessage( kReturn );
	}
}

void User::OnSendSuperGashponSubPackage( DWORD dwEtcItemType, int iUseType )
{
	ioUserEtcItem::ETCITEMSLOT rkSlot;
	m_UserEtcItem.GetEtcItem( dwEtcItemType, rkSlot );
	if( rkSlot.m_iType <= 0 || rkSlot.m_iValue1 <= 0 )
	{
		SP2Packet kPacket( STPK_ETCITEM_USE );
		kPacket << ETCITEM_USE_EXCEPTION;
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - pUserEtcItem == NULL.(%d)", __FUNCTION__, dwEtcItemType );
		return;
	}

	rkSlot.AddUse( -1 );
	if( rkSlot.GetUse() <= 0 )
	{
		m_UserEtcItem.DeleteEtcItem( rkSlot.m_iType, LogDBClient::ET_DEL );
	}
	else
	{
		m_UserEtcItem.SetEtcItem( rkSlot );
	}
	
	DWORD dwSubPackageIndex;
	if( g_SuperGashaponMgr.SendSuperGashaponRandSubPackage( this, dwEtcItemType, dwSubPackageIndex ) )
	{
		SP2Packet kPacket( STPK_ETCITEM_USE );
		kPacket << ETCITEM_USE_OK;
		kPacket << rkSlot.m_iType;
		kPacket << rkSlot.m_iValue1;
		kPacket << rkSlot.m_iValue2;
		kPacket << (int)SUPER_GASHPON_SUB;
		kPacket << dwSubPackageIndex;
		kPacket << iUseType;

		SendMessage( kPacket );
		SendPresentMemory();  // 메모리 선물 전송
	}
	else
	{
		SP2Packet kReturn( STPK_ETCITEM_USE );
		kReturn << ETCITEM_USE_EXCEPTION;
		SendMessage( kReturn );
	}
}

void User::OnSendSuperGashponLimitInfo(  DWORD dwEtcItemType, DWORD dwLimit )
{
	DWORD dwMaxLimit = g_SuperGashaponMgr.GetSuperGashaponPackageLimit( dwEtcItemType );

	SP2Packet kPacket( STPK_DEVELOPER_MACRO );
	kPacket << DEVELOPER_SUPERGASHAPON_LIMIT_INFO_GET;
	kPacket << dwEtcItemType << dwLimit << dwMaxLimit;
	SendMessage( kPacket );
}

void User::OnSubscriptionBuy( SP2Packet &rkPacket )
{
	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Billing Wait : %s:%d:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	short iPresentType   = 0;
	int   iBuyValue1     = 0;
	int   iBuyValue2     = 0;

	rkPacket >> iPresentType;
	rkPacket >> iBuyValue1;
	rkPacket >> iBuyValue2;

	int iPreCash			= GetCash();
	int iPreRealCash		= GetPurchasedCash();
	
	// 청약철회 가능 상품인지 체크
	int iSubscriptionType = g_PresentHelper.GetSubscriptionType( iPresentType, iBuyValue1, iBuyValue2 );
	if( iSubscriptionType != SUBSCRIPTION_TYPE1 )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_DISABLE_SUBSCRIPTION;
		SendMessage( kReturn );
		return;
	}

	int iBuyCash = g_PresentHelper.GetCash( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBuyCash <= 0 )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error : %s:%d:%d:%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iPresentType, iBuyValue1, iBuyValue2 );
		return;
	}

	//kyg 여기에 빌링 체크 지원 하는지 안하는지 하는 함수 
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
		return;
	}

	// 청약상품 보관 가능 갯수 체크
	int iRecvPresentCnt = m_UserSubscription.GetSubscriptionDataCnt();
	if( iRecvPresentCnt >= g_PresentHelper.GetCanSubscriptionCnt() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Exeed subscription cnt : %s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iRecvPresentCnt );
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_EXCEED_PRESENT_CNT;
		SendMessage( kReturn );
		return;
	}

	/*static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_SUBSCRIPTION_BUY, SUBSCRIPTION_BUY_WANT_OF_CASH, iPresentType, vConsumeInfo ) )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		return;
	}
*/
	_OnDBSubscriptionBuy( GetUserIndex(), GetPrivateID().c_str(), iPresentType, iBuyValue1, iBuyValue2 );

	//LogCashItemBuyInfo(iBuyCash, iPreCash, iPreRealCash, GetCash(), GetPurchasedCash(), iPresentType, iBuyValue1, iBuyValue2);
}

//HRYOON BONUS CASH 위메이드 인경우 청약철회?
//청약철회 되는 아이템 구매시에만 여기로 들어온다. 
void User::_OnDBSubscriptionBuy( DWORD dwRecvUserIndex, const char *szRecvPrivateID, short iPresentType, int iBuyValue1, int iBuyValue2 )
{
	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Billing Wait : %s:%d:%s", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}

	int iBuyCash = g_PresentHelper.GetCash( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBuyCash <= 0 )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error : %s:%d:%d:%d:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iPresentType, iBuyValue1, iBuyValue2 );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		return;
	}

	//HRYOON BONUS CASH 사용 가능 여부 파악
	//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();
	int iItemPrice = iBuyCash;

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_SUBSCRIPTION_BUY, SUBSCRIPTION_BUY_WANT_OF_CASH, iPresentType, vConsumeInfo ) )
	{
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );
		return;
	}

	//구매가 가능한데..
	bool bBonusCash = false;
	int iSize	= vConsumeInfo.size();
	int iSpendBonusCash	= 0;

	for( int i = 0; i < iSize; i++ )
		iSpendBonusCash += vConsumeInfo[i].value2;

	//보너스 캐쉬로 구매 가능 
	if( iSpendBonusCash >= iItemPrice )
		bBonusCash = true;

	//실캐시도 함께 쓰겠다는 것
	if( iItemPrice != iSpendBonusCash )
	{
		iBuyCash = iItemPrice - iSpendBonusCash;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << iItemPrice;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;

		PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
		for( int i = 0; i < iSize; i++ )
		{
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		kBillingPacket << OUTPUT_CASH_SUBSCRIPTION;
		kBillingPacket << iPresentType;
		kBillingPacket << iBuyValue1;
		kBillingPacket << iBuyValue2;

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_SUBSCRIPTION_BUY, SUBSCRIPTION_BUY_BILLING_FAIL, NULL, NULL ) )
		{
			SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
			kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
			SendMessage( kReturn );

			ClearBillingGUID();
			return;
		}

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->FillRequestOutputCash( this, kBillingPacket, szRecvPrivateID );

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s:%d:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
		
			SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
			kReturn << SUBSCRIPTION_BUY_BILLING_DISCONNECT;
			SendMessage( kReturn );
		
			ClearBillingGUID();
			return;
		}
	}
	else
	{


		if( bBonusCash )
		{

			// 구매한 상품
			if( !g_PresentHelper.InsertUserSubscription( this, GetPublicIP(), 0, iSpendBonusCash, iPresentType, iBuyValue1, iBuyValue2 ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), 0, iBuyCash, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
		



				SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
				kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
				SendMessage( kReturn );



				return;
			}


			enum { SELECT_CNT = 30, };


			_OnSelectSubscription( SELECT_CNT );

	
			SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
			kReturn << SUBSCRIPTION_BUY_SUCCESS;
			kReturn << GetMoney();
			kReturn << GetCash();
			kReturn << GetPurchasedCash();
			kReturn << GetChannelingCash();
			kReturn << GetPublicIP() << 0;
			kReturn << iPresentType << iBuyValue1 << iBuyValue2;
			SendMessage( kReturn );


			if(m_szBillingGUID.IsEmpty())
			{
				char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
				Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
				m_szBillingGUID = szTempGUID;
			}

			for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
			{
				//보너스 캐쉬 사용.
				if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, iPresentType, iBuyValue1, iBuyValue2) )
				{
					SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );

					PACKET_GUARD_VOID( kReturn.Write(SUBSCRIPTION_BUY_BILLING_FAIL) );

					SendMessage( kReturn );
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error-guid:%s,userIndex:%d,PublicID:%s:index:%d,money:%d:ClassType:%d", __FUNCTION__, GetBillingGUID().c_str(),GetUserIndex(), GetPublicID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2, iPresentType );

				}
			}
		
			ClearBillingGUID();
			//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
			g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);
		}
		else
		{


			SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
			kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail BonusCash Shortage : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), 0, iBuyCash, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
			return;
		}
	}
	//[HRYOON구매] 유저 구매 중인 상태로 변경함
	SetOutputStatus( true );
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::_OnDBSubscriptionBuy Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
}


void User::_OnBillingOutputCashSubscription( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID, ioHashString szSubscriptionID )
{
	int iSubscriptionGold = iPayAmt;

	short iPresentType = 0;
	int   iBuyValue1   = 0;
	int   iBuyValue2   = 0;
	int iSubscriptionState = 0;

	rkPacket >> iPresentType;	
	rkPacket >> iBuyValue1;
	rkPacket >> iBuyValue2;

	ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	int iBuyCash = g_PresentHelper.GetCash( iPresentType, iBuyValue1, iBuyValue2 );
	if( iBuyCash <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Wrong : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), GetCash(), iBuyCash );
		
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );

		ClearBillingGUID();
		return;
	}


	if( iBuyCash != iReturnItemPrice )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Different : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );

		ClearBillingGUID();
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_SUBSCRIPTION_BUY, SUBSCRIPTION_BUY_BILLING_FAIL ) )
		{
			SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
			kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
			SendMessage( kReturn );

			// 이것 있어야 하지 않나? KDH
			if( pLocal )
				pLocal->SendRefundCash( this, iTransactionID, true );
			ClearBillingGUID();
			return;
		}
	}


	int iSize			= 0;
	int iConsumeValue	= 0;
	//HRYOON 보너스 캐쉬 사용
	PACKET_GUARD_VOID( rkPacket.Read(iSize) );
	for( int i = 0; i < iSize; i++ )
	{
		int iIndex	= 0;
		int iValue	= 0;

		PACKET_GUARD_VOID( rkPacket.Read(iIndex) );
		PACKET_GUARD_VOID( rkPacket.Read(iValue) );

		iConsumeValue += iValue;
		//보너스 캐쉬 사용!

		if( !m_UserBonusCash.SpendBonusCash(iIndex, iValue, iPresentType, iBuyValue1, iBuyValue2) )
		{
			
			SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
			kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error-guid:%s,userIndex:%d,PublicID:%s:index:%d,money:%d:ClassType:%d", __FUNCTION__, GetBillingGUID().c_str(),GetUserIndex(), GetPublicID().c_str(), iIndex, iValue, iPresentType );
			
		}
	}

	//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);

	// 구매한 상품
	if( !g_PresentHelper.InsertUserSubscription( this, szSubscriptionID, iSubscriptionGold, iConsumeValue, iPresentType, iBuyValue1, iBuyValue2 ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
		
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );

		ClearBillingGUID();
		return;
	}

	enum { SELECT_CNT = 30, };

	_OnSelectSubscription( SELECT_CNT );

	int iPreCash = GetCash();
	int iPrePurchasedCash = GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %s:%s:%d:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash );
		
		SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
		kReturn << SUBSCRIPTION_BUY_BILLING_FAIL;
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );

		ClearBillingGUID();
		return;
	}

	
	////////////


	SP2Packet kReturn( STPK_SUBSCRIPTION_BUY );
	kReturn << SUBSCRIPTION_BUY_SUCCESS;
	kReturn << GetMoney();
	kReturn << GetCash();
	kReturn << GetPurchasedCash();
	kReturn << GetChannelingCash();
	kReturn << szSubscriptionID << iSubscriptionGold;
	kReturn << iPresentType << iBuyValue1 << iBuyValue2;
	SendMessage( kReturn );

	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%d:%d:%d", iPresentType, iBuyValue1, iBuyValue2 ); // 스트링 형식 수정 불가, DB에서 파싱해서 사용함.


	g_LogDBClient.OnInsertCashItem( this, iBuyValue1, iBuyValue2, iPayAmt, szItemIndex, (LogDBClient::CashItemType)iPresentType, GetBillingGUID().c_str() );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );
	
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnBillingOutputCashSubscription SUCCESS : userID:%s, Guid:%s, UsedCash:%d, ItemPrice:%d, ItemType:%d, ItemValue1:%d, ItemValue2:%d", 
		GetPrivateID().c_str(), GetBillingGUID().c_str(), iPayAmt, iBuyCash, iPresentType, iBuyValue1, iBuyValue2 );

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPrePurchasedCash, GetCash(), GetPurchasedCash(), iPresentType, iBuyValue1, iBuyValue2);
}

void User::_OnSelectSubscription( DWORD dwSelectCount )
{
	g_DBClient.OnSelectSubscriptionData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), m_UserSubscription.GetLastSubscriptionDBIndex(), dwSelectCount );
}

void User::OnSubscriptionRecv( SP2Packet &rkPacket )
{
	SP2Packet kPacket( STPK_SUBSCRIPTION_RECV );
    m_UserSubscription.SubscriptionRecv( rkPacket, kPacket );
    SendMessage( kPacket );
}

void User::OnSubscriptionRetrCheck( SP2Packet &rkPacket )
{
	DWORD dwDBIndex;
	ioHashString szSubscriptionID;
	rkPacket >> dwDBIndex;
	rkPacket >> szSubscriptionID;

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 1;
		SendMessage( kPacket );
		return;
	}

	if( !m_UserSubscription.CheckExistSubscriptionData( dwDBIndex, szSubscriptionID ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_NONE_ITEM;
		SendMessage( kPacket );
		return;
	}

	// 기한 체크
	if( !m_UserSubscription.CheckLimitData( dwDBIndex, szSubscriptionID ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_LIMIT_DATE;
		SendMessage( kPacket );
		return;
	}

	if ( !pNode->IsSubscriptionRetractCheck() )
	{
		if( pNode->IsSubscrptionRetract() )
		{
			SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
			PACKET_GUARD_VOID( kPacket.Write(SUBSCRIPTION_RETR_CHECK_NOT_SUPPORTED) );
			PACKET_GUARD_VOID( kPacket.Write(dwDBIndex) );
			PACKET_GUARD_VOID( kPacket.Write(szSubscriptionID) );
			SendMessage( kPacket );
		}
		else
		{
			SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
			PACKET_GUARD_VOID( kPacket.Write(SUBSCRIPTION_RETR_NOT_SUPPORTED) );
			SendMessage( kPacket );
		}
		return;
	}

	// 청약 철회 조회
	if( !CheckSubscriptionRetr( rkPacket, dwDBIndex, szSubscriptionID ) )
		return;
}

void User::OnSubscriptionRetr( SP2Packet &rkPacket )
{
	DWORD dwDBIndex;
	ioHashString szSubscriptionID;
	rkPacket >> dwDBIndex;
	rkPacket >> szSubscriptionID;

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_EXCEPTION << 2;
		SendMessage( kPacket );
		return;
	}

	if( !m_UserSubscription.CheckExistSubscriptionData( dwDBIndex, szSubscriptionID ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_NONE_ITEM;
		SendMessage( kPacket );
		return;
	}

	// State 체크
	if( !m_UserSubscription.CheckSubscriptionState( dwDBIndex, szSubscriptionID ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_FAIL_STATE;
		SendMessage( kPacket );
		return;
	}

	// 기한 체크
	if( !m_UserSubscription.CheckLimitData( dwDBIndex, szSubscriptionID ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_LIMIT_DATE;
		SendMessage( kPacket );
		return;
	}

	m_UserSubscription.SetSubscriptionState( dwDBIndex, szSubscriptionID, ioUserSubscription::SUBSCRIPTION_STATE_RETRACT_WAIT );

	// 청약 철회 시작
	if( !SetSubscriptionRetr( dwDBIndex, szSubscriptionID ) )
		return;
}

void User::AddSubscriptionMemory( const ioHashString &szSubscriptionID, int iSubscriptionGold,
								  short iPresentType, int iPresentValue1, int iPresentValue2,
								  CTime &rkLimitTime )
{
	m_UserSubscription.AddSubscriptionMemory( GetUserIndex(), szSubscriptionID, iSubscriptionGold,
											  iPresentType, iPresentValue1, iPresentValue2,
											  rkLimitTime );
}

void User::SendSubscriptionMemory()
{
	m_UserSubscription.SendSubscriptionMemory();
}

void User::LogoutMemorySubscriptionInsert()
{
	m_UserSubscription.LogoutMemorySubscriptionInsert();
}

bool User::CheckSubscriptionRetr( SP2Packet &rkPacket, DWORD dwIndex, const ioHashString& szSubscriptionID )
{
	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;

	SP2Packet kBillingPacket( BSTPK_SUBSCRIPTION_RETRACT_CASH_CHECK );
	kBillingPacket << (int) GetChannelingType();
	kBillingPacket << m_szBillingGUID;
	kBillingPacket << GetUserIndex();
	kBillingPacket << GetPublicID();
	kBillingPacket << GetPrivateID();
	kBillingPacket << dwIndex;
	kBillingPacket << szSubscriptionID;

	int iGold	= m_UserSubscription.GetDBRetractGold(dwIndex, szSubscriptionID);
	int iBonusCash	= m_UserSubscription.GetUsedBonusCash(dwIndex, szSubscriptionID);

	if( iBonusCash != 0 )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 2;
		SendMessage( kPacket );

		ClearBillingGUID();
		return false;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 2;
		SendMessage( kPacket );

		ClearBillingGUID();
		return false;
	}

	if( !pNode->AddReuestSubscriptionRetractCashCheckPacket( this, kBillingPacket ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 3;
		SendMessage( kPacket );

		ClearBillingGUID();
		return false;
	}

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
		pLocal->FillSubscriptionRetractCash( this, kBillingPacket );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{	
		SP2Packet kReturn( STPK_SUBSCRIPTION_RETR_CHECK );
		kReturn << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 4;
		SendMessage( kReturn );

		ClearBillingGUID();
		return false;
	}

	return true;
}

bool User::SetSubscriptionRetr( DWORD dwIndex, const ioHashString& szSubscriptionID )
{
	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;

	SP2Packet kBillingPacket( BSTPK_SUBSCRIPTION_RETRACT_CASH );
	kBillingPacket << (int) GetChannelingType();
	kBillingPacket << m_szBillingGUID;
	kBillingPacket << GetUserIndex();
	kBillingPacket << GetPublicID();
	kBillingPacket << GetPrivateID();
	kBillingPacket << dwIndex;
	kBillingPacket << szSubscriptionID;

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_EXCEPTION << 3;
		SendMessage( kPacket );

		m_UserSubscription.SetSubscriptionState( dwIndex, szSubscriptionID, ioUserSubscription::SUBSCRIPTION_STATE_NORMAL );
		ClearBillingGUID();
		return false;
	}

	if( !pNode->AddReuestSubscriptionRetractCashPacket( this, kBillingPacket ) )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_EXCEPTION << 4;
		SendMessage( kPacket );

		m_UserSubscription.SetSubscriptionState( dwIndex, szSubscriptionID, ioUserSubscription::SUBSCRIPTION_STATE_NORMAL );
		ClearBillingGUID();
		return false;
	}
	if( GetChannelingType() == CNT_NEXON )//kyg 넥슨은 환불금액까지보내줘야함
	{
		int nGold = GetDBRetractGold(dwIndex,szSubscriptionID);
		kBillingPacket << nGold;
		LOG.PrintTimeAndLog(0,"NexonRetractCash %d",nGold);
	}
	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
		pLocal->FillSubscriptionRetractCash( this, kBillingPacket );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{	
		SP2Packet kReturn( STPK_SUBSCRIPTION_RETR );
		kReturn << SUBSCRIPTION_RETR_EXCEPTION << 5;
		SendMessage( kReturn );

		m_UserSubscription.SetSubscriptionState( dwIndex, szSubscriptionID, ioUserSubscription::SUBSCRIPTION_STATE_NORMAL );
		ClearBillingGUID();
		return false;
	}

	return true;
}

void User::OnBillingSubscriptionRetractCheck( SP2Packet& rkPacket )
{
	ioHashString szBillingGUID;
	PACKET_GUARD_VOID( rkPacket.Read(szBillingGUID) );

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingSubscriptionRetractCheck BillingGUID Is Empty: %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );

		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 5;
		ClearBillingGUID();
		SendMessage( kPacket );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingSubscriptionRetractCheck Wrong BillingGUID : %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );	 

		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 6;
		ClearBillingGUID();
		SendMessage( kPacket );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( pNode )
	{
		rkPacket.SetPosBegin();

		if( !pNode->OnReceiveSubscriptionRetractCashCheck( this, rkPacket, STPK_SUBSCRIPTION_RETR, SUBSCRIPTION_RETR_CHECK_EXCEPTION ) )
		{
			ClearBillingGUID();

			SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
			kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 7;
			SendMessage( kPacket );
			return;
		}
	}
	else
	{
		ClearBillingGUID();

		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR_CHECK );
		kPacket << SUBSCRIPTION_RETR_CHECK_EXCEPTION << 8;
		SendMessage( kPacket );
		return;
	}
}

void User::OnBillingSubscriptionRetract( SP2Packet& rkPacket )
{
	ioHashString szBillingGUID;
	DWORD		 dwIndex = 0;
	ioHashString szSubscriptionID;

	PACKET_GUARD_VOID( rkPacket.Read(szBillingGUID) );
	PACKET_GUARD_VOID( rkPacket.Read(dwIndex) );
	PACKET_GUARD_VOID( rkPacket.Read(szSubscriptionID) );

	m_UserSubscription.SetSubscriptionState( dwIndex, szSubscriptionID, ioUserSubscription::SUBSCRIPTION_STATE_NORMAL );

	if( szBillingGUID.IsEmpty() )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_EXCEPTION << 6;
		SendMessage( kPacket );

		ClearBillingGUID();

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingSubscriptionRetract BillingGUID Is Empty: %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_EXCEPTION << 7;
		SendMessage( kPacket );

		ClearBillingGUID();

		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingSubscriptionRetract Wrong BillingGUID : %s(%d):%s:%s", GetPublicID().c_str(), GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str() );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		SP2Packet kPacket( STPK_SUBSCRIPTION_RETR );
		kPacket << SUBSCRIPTION_RETR_EXCEPTION << 8;
		SendMessage( kPacket );

		ClearBillingGUID();
		return;
	}

	rkPacket.SetPosBegin();
	pNode->OnReceiveSubscriptionRetractCash( this, rkPacket, STPK_SUBSCRIPTION_RETR, SUBSCRIPTION_RETR_EXCEPTION ); //kyg 패킷 채워야 할 부분 
}

void User::OnSubscriptionRequest( SP2Packet &rkPacket )
{
	DWORD dwRequestCount;
	rkPacket >> dwRequestCount;

	_OnSelectSubscription( dwRequestCount );
}

void User::SetSubscriptionRetract(const DWORD dwIndex, const ioHashString& szSubscriptionID, int iGold, SP2Packet& kPacket, bool bDefaultGold)
{
	m_UserSubscription.SubscriptionRetr( dwIndex, szSubscriptionID, iGold, kPacket, bDefaultGold );
}

void User::SetRetractGold( const DWORD dwIndex, const ioHashString& szSubscriptionID, int iGold )
{
	m_UserSubscription.SetRetractGold( dwIndex, szSubscriptionID, iGold );
}

int User::GetSubscriptionGold( const DWORD dwIndex, const ioHashString& szSubscriptionID )
{
	return m_UserSubscription.GetSubscriptionGold( dwIndex, szSubscriptionID );
}

int User::GetRetractGold( const DWORD dwIndex, const ioHashString& szSubscriptionID )
{
	return m_UserSubscription.GetRetractGold( dwIndex, szSubscriptionID );
}

void User::OnSessionControl( SP2Packet& rkPacket )
{
	int controlType = 0;
	ioHashString chanNo; //다른 패킷들과 공통와 위해서 체널링 아이디가 들어가게됨 

	rkPacket >> chanNo;

	PACKET_GUARD_VOID( rkPacket.Read(controlType) );


	switch(controlType)
	{
	case NexonOnPCRoom:
		{
			OnNexonPCRoom(rkPacket);
		}
		break;
	case NexonUnknownShutDown:
	case NexonShutDown://kyg 코드 정리 
		{
			SendShutDown(rkPacket);
		}
		break;
	case NexonSelctShutdown: //STPK_SELECT_SHUT_DOWN_USER //코드정리
		{
			SendSelectUserShutDown(rkPacket);
		}
		break;
	default:
		OnNexonTerminateMessage(rkPacket,controlType);
		break;
	}

	

	LOG.PrintTimeAndLog(0,"[info[user]ControlType : [%d]", controlType);
}

void User::SendShutDown(SP2Packet& rkPacket)
{
	int errCode = 0;
	DWORD time = 0;
	bool bExitUser = true;

	SetShutDownUser(true);

	rkPacket >> errCode;
	rkPacket >> time;
	rkPacket >> bExitUser;

	SP2Packet pk(STPK_SHUT_DOWN_USER);

	pk << true; //무조건 셧다운임 
	pk << true; // 

	SendMessage(pk);

	LOG.PrintTimeAndLog(0,"Nexon ShutDown[%s::%s]",GetPublicID().c_str(),GetPrivateID().c_str());
}

void User::SendSelectUserShutDown(SP2Packet& rkPacket)
{
	int errCode = 0;
	DWORD time = 0;
	bool bNow = false;

	rkPacket >> errCode;
	rkPacket >> time;
	rkPacket >> bNow;

	int iYear  = (int)(( time % 100000000 ) / 1000000 ) + 2000; //넥슨에서 13이런식으로오니까 2013으로 ..
	int iMonth    = (int)(( time % 1000000 ) / 10000 );
	int iDay   = (int)(( time % 10000 ) / 100 );
	int iHour = (int)(time % 100 );

	SP2Packet pk(STPK_SELECT_SHUT_DOWN_USER);

	PACKET_GUARD_VOID( pk.Write(bNow) ); //정상 로그인때 보내주는데 종료는 안시키면 될듯
	PACKET_GUARD_VOID( pk.Write(iYear) );
	PACKET_GUARD_VOID( pk.Write(iMonth) );
	PACKET_GUARD_VOID( pk.Write(iDay) );
	PACKET_GUARD_VOID( pk.Write(iHour) );
	PACKET_GUARD_VOID( pk.Write(00) );

	DBTIMESTAMP dts = { iYear, iMonth, iDay, iHour, 0, 0, 0, };

	m_UserSelectShutDown.SetSelectShutDown( 1, dts );

	SendMessage(pk);

	LOG.PrintTimeAndLog(0,"Nexon NexonSelectShutDown[%s::%s][Time:%d:%d:%d:%d]",GetPublicID().c_str(),GetPrivateID().c_str(),iYear,iMonth,iDay,iHour);
}

void User::SendSessionLogin()
{
	LOG.PrintTimeAndLog(0,"[info][user]Send session login info : [%lu]", GetUserIndex());

	SP2Packet pk(BSTPK_SESSION_CONTROL);

	ioHashString publicIP = GetPublicIP();
	ioHashString privateIP = GetPrivateIP();
	ioHashString privateID = GetPrivateID();
	ioHashString chanID = GetChannelingUserNo();
 
	PACKET_GUARD_VOID( pk.Write(NexonSessionLogin) );
	PACKET_GUARD_VOID( pk.Write(GetChannelingType()) );
	PACKET_GUARD_VOID( pk.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( pk.Write(chanID) );
	PACKET_GUARD_VOID( pk.Write(publicIP) );
	PACKET_GUARD_VOID( pk.Write(privateIP) );
	PACKET_GUARD_VOID( pk.Write(privateID));
	PACKET_GUARD_VOID( pk.Write(g_ServerNodeManager.GetServerIndex()));

	if(!g_BillingRelayServer.SendMessage(pk))
	{
		LOG.PrintTimeAndLog(0,"%s Error",__FUNCTION__);
	}

	InsertLoginRecord();
}

void User::SendSessionLogout()
{
	if(GetUserIndex() != 0)
	{
		LOG.PrintTimeAndLog(0,"[info][user]Send session logout : [%d]", GetUserIndex());

		SP2Packet pk(BSTPK_SESSION_CONTROL);

		PACKET_GUARD_VOID( pk.Write(NexonSessionLogout) );
		PACKET_GUARD_VOID( pk.Write(GetChannelingType()) );
		PACKET_GUARD_VOID( pk.Write(GetUserIndex()) );
		PACKET_GUARD_VOID( pk.Write(GetChannelingUserNo()) );
		PACKET_GUARD_VOID( pk.Write(GetPrivateID()) );
		PACKET_GUARD_VOID( pk.Write(g_ServerNodeManager.GetServerIndex()));

		if(!g_BillingRelayServer.SendMessage(pk))
		{
			LOG.PrintTimeAndLog(0,"%s Error",__FUNCTION__);
		}

	}
}

int User::GetDBRetractGold( const DWORD dwIndex, const ioHashString& szSubscriptionID )
{
	return m_UserSubscription.GetDBRetractGold( dwIndex, szSubscriptionID );
}

void User::OnNexonTerminateMessage( SP2Packet& rkPacket, int controlType )
{
	int errCode = 0;
	int time = 0;

	rkPacket >> errCode;
	rkPacket >> time;

	SP2Packet pk(STPK_SESSION_CONTROL);

	pk << controlType;
	pk << time;

	SendMessage(pk);

	LOG.PrintTimeAndLog(0,"controID[%d][%s]Meesage %d",controlType,GetPrivateID().c_str(),time);
}

void User::OnNexonPCRoom( SP2Packet& rkPacket )
{ 
	rkPacket >> m_dwPCRoomNumber;
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]OnNexonPCRoom PCRoom Index : [%d] [%d]", GetUserIndex(), m_dwPCRoomNumber );

	if( g_EventMgr.IsAlive( EVT_FREEDAY_HERO, GetChannelingType() ) )
	{
		if( GetPCRoomNumber() == 0 )
			SendFreeDayEvent(FREEDAY_EVENT_CODE);
	}
	else
	{
		if( GetPCRoomNumber() == FREEDAY_EVENT_CODE )
			SendFreeDayEvent(0);
	}

	// 접속 완료 되었으면 유저에게 즉시 알림
	if( IsConnectProcessComplete() && m_bSendCheckPCRoom == false )
	{
		m_bSendCheckPCRoom = true;

		SP2Packet kPacket( STPK_PCROOM_AUTHORITY );
		PACKET_GUARD_VOID( kPacket.Write( GetPCRoomNumber() ) );
		PACKET_GUARD_VOID( kPacket.Write( m_UserPcRoom.GetPcRoomCharMax() ) );
		SendMessage( kPacket );

		InsertLoginPcRoom(LogDBClient::RCT_PCROOM);

		
		GivePCRoomRodAndBait();
	}

	LOG.PrintTimeAndLog( 0, "[info][user]Nexon pcroom user : [%s] [%s] [%d]", GetPublicID().c_str(), GetPublicIP(), m_dwPCRoomNumber ); 
}

void User::InsertLoginPcRoom(int recordType)
{
	if( recordType == LogDBClient::RCT_PCROOM)
	{
		m_cLoginTime = CTime::GetCurrentTime();

		g_LogDBClient.OnInsertRecordInfo( this, 0, (LogDBClient::RecordTypes)recordType );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PCROOM, this, 0, 0, IsEntryFormality(), GetPCRoomNumber(), 0, 0, 0, NULL);
	}
}

void User::OnPcRoomCharCreate( SP2Packet &packet )
{
	// 상점 블럭
	if( IsCharCreating() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s block", __FUNCTION__, GetPublicID().c_str() );

		// 레벨업 보상 지급중이다 완료시까지 용병 구매 불가
		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_FAIL_WORKING ) );
		SendMessage( kReturn );
		return;
	}

	// 빌링응답을 기다리는 중
	if( IsBillingWait() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s Billing Wait %s", __FUNCTION__, GetPublicID().c_str(), m_szBillingGUID.c_str() );

		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_BILLING_WAIT ) );
		SendMessage( kReturn );
		return;
	}

	if( !IsPCRoomAuthority() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s Not Pcroom User", __FUNCTION__, GetPublicID().c_str() );

		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	if( !IsBuyExerciseChar( EXERCISE_PCROOM ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s Wrong Mode %d", __FUNCTION__, GetPublicID().c_str() , GetPlayingMode() );
		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
		SendMessage( kReturn );
		return;
	}

	if( !g_ExerciseCharIndexMgr.IsHave() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s Don't have index", __FUNCTION__, GetPublicID().c_str() );
		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_FAIL_MAKE_INDEX ) );
		SendMessage( kReturn );
		return;
	}

	int iCount = 0;
	bool bWait = false, bOneChar = false;
	PACKET_GUARD_VOID( packet.Read(bWait) );
	PACKET_GUARD_VOID( packet.Read(bOneChar) );
	PACKET_GUARD_VOID( packet.Read(iCount) );
	MAX_GUARD(iCount, 50);

	int iCharDel = 0;
	int iCharCount = 0;
	static PcRoomCharInfoVec InfoVec;
	InfoVec.clear();

	LOOP_GUARD();
	for( int i = 0; i < iCount; ++i )
	{
		PcRoomCharInfo Info;
		PACKET_GUARD_VOID( packet.Read(Info.m_iClassType) );
		PACKET_GUARD_VOID( packet.Read(Info.m_bCharDelete) );

		if( Info.m_iClassType != 0 )
		{
			if( !g_ItemPriceMgr.IsActivePcRoomHero(Info.m_iClassType) )
			{
				SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
				PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EVENT_END ) );
				SendMessage( kReturn );
				return;
			}

			DWORD dwSetItemCode = Info.m_iClassType + SET_ITEM_CODE;
			const ioSetItemInfo *pSetInfo = g_SetItemInfoMgr.GetSetInfoByCode( dwSetItemCode );
			if( !pSetInfo )
			{
				// 잘못된 세트 값
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s 잘못된 세트 값을 보냈다 = %d", __FUNCTION__, GetPublicID().c_str(), Info.m_iClassType );
				SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
				PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
				SendMessage( kReturn );
				return;
			}

			// 고용중인 용병이면 체험 용병 불가 - 대여 용병은 PC방 용병과 별개 - 이벤트 용병과도 별개(2013/8/13일 창섭씨와 협의)
			if( IsBuyActiveChar( Info.m_iClassType ) || 
				IsClassTypeExerciseStyle( Info.m_iClassType, EXERCISE_RENTAL ) ||
				IsClassTypeExerciseStyle( Info.m_iClassType, EXERCISE_EVENT ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s 이미 보유하고 있는 용병 구매 요청 = %d", __FUNCTION__, GetPublicID().c_str(), Info.m_iClassType );
				//
				SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
				PACKET_GUARD_VOID( kReturn.Write( EXERCISE_CHAR_CREATE_EXCEPTION ) );
				SendMessage( kReturn );
				return;
			}
			iCharCount++;
		}

		if( Info.m_bCharDelete )
			iCharDel++;

		InfoVec.push_back( Info );
	}
	LOOP_GUARD_CLEAR();

	//PC방 체험용병 리스트의 객수가 0이거나 지정된 갯수를 초과 했을
	int iExcercisePCRoomCharMax = m_UserPcRoom.GetPcRoomCharMax();
	if( iCount == 0 || iExcercisePCRoomCharMax < iCount )
	{		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s char count error", __FUNCTION__, GetPublicID().c_str() );

		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_PCROOM_CHAR_MAX ) );
		SendMessage( kReturn );
		return;
	}

	int iDeleteExcerciseCnt = GetExerciseCharCount( EXERCISE_GENERAL ) + m_UserPcRoom.GetDeleteCount( InfoVec ); //제거 될 체험 용병 수
	int iAddCount = iCharCount - m_UserPcRoom.GetHasCount( InfoVec );

	//PC방 체험 용병을 넣을 슬롯이 없으면 안됨	 : 총 캐릭 갯수 - 제거될 체험 용병 갯수 - 기간이 만료되어 삭제 될 용병 갯수 + 추가 될 용병 갯수 >= 용병 슬롯 갯수
	int iNextCharCount = GetCharCount() - iDeleteExcerciseCnt - iCharDel + iAddCount;
	if( iNextCharCount > m_iCurMaxCharSlot )
	{		
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s - %s 빈 슬롯이 없음 - %d(%d - %d - %d + %d) > %d ", __FUNCTION__, GetPublicID().c_str(), iNextCharCount, GetCharCount(), iDeleteExcerciseCnt, iCharDel, iAddCount, m_iCurMaxCharSlot );

		SP2Packet kReturn( STPK_EXERCISE_PCROOM_CHAR_CREATE );
		PACKET_GUARD_VOID( kReturn.Write( EXERCISE_PCROOM_CHAR_MAX ) );
		SendMessage( kReturn );
		return;
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][user]%s - %s 생성 가능 - %d(%d - %d - %d + %d) <= %d ", __FUNCTION__, GetPublicID().c_str(), iNextCharCount, GetCharCount(), iDeleteExcerciseCnt, iCharDel, iAddCount, m_iCurMaxCharSlot );
	}

	DeleteExerciseChar( EXERCISE_GENERAL );
	DeleteExpiredChar( InfoVec ); //기간이 만료된 시간제 용병 제거
	FixSelectChar();

	m_UserPcRoom.AllocPCRoomChar( this, InfoVec ); //PC방슬롯을 전부 비우고 재할당
	m_UserPcRoom.DeletePCRoomCharBySlot( this );   //PC방슬롯에 할당되지 못한 PC방 캐릭터 삭제
	m_UserPcRoom.CheckNewPcRoomCharSlot( this );   //새로 생성된 PC방 캐릭터들을 캐릭터 슬롯에 할당
	
	int iCharArray = GetCharCount() - 1;
	/*
	if( m_pMyRoom )
	{
		// 챔피언 모드에서는 선택한 피씨방 용병으로 교체를하지 않는다.
		if( m_pMyRoom->GetModeType() != MT_FIGHT_CLUB )
		{			
			SetChangeChar( iCharArray, bWait, m_select_char, MAX_INT_VALUE );
		}
	}
	else if( bOneChar )
	{
		SetChangeChar( iCharArray, bWait, -1, MAX_INT_VALUE );
	}
	*/
	const ioUserPcRoom::PCRoomCharVec& vCharVec = m_UserPcRoom.GetRoomCharVec();

	LOOP_GUARD();
	int iMaxCharCount = vCharVec.size();
	SP2Packet kPacket( STPK_EXERCISE_PCROOM_CHAR_CREATE );
	PACKET_GUARD_VOID( kPacket.Write( EXERCISE_CHAR_CREATE_OK ) );
	PACKET_GUARD_VOID( kPacket.Write( iMaxCharCount ) );
	for( int i = 0; i< iMaxCharCount; ++i )
	{
		ioCharacter* pChar = vCharVec[i];
		if( pChar )
		{
			int iCharIdx  = pChar->GetCharIndex();
			bool bNewChar = m_UserPcRoom.IsNewPcRoomChar( iCharIdx );

			PACKET_GUARD_VOID( kPacket.Write( iCharIdx ) );
			PACKET_GUARD_VOID( kPacket.Write( bNewChar ) );

			if( bNewChar )
				PACKET_GUARD_VOID( kPacket.Write( (CHARACTER)pChar->GetCharInfo() ) );
		}
		else
		{
			PACKET_GUARD_VOID( kPacket.Write( 0 ) );
			PACKET_GUARD_VOID( kPacket.Write( false ) );
		}
	}
	SendMessage( kPacket );
	LOOP_GUARD_CLEAR();	
}

ioCharacter* User::GetPCRoomChar( int iClassType )
{
	ioCharacter* pCharacter = NULL;
	int iArray = GetCharArrayByClass( iClassType );
	if( COMPARE( iArray, 0, GetCharCount() ) )
		pCharacter = m_CharList[iArray];

	if( pCharacter && pCharacter->HasExerciseStyle( EXERCISE_PCROOM ) )
	{
		return pCharacter;
	}

	return NULL;
}

ioCharacter* User::CreatePCRoomChar( int iClassType )
{	
	ioCharacter *pCharacter = AddCharDataToPointer();
	if( !pCharacter )
	{
		LOG.PrintTimeAndLog(0, "%s - PcRoomCreate Failed( Class : %d )", __FUNCTION__, iClassType );
		return NULL;
	}

	CHARACTER kCharInfo;
	kCharInfo.m_class_type = iClassType;

	// 착용중인 아이템이 있으면 아이템 적용
	m_Inventory.GetEquipItemCode( kCharInfo );

	// 착용한 아이템이 없다면 Default 지급
	if( kCharInfo.m_face == -1)
		kCharInfo.m_face = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type );
	if( kCharInfo.m_hair == -1 )
		kCharInfo.m_hair = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
	if( kCharInfo.m_skin_color == -1 )
		kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
	if( kCharInfo.m_hair_color == -1 )
		kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );
	if( kCharInfo.m_underwear == -1 )
		kCharInfo.m_underwear = g_DecorationPrice.GetDefaultDecoCode( kCharInfo.m_sex - 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );

	kCharInfo.m_chExerciseStyle = EXERCISE_PCROOM;

	//Item
	memset( kCharInfo.m_extra_item, 0, sizeof( kCharInfo.m_extra_item ) );

	//캐릭터 기간
	enum { LIMITE_HOUR_EXERCISE_CHAR = 604800, };
	kCharInfo.m_iLimitSecond = LIMITE_HOUR_EXERCISE_CHAR;

	//용병 슬롯 위치
	kCharInfo.m_iSlotIndex = -1;
	pCharacter->SetCharInfo( g_ExerciseCharIndexMgr.Pop() , kCharInfo, this );
	pCharacter->BackUp();

	g_LogDBClient.OnInsertChar( this, iClassType, 0, 0, "", LogDBClient::CT_PCROOM );
	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s %d)%s %d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iClassType );

	if( m_pMyRoom )
		m_pMyRoom->OnModeCharInsert( this, pCharacter );

	return pCharacter;
}

void User::DeleteExpiredPcRoomChar(int iClassType)
{
	if( !IsPCRoomAuthority() )
		return;

	int iArray = GetCharArrayByClass( iClassType );
	if( iArray == -1 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][pcroomchar] none exist pcroom char" );
		return;
	}

	ioCharacter* pInfo	= GetCharacter(iArray);
	if( !pInfo )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][pcroomchar] none exist pcroom char pointer" );
		return;
	}
	
	DWORD dwCharIndex = pInfo->GetCharIndex();
	DeleteExercisePCRoomChar(dwCharIndex);
	//_OnCharDelete(iArray);

	SP2Packet kPacket( STPK_EXPIRED_CHAR_DEL_BY_PCROOM );
	PACKET_GUARD_VOID( kPacket.Write(1) );
	PACKET_GUARD_VOID( kPacket.Write(dwCharIndex) );
	SendMessage(kPacket);
}

void User::DeleteExpiredChar( const PcRoomCharInfoVec& InfoVec )
{
	if( InfoVec.empty() )
		return;

	LOOP_GUARD();
	DWORDVec dwDelVec;
	for( PcRoomCharInfoVec::const_iterator iter = InfoVec.begin(); iter != InfoVec.end(); ++iter )
	{
		const PcRoomCharInfo& rkInfo = *iter;				
		if( !rkInfo.m_bCharDelete )
			continue;

		for( int i = 0; i < GetCharCount(); ++i )
		{
			if( m_CharList[i]->IsActive() )
				continue;

			const CHARACTER rkChar = m_CharList[i]->GetCharInfo();
			if( rkChar.m_class_type == rkInfo.m_iClassType )
			{
				DWORD dwCharDeleteIndex = m_CharList[i]->GetCharIndex();
				_OnCharDelete( i );
				dwDelVec.push_back( dwCharDeleteIndex );

				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s :: CharDelete( %s ) : %d", __FUNCTION__, GetPublicID().c_str(), rkInfo.m_iClassType );
				break;
			}
		}
	}
	LOOP_GUARD_CLEAR();

	LOOP_GUARD();
	int iMaxCount = dwDelVec.size();
	SP2Packet kPacket( STPK_EXPIRED_CHAR_DEL_BY_PCROOM );
	PACKET_GUARD_VOID( kPacket.Write( iMaxCount ) );
	for( int i = 0; i< iMaxCount; ++i )
	{
		PACKET_GUARD_VOID( kPacket.Write( dwDelVec[i] ) );
	}
	SendMessage( kPacket );
	LOOP_GUARD_CLEAR();	
}

void User::OnAttedanceCheck( SP2Packet& rkPacket )
{
	m_UserAttendance.CheckTodayAttendance( rkPacket );
}

void User::InsertLoginRecord(int recordType)
{
	if( m_cLoginTime == 0 || recordType == LogDBClient::RCT_PCROOM)
	{
		m_cLoginTime = CTime::GetCurrentTime();

		g_LogDBClient.OnInsertRecordInfo( this, 0, (LogDBClient::RecordTypes)recordType );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_LOGIN, this, 0, 0, IsEntryFormality(), GetPCRoomNumber(), 0, 0, 0, NULL);
	}
}

void User::InsertLogoutRecord()
{
	CTimeSpan cPlayTime = CTime::GetCurrentTime() - m_cLoginTime;
	g_LogDBClient.OnInsertRecordInfo( this, (int)cPlayTime.GetTotalSeconds(), LogDBClient::RCT_LOGOUT );
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_LOGOUT, this, 0, 0, 0, GetPCRoomNumber(), (int)cPlayTime.GetTotalSeconds(), 0, 0, NULL);
}

void User::OnBillingTimeoutBillingGUID( SP2Packet &rkPacket )
{
	
	ioHashString szBillingGUID;
	DWORD channelingType = 0;
	DWORD eType = 0;
	
	rkPacket.Read( szBillingGUID );
	rkPacket.Read( channelingType );
	rkPacket.Read( eType );

	if( szBillingGUID == GetBillingGUID() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s::%d:%d:%d:%s:%s", "User::OnBillingTimeoutBillingGUID", channelingType, eType, GetUserIndex(), GetPrivateID().c_str(), szBillingGUID.c_str() );
		ClearBillingGUID();
	}
}

//HRYOON 20150102 태국 토큰 복호화 결과 전달
void User::OnBillingDecodeGarenaToken( SP2Packet &rkPacket )
{
	//태국 인경우 처음에 토큰 복호화 할 때만 이 함수 탐
	ioHashString szBillingGUID;
	ioHashString szGarenaUID;
	int          iReturnValue;

	szGarenaUID.Clear();

	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "TEMPLOG-1 User::OnBillingLogin %s:%s", szBillingGUID.c_str(), GetBillingGUID().c_str() );

	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )
	{
		if( szBillingGUID.IsEmpty() )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s BillingGUID Is Empty: :%s:%s", __FUNCTION__,szBillingGUID.c_str(), GetBillingGUID().c_str() );
			SP2Packet kReturn( STPK_TH_GA_ID_REQ );
			kReturn << false << "";
			SendMessage( kReturn );
			ClearBillingGUID();
			return;
		}

		if( GetBillingGUID() != szBillingGUID )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Wrong BillingGUID: %s:%s", __FUNCTION__, szBillingGUID.c_str(), GetBillingGUID().c_str() );
			SP2Packet kReturn( STPK_TH_GA_ID_REQ );
			kReturn << false << "";
			SendMessage( kReturn );
			ClearBillingGUID();
			return;
		}

		if( iReturnValue != BILLING_LOGIN_RESULT_SUCCESS )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s fail BillingGUID: %s:%s", __FUNCTION__, szBillingGUID.c_str(), GetBillingGUID().c_str() );
			SP2Packet kReturn( STPK_TH_GA_ID_REQ );
			kReturn << false << "";
			SendMessage( kReturn );
			ClearBillingGUID();
			return;
		}

		//유저 정보 저장
		ioLocalParent *pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( !pLocal->ApplyLogin( this, rkPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s apply login: GUID:%s", __FUNCTION__, GetBillingGUID().c_str() );
			SP2Packet kReturn( STPK_TH_GA_ID_REQ );
			kReturn << false << "";
			SendMessage( kReturn );
			ClearBillingGUID();
			return;
		}
		//성공
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Success:User ID:%s, GUID:%s", __FUNCTION__, GetPrivateID().c_str(), GetBillingGUID().c_str() );
		SP2Packet kReturn( STPK_TH_GA_ID_REQ );
		kReturn << true <<  GetPrivateID();
		SendMessage( kReturn );
		return;	//아래의 작업은 태국에서 필요 없으니 return 
	}
	ClearBillingGUID();

}

//HRYOON 20150130 가레나 웹 이벤트
void User::OnBillingGarenaWebEvent( SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int          iUserIndex;
	int          iReturnValue;
	DWORD		 dwApiType;			 
	ioHashString szReturnValue;
	dwApiType	= 0;


	rkPacket >> szBillingGUID;
	rkPacket >> iReturnValue;
	rkPacket >> iUserIndex;
	rkPacket >> dwApiType;
	rkPacket >> szReturnValue;

	if( iReturnValue == BILLING_GA_WEB_EVENT_RESULT_FAIL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[WEB_EVENT]User::OnBillingGarenaWebEvent Result Fail TYPE:%d, accountIDX:%d,GUID:%s,msg:%s", dwApiType, iUserIndex, GetBillingGUID().c_str(), szReturnValue.c_str() );
	}
	else
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[WEB_EVENT]User::OnBillingGarenaWebEvent Result Success TYPE:%d, accountIDX:%d,GUID:%s,msg:%s", dwApiType, iUserIndex, GetBillingGUID().c_str(), szReturnValue.c_str() );
	}

	ClearBillingGUID();

}

void User::ClearSelectGashapon()
{
	m_SelectGashaponItem.clear();
}

const SelectGashaponValueVec& User::GetSelectGashapon()
{
	return m_SelectGashaponItem;
}

void User::OnBuySelectGashapon( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s %s Billing Wait %s", __FUNCTION__, GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
		kReturn << BUY_SELECT_GASHAPON_BILLING_WAIT;
		SendMessage( kReturn );
		return;
	}
	
	int iEtcItemType = 0;
	int iSelectCount = 0;
	rkPacket >> iEtcItemType;
	rkPacket >> iSelectCount;

	if( MAX_GASHAPON_SELECT_SLOT < iSelectCount )
	{
		SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
		kReturn << BUY_SELECT_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectGashapon();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - select over flow - %s", __FUNCTION__ , GetPublicID().c_str() );
		return;
	}

	// 체크
	if( iSelectCount == 0 )
	{
		SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
		kReturn << BUY_SELECT_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectGashapon();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - empty -%s", __FUNCTION__ , GetPublicID().c_str() );
		return;
	}

	ClearSelectGashapon();
	for( int i = 0; i < iSelectCount; i++ )
	{
		SelectGashaponValue Value;
		rkPacket >> Value.m_iType;
		rkPacket >> Value.m_iValue1;
		rkPacket >> Value.m_iValue2;
		m_SelectGashaponItem.push_back( Value );
	}
	
	// 중복 체크
	unsigned int iSize = m_SelectGashaponItem.size();
	for( unsigned int i = 0; i < iSize ; i++ )
	{
		for( unsigned int j = 0; j < iSize; j++ )
		{
			if( i != j && m_SelectGashaponItem[i] == m_SelectGashaponItem[j] )
			{
				SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
				kReturn << BUY_SELECT_GASHAPON_EXCEPTION;
				SendMessage( kReturn );
				ClearSelectGashapon();
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - Duplicate -%s", __FUNCTION__ , GetPublicID().c_str() );
				return;
			}
		}
	}
	
	ioEtcItem* pEtcItem = g_EtcItemMgr.FindEtcItem( iEtcItemType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
		kReturn << BUY_SELECT_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectGashapon();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - NULL -%s : %d", __FUNCTION__ , GetPublicID().c_str(), iEtcItemType );
		return;
	}

	if( GetEntryType() == ET_TERMINATION )
	{
		SP2Packet kPacket( STPK_BUY_SELECT_GASHAPON );
		kPacket << BUY_SELECT_GASHAPON_EXCEPTION;
		SendMessage( kPacket );	
		ClearSelectGashapon();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Entry Type Error - %s : %d", __FUNCTION__,GetPublicID().c_str(), GetEntryType() );
		return;
	}

	int iCashArray = iSelectCount-1;
	int iBuyCash = pEtcItem->GetCash( iCashArray );
	if( iBuyCash <= 0 )
	{
		SP2Packet kPacket( STPK_BUY_SELECT_GASHAPON );
		kPacket << BUY_SELECT_GASHAPON_EXCEPTION;
		SendMessage( kPacket );	
		ClearSelectGashapon();
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error - %s(%d) : %d : %d : %d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iEtcItemType, iSelectCount );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
		SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
		kReturn << BUY_SELECT_GASHAPON_EXCEPTION;
		SendMessage( kReturn );
		ClearSelectGashapon();
		return;
	}

	//HRYOON BONUS CASH 사용 가능 여부 파악
	//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	
	bool bBonusCash = false;
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	int iItemPrice = iBuyCash;

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_BUY_SELECT_GASHAPON, BUY_SELECT_GASHAPON_BILLING_WANT_OF_CASH, iEtcItemType, vConsumeInfo ) )
		return;

	int iConsumeSize	= vConsumeInfo.size();

	int iSpendBonusCash	= 0;
	for( int i = 0; i < iConsumeSize; i++ )
		iSpendBonusCash += vConsumeInfo[i].value2;

	//보너스 캐쉬로 구매 가능 
	if( iSpendBonusCash >= iItemPrice )
		bBonusCash = true;

	if( iItemPrice != iSpendBonusCash )
	{
		iBuyCash = iItemPrice - iSpendBonusCash;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << iItemPrice;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;

		PACKET_GUARD_VOID( kBillingPacket.Write(iConsumeSize) );
		for( int i = 0; i < iConsumeSize; i++ )
		{
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		kBillingPacket << OUTPUT_CASH_ETC;
		kBillingPacket << iEtcItemType;
		kBillingPacket << iCashArray;

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_BUY_SELECT_GASHAPON, BUY_SELECT_GASHAPON_BILLING_FAIL, NULL, NULL ) )
		{
			return;
		}

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
		{
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );
		}

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
			kReturn << BUY_SELECT_GASHAPON_BILLING_DISCONNECT;
			SendMessage( kReturn );
			m_szBillingGUID.Clear();
			ClearSelectGashapon();
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );	
		}
	}
	else
	{
		//[HRYOON구매] 유저 구매 중인 상태로 변경함
		SetOutputStatus( true );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnBuySelectGashapon Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );	
		if( bBonusCash )
		{
			pEtcItem->OnAfterBuy( this, rkPacket, iCashArray, 0 );
			ClearSelectGashapon();
			if(m_szBillingGUID.IsEmpty())
			{
				char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
				Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
				m_szBillingGUID = szTempGUID;
			}
			for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
			{
				//보너스 캐쉬 사용.
				if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_ETC_ITEM, iEtcItemType, 0) )
				{
					SP2Packet kReturn( STPK_BUY_SELECT_EXTRA_GASHAPON );
					PACKET_GUARD_VOID( kReturn.Write(BUY_SELECT_EXTRA_GASHAPON_EXCEPTION) );
					SendMessage( kReturn );

					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error : publicID:%s(userIndex:%d)guid:%s, index:%d,money:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2 );
					ClearBillingGUID();

					return;
				}
			}
			ClearBillingGUID();


			//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
			g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);
		}
		else
		{


			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail BonusCash Shortage. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_BUY_SELECT_GASHAPON );
			kReturn << BUY_SELECT_GASHAPON_EXCEPTION;
			SendMessage( kReturn );
		}
		

	}
}

void User::OnPetChange( SP2Packet &rkPacket )
{
	int iPetIndex;
	bool bEquip = false;
	ioUserPet::PETSLOT rkPetSlot;
	
	PACKET_GUARD_VOID( rkPacket.Read( iPetIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( bEquip ) );

	if( m_pMyRoom )
	{
		Mode* pMode = m_pMyRoom->GetModeInfo();
		if( pMode )
		{
			ModeRecord* pRecord = pMode->FindModeRecord(this);
			if( !pRecord )
				return;

			if( m_pMyRoom->IsRoundEndState() || pRecord->bDieState )
			{
				SP2Packet kReturn( STPK_PET_CHANGE );
				PACKET_GUARD_VOID( kReturn.Write( PET_CHANGE_FAIL ) );
				PACKET_GUARD_VOID( kReturn.Write( iPetIndex ) );
				SendMessage( kReturn );
				return;
			}
		}
	}

	if( !bEquip )
	{
		//착용 해제
		if( !m_UserPetItem.ClearPetEquip( iPetIndex ) )
		{
			SP2Packet kReturn( STPK_PET_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write( PET_CHANGE_FAIL ) );
			PACKET_GUARD_VOID( kReturn.Write( iPetIndex ) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s None Pet.[%d/%s](petIndex : %d)", __FUNCTION__ , GetUserIndex(), GetPublicID().c_str(), iPetIndex );
			return;
		}
	}
	else
	{
		if( !m_UserPetItem.EquipPet( iPetIndex, rkPetSlot ) )
		{
			//error 전송
			SP2Packet kReturn( STPK_PET_CHANGE );
			PACKET_GUARD_VOID( kReturn.Write( PET_CHANGE_FAIL ) );
			PACKET_GUARD_VOID( kReturn.Write( iPetIndex ) );
			SendMessage( kReturn );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s slot is wrong.[%d/%s](petIndex : %d)", __FUNCTION__ , GetUserIndex(), GetPublicID().c_str(), iPetIndex );
			return;
		}

		g_LogDBClient.OnInsertPetLog( this, rkPetSlot.m_iIndex, rkPetSlot.m_iPetCode,  rkPetSlot.m_iPetRank, rkPetSlot.m_iCurLevel, rkPetSlot.m_iCurExp, 0, LogDBClient::PDT_EQUIP );
	}

	if(  GetModeType() != MT_NONE && !m_pMyRoom )
	{
		SP2Packet kReturn( STPK_PET_CHANGE );
		PACKET_GUARD_VOID( kReturn.Write( PET_CHANGE_FAIL ) );
		PACKET_GUARD_VOID( kReturn.Write( iPetIndex ) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s position is worng.[%d/%s]", __FUNCTION__ , GetUserIndex(), GetPublicID().c_str() );
		return;
	}

	SP2Packet kReturn( STPK_PET_CHANGE );
	PACKET_GUARD_VOID( kReturn.Write( PET_CHANGE_OK ) );
	PACKET_GUARD_VOID( kReturn.Write( iPetIndex ) );
	PACKET_GUARD_VOID( kReturn.Write( bEquip ) );

	SendMessage( kReturn );
	
	if( m_pMyRoom && !m_pMyRoom->IsRoundEndState() ) 
	{
		//라운드가 안끝났을 경우 펫 정보 전송.
		SP2Packet kReturn( STPK_PET_EQUIP_INFO );
		PACKET_GUARD_VOID( kReturn.Write( GetPublicID() ) );
		PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_iPetCode ) );
		PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_iPetRank ) );
		PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_iCurLevel ) );
		PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_bEquip ) );

		m_pMyRoom->RoomSendPacketTcp( kReturn );
	}
}

void User::OnPetNurture( SP2Packet &rkPacket )
{
	int iPetIndex;
	int iNeedMaterialCount = 0;
	int iMaterialCode = 0;
	ioUserPet::PETSLOT rkPetSlot;

	PACKET_GUARD_VOID( rkPacket.Read( iPetIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( iMaterialCode ) );

	int iResult = m_UserPetItem.PetNurture( this, iPetIndex, iMaterialCode, rkPetSlot, iNeedMaterialCount );
	if( iResult > 1 )
	{
		//실패 패킷 전송
		SP2Packet kPacket( STPK_PET_NURTURE );
		PACKET_GUARD_VOID( kPacket.Write( PET_NURTURE_FAIL ) );
		PACKET_GUARD_VOID( kPacket.Write( iResult ) );
		SendMessage( kPacket );
		return;
	}

	SP2Packet kPacket( STPK_PET_NURTURE );
	PACKET_GUARD_VOID( kPacket.Write( PET_NURTURE_OK ) );
	PACKET_GUARD_VOID( kPacket.Write( rkPetSlot.m_iIndex ) );
	PACKET_GUARD_VOID( kPacket.Write( rkPetSlot.m_iPetRank ) );
	PACKET_GUARD_VOID( kPacket.Write( rkPetSlot.m_iCurLevel ) );
	PACKET_GUARD_VOID( kPacket.Write( rkPetSlot.m_iCurExp ) );
	PACKET_GUARD_VOID( kPacket.Write( iMaterialCode ) );
	PACKET_GUARD_VOID( kPacket.Write( iNeedMaterialCount ) );
		
	SendMessage( kPacket );

	//장착 중인 녀석이 레벨업
	if( iResult != 0 )
	{
		if( m_pMyRoom && !m_pMyRoom->IsRoundEndState() ) 
		{
			//라운드가 안끝났을 경우 펫 레벨업 정보 전송.
			SP2Packet kReturn( STPK_PET_NURTURE_LEVELUP );
			PACKET_GUARD_VOID( kReturn.Write( GetPublicID() ) );
			PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_iPetCode ) );
			PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_iPetRank ) );
			PACKET_GUARD_VOID( kReturn.Write( rkPetSlot.m_iCurLevel ) );

			m_pMyRoom->RoomSendPacketTcp( kReturn );
		}
	}

	SaveAlchemicInventory();
	SavePet();
}

bool User::FillEquipPetData( SP2Packet &rkPacket )
{
	ioUserPet::PETSLOT rkPetSlot;

	if( !m_UserPetItem.GetEquipPetInfo( rkPetSlot ) )
		return false;
	
	PACKET_GUARD_bool( rkPacket.Write(  GetPublicID() ) );
	PACKET_GUARD_bool( rkPacket.Write( rkPetSlot.m_iPetCode ) );
	PACKET_GUARD_bool( rkPacket.Write( rkPetSlot.m_iPetRank ) );
	PACKET_GUARD_bool( rkPacket.Write( rkPetSlot.m_iCurLevel ) );
	PACKET_GUARD_bool( rkPacket.Write( true ) );

	return true;
}

bool User::FillEquipTitleData(SP2Packet &rkPacket)
{
	UserTitleInfo* pInfo = m_TitleInven.GetEquipTitle();
	if( !pInfo )
		return false;

	PACKET_GUARD_bool( rkPacket.Write(GetPublicID()) );
	PACKET_GUARD_bool( rkPacket.Write(pInfo->GetCode()) );
	PACKET_GUARD_bool( rkPacket.Write((BYTE)pInfo->IsPremium()) );
	PACKET_GUARD_bool( rkPacket.Write(pInfo->GetTitleLevel()) );
	
	return true;
}

void User::SetOutPutCashPacket( SP2Packet &rkPacket, const int& iBuyCash, const int& iMachineCode, const int& iType )
{
	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;
	PACKET_GUARD_VOID( rkPacket.Write( (int) GetChannelingType() ) );
	PACKET_GUARD_VOID( rkPacket.Write( m_szBillingGUID ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetUserIndex() ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetPublicID() ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetPrivateID() ) );
	PACKET_GUARD_VOID( rkPacket.Write( GetPublicIP() ) );
	PACKET_GUARD_VOID( rkPacket.Write( iBuyCash ) );
	PACKET_GUARD_VOID( rkPacket.Write( iType ) );
	PACKET_GUARD_VOID( rkPacket.Write( iMachineCode ) );
}

void User::OnPetSell( SP2Packet &rkPacket )
{
	int iPetIndex = 0;
	PACKET_GUARD_VOID( rkPacket.Read( iPetIndex ) );

	if( iPetIndex <= 0 )
	{
		SP2Packet kReturn( STPK_PET_SELL );
		PACKET_GUARD_VOID( kReturn.Write( PET_SELL_FAIL ) ); 
		PACKET_GUARD_VOID( kReturn.Write( 1 ) ); 
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnPetSell Fail - %s) %d don't have value.",  GetPublicID().c_str(), iPetIndex );
		return;
	}

	int iSellPeso = g_PetInfoMgr.GetSellPeso();
	int iPetCode = m_UserPetItem.GetPetCode( iPetIndex );

	if( !m_UserPetItem.DeleteData( iPetIndex ) )
	{
		SP2Packet kReturn( STPK_PET_SELL );
		PACKET_GUARD_VOID( kReturn.Write( PET_SELL_FAIL ) ); 
		PACKET_GUARD_VOID( kReturn.Write( 2 ) ); 
		SendMessage( kReturn );
		return;
	}

	AddMoney( iSellPeso );
	g_LogDBClient.OnInsertPeso( this, iSellPeso, LogDBClient::PT_SELL_PET );
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_PET, PRESENT_PET_ITEM, iPetCode, iSellPeso, NULL);

	//판매 성공 패킷
	SP2Packet kPacket( STPK_PET_SELL );
	PACKET_GUARD_VOID( kPacket.Write( PET_SELL_OK ) );
	PACKET_GUARD_VOID( kPacket.Write( iPetIndex ) );
	//PACKET_GUARD_VOID( kPacket.Write( iSellPeso ) );
	PACKET_GUARD_VOID( kPacket.Write( GetMoney() ) );
	SendMessage( kPacket );

	SaveUserData();
}

void User::OnPetComPound( SP2Packet &rkPacket )
{
	int iTargetIndex;
	int iVictimIndex;
	
	ioUserPet::PETSLOT rkTargetSlot;
	ioUserPet::PETSLOT rkVictimSlot;

	PACKET_GUARD_VOID( rkPacket.Read( iTargetIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( iVictimIndex ) );

	if( !m_UserPetItem.GetPetInfo( iTargetIndex, rkTargetSlot ) )
	{
		SP2Packet kPacket( STPK_PET_COMPOUND );
		PACKET_GUARD_VOID( kPacket.Write( PET_COMPOUND_FAIL ) );
		PACKET_GUARD_VOID( kPacket.Write( 8 ) );
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error: %s User Pet Have None PetIndex:%d.", __FUNCTION__, GetPublicID().c_str(), iTargetIndex );
		return;
	}

	if( !m_UserPetItem.GetPetInfo( iVictimIndex, rkVictimSlot ) )
	{
		SP2Packet kPacket( STPK_PET_COMPOUND );
		PACKET_GUARD_VOID( kPacket.Write( PET_COMPOUND_FAIL ) );
		PACKET_GUARD_VOID( kPacket.Write( 8 ) );
		SendMessage( kPacket );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error: %s User Pet Have None PetIndex:%d.", __FUNCTION__, GetPublicID().c_str(), iVictimIndex );
		return;
	}

	int iResult = g_PetGashaponMgr.PetCompound( this, rkTargetSlot, rkVictimSlot );

	if( iResult != 0 )
	{
		//오류 전송
		SP2Packet kPacket( STPK_PET_COMPOUND );
		PACKET_GUARD_VOID( kPacket.Write( PET_COMPOUND_FAIL ) );
		PACKET_GUARD_VOID( kPacket.Write( iResult ) );
		SendMessage( kPacket );
	}
}

void User::OnPetEquipInfo( SP2Packet &rkPacket )
{
	ioHashString szUserID;

	PACKET_GUARD_VOID( rkPacket.Read( szUserID ) );

	User *pUser = g_UserNodeManager.GetUserNodeByPublicID( szUserID );

	if( !pUser )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s : User NULL.", __FUNCTION__ );
		return;
	}

	SP2Packet kPacket( STPK_PET_EQUIP_INFO );
	if( !pUser->FillEquipPetData( kPacket ) )
			return;

	SendMessage( kPacket );
}

bool User::OnPetEggUse( SP2Packet &rkPacket, bool &bCash, int &iType )
{
	if( !m_UserPetItem.CheckPetHavePossible() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error: %s User PetCount Max.", __FUNCTION__, GetPublicID().c_str() );
		return false;
	}

	ioUserPet::PETSLOT rkPetInfo;
	
	//펫 뽑기 오류 처리
	if( !g_PetGashaponMgr.PickBuyRandomPet( rkPetInfo, bCash ) )
	{
		SP2Packet kPacket( STPK_PET_ADD  );
		PACKET_GUARD_bool( kPacket.Write( PET_HATCH_FAIL ) );
		SendMessage( kPacket );
		return false;
	}

	CQueryData query_data;
	DWORD dwPacketID = STPK_PET_ADD;
	DWORD dwPacketTYpe = PET_HATCH_OK;
	DWORD dwUserIndex = GetUserIndex();

	query_data.SetReturnData( &dwUserIndex, sizeof( DWORD ) );
	//query_data.SetReturnData( GetPublicID().c_str(), ID_NUM_PLUS_ONE );
	query_data.SetReturnData( &dwPacketID, sizeof( DWORD ) );
	query_data.SetReturnData( &dwPacketTYpe, sizeof( DWORD ) );
	query_data.SetReturnData( &iType, sizeof( int ) );


	m_UserPetItem.AddData( rkPetInfo, query_data );
	return true;
}

//각성
void User::SendCharAwakeEndPacket( std::map< int, BYTE > &mAwakeMap )
{
	int iEndCharCount = mAwakeMap.size();
	std::map< int, BYTE >::iterator iter = mAwakeMap.begin();

	SP2Packet kPacket( STPK_DELETE_CHAR_AWAKE_DATE );
	PACKET_GUARD_VOID( kPacket.Write( iEndCharCount ) );

	for(	; iter!=mAwakeMap.end(); iter++  )
	{
		PACKET_GUARD_VOID( kPacket.Write( iter->first ) );
		PACKET_GUARD_VOID( kPacket.Write( iter->second ) );
	}

	SendMessage( kPacket );
}

void User::EraseCharAwakeDataMap( std::map < int, int >::iterator &iter, std::map< int, BYTE > &mAwakePassedDateMap )
{
	int iArray = GetCharArray( iter->first );

	if( iArray == -1 || !COMPARE( iArray, 0, GetCharCount() ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error: ID %s CharIndex %d NULL.", __FUNCTION__, GetPublicID().c_str(), iter->first );
		m_CharAwakeDataMap.erase(iter++ );
		return;
	}

	BYTE chAwakeType = m_CharList[iArray]->GetAwakeType();
	mAwakePassedDateMap.insert( std::make_pair( iter->first, chAwakeType ) );
	m_CharList[iArray]->SetAwakeInit();
	m_CharAwakeDataMap.erase(iter++ );

	return;
}

void User::DeleteCharAwakePassedDate()
{
	std::map< int, BYTE > mAwakePassedDateMap;
	CTime kCurTime = CTime::GetCurrentTime();

	std::map < int, int >::iterator iter = m_CharAwakeDataMap.begin();

	for(	; iter!=m_CharAwakeDataMap.end(); )
	{
		if( iter->second == 0 )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Error EndDate Zero: ID %s CharIndex %d", __FUNCTION__, GetPublicID().c_str(), iter->first );
			EraseCharAwakeDataMap( iter, mAwakePassedDateMap );
			continue;
		}

		CTime kLimitTime = Help::ConvertDateToCTime( iter->second );
		CTimeSpan kRemainTime = kLimitTime - kCurTime;

		if( kRemainTime.GetTotalMinutes() > 0 )
		{
			++iter;
			continue;
		}

		EraseCharAwakeDataMap( iter, mAwakePassedDateMap );
	}

	if( mAwakePassedDateMap.size() > 0 )
	{
		SendCharAwakeEndPacket( mAwakePassedDateMap );
	}
}

void User::SendAwakeFailPacket( BYTE chFailType ) 
{
	SP2Packet kPacket( STPK_CHAR_AWAKE );

	BYTE chPacketType = AWAKE_FAIL;
	PACKET_GUARD_VOID( kPacket.Write( chPacketType ) );
	PACKET_GUARD_VOID( kPacket.Write( chFailType ) );

	SendMessage( kPacket );
}

bool User::IsRightAwakeChange( const int iCharArray, const int iAwakeType )
{
	if( !COMPARE( iCharArray, 0, GetCharCount() ) ) 
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::IsRightAwake Error - Char Array Size Over %s", GetPublicID().c_str() );
		return false;
	}

	int chAwakeType = m_CharList[iCharArray]->GetAwakeType();

	if( chAwakeType != AWAKE_NONE )
	{
		//일반->초월만 가능
		return g_CharAwakeManager.CheckRightAwakeChange( chAwakeType, iAwakeType );	
	}

	return true;
}

bool User::CharAwakeErrorCheck( int iCharArray, int iAwakeType, int iAwakeDay, int &iMaterialCode, int &iMaterialNeedCount )
{
	//영구 용병인지 체크
	if( !IsCharMortmain( iCharArray ) )
	{
		SendAwakeFailPacket(  AWAKE_EXCEPTION  );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeErrorCheck Error - No Mortmain Character UserID %s CharIndex %d", GetPublicID().c_str(), GetCharIndex( iCharArray ) );
		return false;
	}

	// 적절한 각성 일 체크
	if( !g_CharAwakeManager.CheckRightDate( iAwakeDay ) )
	{
		SendAwakeFailPacket(  AWAKE_EXCEPTION );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeErrorCheck Error -  Wrong Awake Day UserID %s AwakeDay %d", GetPublicID().c_str(), iAwakeDay );
		return false;
	}

	// 적절한 각성 변환 체크
	if( !IsRightAwakeChange( iCharArray, iAwakeType )  )
	{
		SendAwakeFailPacket(  AWAKE_EXCEPTION  );
		return false;
	}

	// 적절한 재료 정보 체크
	g_CharAwakeManager.GetMaterialInfo( iAwakeType, iAwakeDay, m_CharList[iCharArray]->GetClassType(), iMaterialCode, iMaterialNeedCount );
	if( iMaterialCode == 0 || iMaterialNeedCount == 0 )
	{
		SendAwakeFailPacket(  AWAKE_EXCEPTION  );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeErrorCheck Error -  Wrong Material" );
		return false;
	}

	// 재료 찾기
	ioAlchemicInventory::AlchemicItem rkMaterialSlot;
	if( !GetAlchemicInventory()->FindAlchemicItem( iMaterialCode, rkMaterialSlot ) )
	{
		SendAwakeFailPacket( AWAKE_NONE_MATERIAL  );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeErrorCheck Error -  Dont Have Material UserID %s MaterialCode %d", GetPublicID().c_str(), iMaterialCode );
		return false;
	}

	// 가지고 있는 재료 수 체크
	if( rkMaterialSlot.m_iCount < iMaterialNeedCount )
	{
		SendAwakeFailPacket( AWAKE_MATERIAL_SHORTAGE   );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeErrorCheck Error -  Dont Have Enought Material Count UserID %s MaterialCode %d MaterialNeedCount %d ", GetPublicID().c_str(), iMaterialCode, iMaterialNeedCount );
		return false;
	}

	return true;
}

int User::GetCalcCharAwakeEndDate( int iAddDay )
{
	CTimeSpan cPresentGapTime( iAddDay, 0, 0, 0 );
	CTime cEndDate = CTime::GetCurrentTime() + cPresentGapTime;

	return Help::ConvertYYMMDDHHMMToDate( cEndDate.GetYear(),
									cEndDate.GetMonth(),
									cEndDate.GetDay(),
									cEndDate.GetHour(),
									cEndDate.GetMinute()
									);
}

void User::OnCharAwake( SP2Packet &rkPacket )
{
	int iCharIndex = 0;
	BYTE chAwakeKind = 0;
	BYTE chAwakeDay = 0;
	int iCharArray = -1;

	PACKET_GUARD_VOID( rkPacket.Read( iCharIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( chAwakeKind ) );
	PACKET_GUARD_VOID( rkPacket.Read( chAwakeDay ) );

	iCharArray = GetCharArray( iCharIndex );
	if( iCharArray == -1 || !COMPARE( iCharArray, 0, GetCharCount()  ) )
	{
		SendAwakeFailPacket(  AWAKE_EXCEPTION );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::OnCharAwake Error - None Have Character UserID %s CharIndex %d", GetPublicID().c_str(), iCharIndex );
		return;
	}

	int iMaterialCode = 0;
	int iMaterialNeedCount = 0;

	//에러 체크
	if( !CharAwakeErrorCheck( iCharArray, chAwakeKind, chAwakeDay, iMaterialCode, iMaterialNeedCount ) )
		return;

	//각성 정보 SET 3
	int iEndDate = GetCalcCharAwakeEndDate( chAwakeDay );
	if( iEndDate == 0 )
		return;

	m_CharList[iCharArray]->SetAwakeInfo( chAwakeKind, iEndDate );
	InsertAwakeDataMap( iCharIndex, iEndDate );

	//재료 삭제 
	if( !GetAlchemicInventory()->UseAlchemicItem( iMaterialCode, iMaterialNeedCount ))
	{
		SendAwakeFailPacket( AWAKE_MATERIAL_SHORTAGE );
		return;
	}

	SP2Packet kPacket( STPK_CHAR_AWAKE );

	BYTE chPacketType = AWAKE_MY_OK;
	short nUseMaterialCount = iMaterialNeedCount;

	PACKET_GUARD_VOID( kPacket.Write( chPacketType ) );
	PACKET_GUARD_VOID( kPacket.Write( iCharIndex ) );
	PACKET_GUARD_VOID( kPacket.Write( chAwakeKind ) );
	PACKET_GUARD_VOID( kPacket.Write( iMaterialCode ) );
	PACKET_GUARD_VOID( kPacket.Write( nUseMaterialCount ) );
	PACKET_GUARD_VOID( kPacket.Write( iEndDate ) );

	SendMessage( kPacket );

	if( m_pMyRoom && !m_pMyRoom->IsRoundEndState() ) 
	{
		BYTE chPacketType = AWAKE_OTHER_OK;

		SP2Packet kPacket2( STPK_CHAR_AWAKE );
		PACKET_GUARD_VOID( kPacket2.Write( chPacketType ) );
		PACKET_GUARD_VOID( kPacket2.Write( GetPublicID() ) );
		PACKET_GUARD_VOID( kPacket2.Write( chAwakeKind ) );
		PACKET_GUARD_VOID( kPacket2.Write( m_CharList[iCharArray]->GetCharInfo().m_class_type ) );

		m_pMyRoom->RoomSendPacketTcp( kPacket2, this );
	}

	SaveAlchemicInventory();
	SaveCharacter();

	g_LogDBClient.OnInsertCharAwakeInfo( this, m_CharList[iCharArray]->GetClassType(), iMaterialCode, nUseMaterialCount, chAwakeKind );

	if( ADDITIVE_CODE_NUM == iMaterialCode )
	{
		DoAdditiveMission(nUseMaterialCount, AMT_AWAKE);
	}
}


void User::SendAwakeExtendFailPacket( BYTE chFailType )
{
	SP2Packet kPacket( STPK_CHAR_AWAKE_EXTEND );

	BYTE chPacketType = AWAKE_EXTEND_FAIL;
	PACKET_GUARD_VOID( kPacket.Write( chPacketType ) );
	PACKET_GUARD_VOID( kPacket.Write( chFailType ) );

	SendMessage( kPacket );
}

bool User::CharAwakeExtendErrorCheck( int iCharArray, int iAwakeDay, int &iMaterialCode, int &iMaterialNeedCount )
{
	//캐릭터가 각성중인지 체크
	if( m_CharList[iCharArray]->GetAwakeType() == AWAKE_NONE || m_CharList[iCharArray]->GetAwakeLimitTime() == 0 )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_EXCEPTION );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeExtendErrorCheck Error - No Awake Character UserID %s CharIndex %d", GetPublicID().c_str(), GetCharIndex( iCharArray ) );
		return false;
	}

	// 적절한 각성 일 체크
	if( !g_CharAwakeManager.CheckRightDate( iAwakeDay ) )
	{
		SendAwakeExtendFailPacket(  AWAKE_EXTEND_EXCEPTION );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeExtendErrorCheck Error -  Wrong Awake Day UserID %s AwakeDay %d", GetPublicID().c_str(), iAwakeDay );
		return false;
	}

	//최대 일 수 체크
	if( !g_CharAwakeManager.CheckMaxAwakePeriod( iAwakeDay, m_CharList[iCharArray]->GetAwakeLimitTime() ) )
	{
		SendAwakeExtendFailPacket(  AWAKE_EXTEND_OVER_DATE );
		return false;
	}

	//필요 재료, 재료수 겟
	g_CharAwakeManager.GetMaterialInfo( m_CharList[iCharArray]->GetAwakeType(), iAwakeDay, m_CharList[iCharArray]->GetClassType(), iMaterialCode, iMaterialNeedCount );
	if( iMaterialCode == 0 || iMaterialNeedCount == 0 )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_EXCEPTION  );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeExtendErrorCheck Error -  Wrong Material" );
		return false;
	}

	//재료 체크
	ioAlchemicInventory::AlchemicItem rkMaterialSlot;
	if( !GetAlchemicInventory()->FindAlchemicItem( iMaterialCode, rkMaterialSlot ) )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_NONE_MATERIAL );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeExtendErrorCheck Error -  Dont Have Material UserID %s MaterialCode %d", GetPublicID().c_str(), iMaterialCode );
		return false;
	}

	// 가지고 있는 재료 수 체크
	if( rkMaterialSlot.m_iCount < iMaterialNeedCount )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_MATERIAL_SHORTAGE  );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::CharAwakeExtendErrorCheck Error -  Dont Have Enought Material Count UserID %s MaterialCode %d MaterialNeedCount %d ", GetPublicID().c_str(), iMaterialCode, iMaterialNeedCount );
		return false;
	}

	return true;
}


int User::GetCalcCharAwakeExtendDate( int iAddDay, int iEndDate )
{
	CTime cEndDate = Help::ConvertDateToCTime( iEndDate );
	CTimeSpan cAddTime( iAddDay, 0, 0, 0 );

	CTime cExtendDate = cEndDate + cAddTime;

	return Help::ConvertYYMMDDHHMMToDate( cExtendDate.GetYear(),
									cExtendDate.GetMonth(),
									cExtendDate.GetDay(),
									cExtendDate.GetHour(),
									cExtendDate.GetMinute()
									);
}

void User::OnCharAwakeExtend( SP2Packet &rkPacket )
{
	int iCharIndex = 0;
	BYTE chExtendDay = 0;

	PACKET_GUARD_VOID( rkPacket.Read( iCharIndex ) );
	PACKET_GUARD_VOID( rkPacket.Read( chExtendDay ) );

	int iMaterialCode = 0;
	int iMaterialNeedCount = 0;
	int iCharArray = GetCharArray( iCharIndex );
	if( iCharArray == -1 || !COMPARE( iCharArray, 0, GetCharCount()  ) )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_EXCEPTION );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::OnCharAwakeExtend Error - None Have Character UserID %s CharIndex %d", GetPublicID().c_str(), iCharIndex );
		return;
	}

	//에러 체크
	if( !CharAwakeExtendErrorCheck( iCharArray, chExtendDay, iMaterialCode, iMaterialNeedCount ) )
		return;

	//각성 연장 정보 SET 
	int iPrevEndDate = m_CharList[iCharArray]->GetAwakeLimitTime();

	//지난 각성 종료시간인지 확인
	if( CheckAwakePassedDate(iPrevEndDate) )
	{
			// 현재 시간으로 변환.
			int iCurDate = GetINTtypeCurDate();
			iPrevEndDate = iCurDate;
	}

	int iEndDate = GetCalcCharAwakeExtendDate( chExtendDay, iPrevEndDate );
	if( iEndDate == 0 || iEndDate <= iPrevEndDate )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL,"User::OnCharAwakeExtend Error - EndDate Error : [EndDate:%d, UserID:%s, CharIndex:%d]",iEndDate, GetPublicID().c_str(), iCharIndex );
		SendAwakeExtendFailPacket( AWAKE_EXTEND_EXCEPTION );
		return;
	}

	m_CharList[iCharArray]->SetAwakeTime( iEndDate );
	InsertAwakeDataMap(iCharIndex,iEndDate);

	//재료 삭제 
	if( !GetAlchemicInventory()->UseAlchemicItem( iMaterialCode, iMaterialNeedCount ))
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_MATERIAL_SHORTAGE );
		return;
	}

	//성공 패킷
	SP2Packet kPacket( STPK_CHAR_AWAKE_EXTEND );

	BYTE chPacketType = AWAKE_EXTEND_OK;
	short nUseMaterialCount = iMaterialNeedCount;

	PACKET_GUARD_VOID( kPacket.Write( chPacketType ) );
	PACKET_GUARD_VOID( kPacket.Write( iCharIndex ) );
	PACKET_GUARD_VOID( kPacket.Write( iMaterialCode ) );
	PACKET_GUARD_VOID( kPacket.Write( nUseMaterialCount ) );
	PACKET_GUARD_VOID( kPacket.Write( iEndDate ) );

	SendMessage( kPacket );

	SaveAlchemicInventory();
	SaveCharacter();

	g_LogDBClient.OnInsertCharAwakeInfo( this, m_CharList[iCharArray]->GetClassType(), iMaterialCode, nUseMaterialCount, m_CharList[iCharArray]->GetAwakeType() );

	if( ADDITIVE_CODE_NUM == iMaterialCode )
	{
		DoAdditiveMission(nUseMaterialCount, AMT_AWAKE);
	}
}

void User::InsertAwakeDataMap( int iCharIndex, int iAwakeEndDate )
{
	if( m_CharAwakeDataMap.find( iCharIndex ) != m_CharAwakeDataMap.end() )
	{
		//일반각성 -> 초월 각성
		m_CharAwakeDataMap[iCharIndex] = iAwakeEndDate;
	}
	else
	{
		m_CharAwakeDataMap.insert( std::make_pair( iCharIndex, iAwakeEndDate ) );
	}
}

int User::GetINTtypeCurDate()
{
	CTime cCurDate = CTime::GetCurrentTime();

	return Help::ConvertYYMMDDHHMMToDate( cCurDate.GetYear(),
													cCurDate.GetMonth(),
													cCurDate.GetDay(),
													cCurDate.GetHour(),
													cCurDate.GetMinute()
													);
}

bool User::CheckAwakePassedDate( int iAwakeEndDate )
{
	if( iAwakeEndDate == 0 )
		return false;

	int iCurDate = GetINTtypeCurDate();

	if( iAwakeEndDate < iCurDate )
		return true;

	return false;
}

void User::OnTestAwakeTimeSet( SP2Packet &rkPacket )
{
	int iClassType = 0;
	int iEndMinute = 0;

	PACKET_GUARD_VOID( rkPacket.Read( iClassType ) );
	PACKET_GUARD_VOID( rkPacket.Read( iEndMinute ) );

	//캐릭터를 소유 하고 있는지 체크
	int iCharArray = GetCharArrayByClass( iClassType );

	if( iCharArray == -1 || !COMPARE( iCharArray, 0, GetCharCount()  ) )
	{
		SendAwakeFailPacket( AWAKE_EXTEND_EXCEPTION );
		return;
	}
	int iCharIndex = GetCharIndex( iCharArray );

	//캐릭터가 각성중인지 체크
	if( m_CharList[iCharArray]->GetAwakeType() == AWAKE_NONE || m_CharList[iCharArray]->GetAwakeLimitTime() == 0 )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_EXCEPTION );
		return;
	}

	//시간 지정
	CTimeSpan cPresentGapTime( 0, 0, iEndMinute, 0 );
	CTime cTestTime = CTime::GetCurrentTime() + cPresentGapTime;
	int iDate = Help::ConvertYYMMDDHHMMToDate( cTestTime.GetYear(),
									cTestTime.GetMonth(),
									cTestTime.GetDay() ,
									cTestTime.GetHour(),
									cTestTime.GetMinute()
									);

	m_CharList[iCharArray]->SetAwakeTime( iDate );

	std::map< int, int >::iterator iter = m_CharAwakeDataMap.find( iCharIndex );
	if( iter == m_CharAwakeDataMap.end() )
	{
		SendAwakeExtendFailPacket( AWAKE_EXTEND_EXCEPTION );
		return;
	}
	iter->second = iDate;

	//시간 패킷 전송
	SP2Packet kPacket( STPK_CHAR_AWAKE_EXTEND );

	BYTE chPacketType = AWAKE_EXTEND_OK;
	short nUseMaterialCount = 0;

	PACKET_GUARD_VOID( kPacket.Write( chPacketType ) );
	PACKET_GUARD_VOID( kPacket.Write( iCharIndex ) );
	PACKET_GUARD_VOID( kPacket.Write( 0 ) );
	PACKET_GUARD_VOID( kPacket.Write( nUseMaterialCount ) );
	PACKET_GUARD_VOID( kPacket.Write( iDate ) );


	SendMessage( kPacket );
	SaveCharacter();
}


#if defined( SRC_OVERSEAS )
// 일반 가챠 패키지 전부 보내기 (매크로)		JCLEE 140718
void User::OnGetGashaAll( SP2Packet &rkPacket )
{
	DWORD dwEtcItemCode = 0;
	PACKET_GUARD_VOID( rkPacket.Read( dwEtcItemCode ) );

	// 알파서버 체크
	if( g_App.GetPublicIP() != "172.20.20.75" &&	// KR
		g_App.GetPublicIP() != "172.20.20.193" &&	// IN
		g_App.GetPublicIP() != "172.20.20.198" &&	// NA
		g_App.GetPublicIP() != "172.20.20.248" &&	// NA2
		g_App.GetPublicIP() != "172.20.20.246" &&	// SA
		g_App.GetPublicIP() != "172.20.20.59" &&	// TH
		g_App.GetPublicIP() != "172.20.20.196" &&	// TW
		g_App.GetPublicIP() != "172.20.20.247" )	// EU
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGetGashaAll - Not Alpha Server, PulicID : %s, AccountID : %d, UserIP : %s, dwEtcItemCode : %d", GetPublicID().c_str(), GetUserIndex(), GetPublicIP(), dwEtcItemCode );
		return;
	}	

	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnGetGashaAll - OK, PulicID : %s, AccountID : %d, UserIP : %s, dwEtcItemCode : %d", GetPublicID().c_str(), GetUserIndex(), GetPublicIP(), dwEtcItemCode );

	g_PresentHelper.SendAllGashaponPresent( this, dwEtcItemCode );
}
#endif


void User::AfterLoginProcess( bool bMove )
{
	//서버 이동 일 경우는 무시 ( 로그인 시 체크 함 )
 	if( !bMove )
		m_iUserIPType = g_UserNodeManager.GetUserAccountType( GetPublicIP() );

	//채널링 유저 인원 증가
	g_UserNodeManager.IncreaseChannelingUserCnt( GetChannelingType() );

	//최대 동접 수 비교
	g_UserNodeManager.CheckMaxUserCnt( GetChannelingType() );
}

void User::BeforeLogoutProcess()
{
	//채널링 유저 감소
	g_UserNodeManager.DecreaseChannelingUserCnt( GetChannelingType() );
}

int User::GetDecoPageCount( )
{
	ioInventory* pInventory = GetInventory();

	if( !pInventory )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Inventory NULL : %s", __FUNCTION__, GetPublicID().c_str() );
		return 0;
	}

	int iTotalDecoRow = pInventory->GetCount();
	int iDecoSendSize = DB_DECO_SELECT_COUNT;

	if( iDecoSendSize == 0 )
		return 0;

	if( iTotalDecoRow % iDecoSendSize == 0 )
		return iTotalDecoRow / iDecoSendSize;

	return iTotalDecoRow / iDecoSendSize + 1;
}

int User::GetExtraItemPageCount( )
{
	ioUserExtraItem* pInventory = GetUserExtraItem();

	if( !pInventory )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s ExtraItem NULL : %s", __FUNCTION__, GetPublicID().c_str() );
		return 0;
	}

	int iTotalRow = pInventory->GetRowCount();
	int iExtraSendRowSize = DB_EXTRAITEM_SELECT_COUNT;

	if( iExtraSendRowSize == 0 )
		return 0;

	if( iTotalRow % iExtraSendRowSize == 0 )
		return iTotalRow / iExtraSendRowSize;

	return iTotalRow / iExtraSendRowSize + 1;
}

void User::OnPlayingUserDataInfo( SP2Packet &rkPacket )
{
	if( !IsEnableInterval(CTPK_PLAYING_USERDATA_INFO, G_MAXDELAY_REQUESTUSERDATA) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "Cheating : Request playing user data (ID:%s)", GetPrivateID().c_str() );
		CloseConnection();
		return;
	}

	ioHashString szUserID;

	PACKET_GUARD_VOID( rkPacket.Read( szUserID ) );

	SP2Packet kPacket( STPK_PLAYING_USERDATA_INFO );

	if( !m_pMyRoom )
	{
		//현재 참여중인 방이 없다.
		PACKET_GUARD_VOID( kPacket.Write( NOT_PLAYING_ROOM ) );
		SendMessage( kPacket );
		return;
	}

	User *pTargetUser = m_pMyRoom->GetUserNode( szUserID );

	if( !pTargetUser )
	{
		PACKET_GUARD_VOID( kPacket.Write( NOT_PLAYING_USER ) );
		SendMessage( kPacket );
		return;
	}
	
	PACKET_GUARD_VOID( kPacket.Write( pTargetUser->GetPublicID() ) );
	m_pMyRoom->FillPlayingUserData( kPacket, pTargetUser );
	SendMessage( kPacket );

	SP2Packet kPacket2( STPK_CHANGE_CHAR );
	pTargetUser->FillUserCharInfo( kPacket2 );
	SendMessage( kPacket2 );
}

void User::FillUserCharInfo( SP2Packet &kPacket )
{
	ioCharacter *rkChar = m_CharList[m_select_char];
	int iClassType = 0;

	if( rkChar )
	{
		iClassType = rkChar->GetCharInfo().m_class_type;
		PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kPacket.Write(CHANGE_CHAR_OK) );
		PACKET_GUARD_VOID( kPacket.Write(GetCountRSoldier()) );
		PACKET_GUARD_VOID( kPacket.Write(GetCountOfSpecialSoldier(SST_GFRIEND)) );
		PACKET_GUARD_VOID( kPacket.Write(false) );
		PACKET_GUARD_VOID( kPacket.Write(rkChar->GetCharIndex()) );
		FillChangeCharData( kPacket );
		FillEquipMedalItem( kPacket );
		FillGrowthLevelData( kPacket );

		//장착 중인 칭호 정보 GET
		if( FillEquipTitleData(kPacket) )
		{
			PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
			PACKET_GUARD_VOID( kPacket.Write((BYTE)0) );
			PACKET_GUARD_VOID( kPacket.Write(0) );
		}

		FillExMedalSlotByClassType( iClassType, kPacket );
	}
}

bool User::IsEnableInterval(const int ID, const DWORD dwInterval)
{
	return (m_Timestamp.IsEnable(ID, dwInterval) ? true : false);
}

void User::ModeExitRoom(bool bMovePenalty, int iPenaltyPeso)
{
	bool bExitLobby = true;
	int iExitType	= 0;
	if( bMovePenalty )
		iExitType = EXIT_ROOM_PENALTY;
	else
		iExitType = EXIT_ROOM_QUICK_OUT;

	Room* pUserRoom = GetMyRoom();
	if( !pUserRoom )
		return;
	
	Mode* pPlayMode = pUserRoom->GetModeInfo();
	if( !pPlayMode )
		return;

	pPlayMode->ExitRoom( this, bExitLobby, iExitType, iPenaltyPeso );
}

void User::OnCostumeChange( SP2Packet &rkPacket )
{
	DWORD dwClassIndex		= 0;
	DWORD dwTargetIndex		= 0;
	DWORD dwMaleCustom		= 0;
	DWORD dwFemaleCustom	= 0;
	BYTE bySlot = 0;
	bool bEquip	= false;

	PACKET_GUARD_VOID(rkPacket.Read(dwClassIndex));
	PACKET_GUARD_VOID(rkPacket.Read(bySlot));
#ifdef CUSTOM_COSTUME
	PACKET_GUARD_VOID(rkPacket.Read(dwMaleCustom));
	PACKET_GUARD_VOID(rkPacket.Read(dwFemaleCustom));
#endif
	PACKET_GUARD_VOID(rkPacket.Read(dwTargetIndex));
	PACKET_GUARD_VOID(rkPacket.Read(bEquip));

	Costume* pEquipCostume = m_UserCostume.GetCostume(dwTargetIndex);
	if( !pEquipCostume )
	{
		SP2Packet kPacket(STPK_COSTUME_CHANGE);
		PACKET_GUARD_VOID(kPacket.Write((BYTE)COSTUME_CHANGE_NO_TARGET));
		PACKET_GUARD_VOID(kPacket.Write(GetPublicID()));
		SendMessage(kPacket);
	}
	int iArray = GetCharArray(dwClassIndex);
	int iResult = m_UserCostume.ChangeEquipInfo(iArray, dwTargetIndex, bySlot, bEquip, pEquipCostume);

	if( iResult != COSTUME_CHANGE_SUCCESS )
	{
		SP2Packet kPacket(STPK_COSTUME_CHANGE);
		PACKET_GUARD_VOID(kPacket.Write((BYTE)iResult));
		PACKET_GUARD_VOID(kPacket.Write(GetPublicID()));
		SendMessage(kPacket);
	}
	else
	{
		SP2Packet kPacket(STPK_COSTUME_CHANGE);
		PACKET_GUARD_VOID(kPacket.Write((BYTE)COSTUME_CHANGE_SUCCESS));
		PACKET_GUARD_VOID(kPacket.Write(GetPublicID()));
		PACKET_GUARD_VOID(kPacket.Write(dwClassIndex));
		PACKET_GUARD_VOID(kPacket.Write(bySlot));
		PACKET_GUARD_VOID(kPacket.Write(dwTargetIndex));
		PACKET_GUARD_VOID(kPacket.Write(bEquip));
		PACKET_GUARD_VOID(kPacket.Write(pEquipCostume->GetCostumeCode()));
		PACKET_GUARD_VOID(kPacket.Write(dwMaleCustom));		//남 스킨 
		PACKET_GUARD_VOID(kPacket.Write(dwFemaleCustom));	//여 스킨

		if( m_pMyRoom )
		{
			if( m_select_char == iArray && !m_pMyRoom->IsRoundEndState())
			{
				//방 유저들에게 전송
				m_pMyRoom->RoomSendPacketTcp(kPacket);
				return;
			}
		}
		SendMessage(kPacket);
	}
	
}


void User::OnCostumeBuy(SP2Packet &rkPacket )
{
	int iGoodsCode	= 0;
	BYTE byArray	= 0;
	bool bCash		= false;

	PACKET_GUARD_VOID( rkPacket.Read(iGoodsCode) );
	PACKET_GUARD_VOID( rkPacket.Read(bCash) );
	PACKET_GUARD_VOID( rkPacket.Read(byArray) );

	if( iGoodsCode <= 0 )
	{
		SP2Packet kReturn( STPK_COSTUME_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ITEM_BUY_NON_EXIST_GOODS) );
		SendMessage( kReturn );
		return;
	}

	if( !g_CostumeShopGoodsMgr.IsRightGoods(iGoodsCode) )
	{
		SP2Packet kReturn( STPK_COSTUME_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ITEM_BUY_NON_EXIST_GOODS) );
		SendMessage( kReturn );
		return;
	}

	if( !g_CostumeShopGoodsMgr.IsRightArray(iGoodsCode, byArray) )
	{
		SP2Packet kReturn( STPK_COSTUME_BUY );
		PACKET_GUARD_VOID( kReturn.Write(ITEM_BUY_NON_EXIST_GOODS) );
		SendMessage( kReturn );
		return;
	}

	//코스튬은 페소구매만 가능.
	if( bCash )
		return;
// 	if( bCash )
// 	{
// 		static IntVec vData;
// 		vData.clear();
// 
// 		vData.push_back(iGoodsCode);
// 		CashItemBuyProcess(AIT_COSTUME, vData, STPK_COSTUME_BUY);
// 		return;
// 	}
	
	//페소 구매
	PesoItemBuyProcess(AIT_COSTUME, iGoodsCode, byArray, STPK_COSTUME_BUY);

}

void User::OnCostumeSell( SP2Packet &rkPacket )
{
	DWORD dwCostumeIndex = 0;
	Costume* pCostume = NULL;
	PACKET_GUARD_VOID( rkPacket.Read(dwCostumeIndex) );

	//소유중인 코스튬인지 확인.
	pCostume = m_UserCostume.GetCostume(dwCostumeIndex);
	if( !pCostume )
	{
		SP2Packet kPacket( STPK_COSTUME_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_SELL_NO_TARGET ) );
		SendMessage( kPacket );
		return;
	}

	//장착중인 코스튬인지 확인.
	if( pCostume->GetWearingClass() != 0 )
	{
		SP2Packet kPacket( STPK_COSTUME_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_SELL_EQUIP_ITEM ) );
		SendMessage( kPacket );
		return;
	}

	__int64 iMoney = g_CostumeMgr.SellCostume(pCostume);

	if( iMoney <= 0 )
	{
		//실패 패킷 전송
		SP2Packet kPacket( STPK_COSTUME_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_SELL_EXCEPTION ) );
		SendMessage( kPacket );
		return;
	}

	int iCode = pCostume->GetCostumeCode();
	//아이탬 삭제 후 페소 증가
	if( m_UserCostume.DeleteCostumeItem(dwCostumeIndex) )
	{
		AddMoney(iMoney);
		g_LogDBClient.OnInsertPeso( this, iMoney, LogDBClient::PT_SELL_COSTUME );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_COSTUME, PRESENT_COSTUME, iCode, iMoney, NULL);

		SP2Packet kPacket( STPK_COSTUME_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_SELL_OK ) );
		PACKET_GUARD_VOID( kPacket.Write( dwCostumeIndex ) );
		PACKET_GUARD_VOID( kPacket.Write( iMoney ) );
		PACKET_GUARD_VOID( kPacket.Write( GetMoney() ) );
		SendMessage( kPacket );
	}
	else
	{
		SP2Packet kPacket( STPK_COSTUME_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_SELL_EXCEPTION ) );
		SendMessage( kPacket );
		return;
	}

	g_LogDBClient.OnInsertCostumeInfo(this, iCode, (int)iMoney, LogDBClient::COT_DEL);
	SaveUserData();
}

void User::OnCostumeDisassemble( SP2Packet &rkPacket )
{
	DWORD dwCostumeIndex = 0;
	PACKET_GUARD_VOID( rkPacket.Read(dwCostumeIndex) );

	Costume* pCostume = NULL;
	pCostume = m_UserCostume.GetCostume(dwCostumeIndex);
	if( !pCostume )
	{
		SP2Packet kPacket( STPK_COSTUME_DISASSEMBLE );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_DISASSEMBLE_NO_TARGET ) );
		SendMessage( kPacket );
		return;
	}

	//장착중인 코스튬인지 확인.
	if( pCostume->GetWearingClass() != 0 )
	{
		SP2Packet kPacket( STPK_COSTUME_DISASSEMBLE );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_DISASSEMBLE_EQUIP_ITEM ) );
		SendMessage( kPacket );
		return;
	}

	CostumeManager::CostumeDisassemble stDisableInfo;
	if( !g_CostumeMgr.DisassembleCostume(pCostume, stDisableInfo) )
	{
		SP2Packet kPacket( STPK_COSTUME_DISASSEMBLE );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_DISASSEMBLE_EXCEPTION ) );
		SendMessage( kPacket );
		return;
	}

	if( m_UserCostume.DeleteCostumeItem(dwCostumeIndex) )
	{

	}
	else
	{
		SP2Packet kPacket( STPK_COSTUME_DISASSEMBLE );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)COSTUME_DISASSEMBLE_EXCEPTION ) );
		SendMessage( kPacket );
		return;
	}

	//유저 코스튬 저장.
	//m_UserCostume.SaveData();
	//획득한 아이템 save

}

ioCharacter* User::FindCostumeEquipChar(int iCostumeIndex)
{
	int iSize = GetCharCount();
	for(int i = 0;i < iSize;i++)
	{
		const CHARACTER &charInfo = m_CharList[i]->GetCharInfo();

		for( int j=0; j < MAX_CHAR_COSTUME_SLOT; ++j )
		{
			if( charInfo.m_costume_item[j].m_iCostumeIndex == iCostumeIndex )
				return m_CharList[i];
		}
	}

	return NULL;
}

void User::DeleteCostumePassedDate()
{
	static IntVec vDeleteIndex;
	vDeleteIndex.clear();

	m_UserCostume.DeleteCostumePassedDate(vDeleteIndex);

	if( vDeleteIndex.empty() )
		return;

	int iSize = vDeleteIndex.size();

	for( int i = 0; i < iSize; i++ )
	{
		int iCostumeIndex = vDeleteIndex[i];
		if( iCostumeIndex <= 0 )
			continue;

		ioCharacter* pCharacter = FindCostumeEquipChar(iCostumeIndex);
	
		if( pCharacter )
		{
			for( int j = 0; j < MAX_CHAR_COSTUME_SLOT; j++ )
			{
				if( pCharacter->GetCostumeIndex(j) == iCostumeIndex )
					pCharacter->ChangeCostumeItem(j, 0, 0);
			}
		}

		g_DBClient.OnDeleteCostumeData(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iCostumeIndex);
	}

	SP2Packet kPacket( STPK_DELETE_COSTUME_DATE );
	PACKET_GUARD_VOID(kPacket.Write(iSize));
	for( int i = 0; i < iSize; i++ )
	{
		PACKET_GUARD_VOID(kPacket.Write(vDeleteIndex[i]));
	}
	SendMessage(kPacket);
}

void User::OnAccessoryChange(SP2Packet &rkPacket )
{
	DWORD dwClassIndex = 0;
	DWORD dwTargetIndex = 0;
	BYTE bySlot = 0;
	bool bEquip	= false;

	PACKET_GUARD_VOID(rkPacket.Read(dwClassIndex));
	PACKET_GUARD_VOID(rkPacket.Read(bySlot));
	PACKET_GUARD_VOID(rkPacket.Read(dwTargetIndex));
	PACKET_GUARD_VOID(rkPacket.Read(bEquip));

	Accessory* pEquipAccessory = m_UserAccessory.GetAccessory(dwTargetIndex);
	if( !pEquipAccessory )
	{
		SP2Packet kPacket(STPK_ACCESSORY_CHANGE);
		PACKET_GUARD_VOID(kPacket.Write((BYTE)ACCESSORY_CHANGE_NO_TARGET));
		PACKET_GUARD_VOID(kPacket.Write(GetPublicID()));
		SendMessage(kPacket);
	}
	int iArray = GetCharArray(dwClassIndex);
	int iResult = m_UserAccessory.ChangeEquipInfo(iArray, dwTargetIndex, bySlot, bEquip, pEquipAccessory);

	if( iResult != ACCESSORY_CHANGE_SUCCESS )
	{
		SP2Packet kPacket(STPK_ACCESSORY_CHANGE);
		PACKET_GUARD_VOID(kPacket.Write((BYTE)iResult));
		PACKET_GUARD_VOID(kPacket.Write(GetPublicID()));
		SendMessage(kPacket);
	}
	else
	{
		SP2Packet kPacket(STPK_ACCESSORY_CHANGE);
		PACKET_GUARD_VOID(kPacket.Write((BYTE)ACCESSORY_CHANGE_SUCCESS));
		PACKET_GUARD_VOID(kPacket.Write(GetPublicID()));
		PACKET_GUARD_VOID(kPacket.Write(dwClassIndex));
		PACKET_GUARD_VOID(kPacket.Write(bySlot));
		PACKET_GUARD_VOID(kPacket.Write(dwTargetIndex));
		PACKET_GUARD_VOID(kPacket.Write(bEquip));
		PACKET_GUARD_VOID(kPacket.Write(pEquipAccessory->GetAccessoryCode()));
		PACKET_GUARD_VOID(kPacket.Write(pEquipAccessory->GetAccessoryValue()));

		if( m_pMyRoom )
		{
			if( m_select_char == iArray && !m_pMyRoom->IsRoundEndState())
			{
				//방 유저들에게 전송
				m_pMyRoom->RoomSendPacketTcp(kPacket);
				return;
			}
		}
		SendMessage(kPacket);
	}
}

void User::DeleteAccessoryPassedDate()
{
	static IntVec vDeleteIndex;
	vDeleteIndex.clear();

	m_UserAccessory.DeleteAccessoryPassedDate(vDeleteIndex);

	if( vDeleteIndex.empty() )
		return;

	int iSize = vDeleteIndex.size();

	for( int i = 0; i < iSize; i++ )
	{
		int iAccessoryIndex = vDeleteIndex[i];
		if( iAccessoryIndex <= 0 )
			continue;

		ioCharacter* pCharacter = FindAccessoryEquipChar(iAccessoryIndex);
	
		if( pCharacter )
		{
			for( int j = 0; j < MAX_CHAR_ACCESSORY_SLOT; j++ )
			{
				if( pCharacter->GetAccessoryIndex(j) == iAccessoryIndex )
					pCharacter->ChangeAccessoryItem(j, 0, 0, 0);
			}
		}

		g_DBClient.OnDeleteAccessoryData(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iAccessoryIndex);
	}

	SP2Packet kPacket( STPK_DELETE_ACCESSORY_DATE );
	PACKET_GUARD_VOID(kPacket.Write(iSize));
	for( int i = 0; i < iSize; i++ )
	{
		PACKET_GUARD_VOID(kPacket.Write(vDeleteIndex[i]));
	}
	SendMessage(kPacket);
}

ioCharacter* User::FindAccessoryEquipChar(int iAccessoryIndex)
{
	int iSize = GetCharCount();
	for(int i = 0;i < iSize;i++)
	{
		const CHARACTER &charInfo = m_CharList[i]->GetCharInfo();

		for( int j=0; j < MAX_CHAR_ACCESSORY_SLOT; ++j )
		{
			if( charInfo.m_accessory_item[j].m_iAccessoryIndex == iAccessoryIndex )
				return m_CharList[i];
		}
	}

	return NULL;
}

void User::OnAccessorySell( SP2Packet &rkPacket )
{
	DWORD dwAccessoryIndex = 0;
	Accessory* pAccessory = NULL;
	PACKET_GUARD_VOID( rkPacket.Read(dwAccessoryIndex) );

	//소유중인지 확인.
	pAccessory = m_UserAccessory.GetAccessory(dwAccessoryIndex);
	if( !pAccessory )
	{
		SP2Packet kPacket( STPK_ACCESSORY_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)ACCESSORY_SELL_NO_TARGET ) );
		SendMessage( kPacket );
		return;
	}

	//장착중인지 확인.
	if( pAccessory->GetWearingClass() != 0 )
	{
		SP2Packet kPacket( STPK_ACCESSORY_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)ACCESSORY_SELL_EQUIP_ITEM ) );
		SendMessage( kPacket );
		return;
	}

	if( pAccessory->GetPeriodType() == PCPT_TIME )
	{
		CTime kCurTime = CTime::GetCurrentTime();
		CTime kLimitTime( Help::GetSafeValueForCTimeConstructor( pAccessory->GetYear(),
																	 pAccessory->GetMonth(),
																	 pAccessory->GetDay(),
																	 pAccessory->GetHour(),
																	 pAccessory->GetMinute(),
																	 0) );
		CTimeSpan kRemainTime = kLimitTime - kCurTime;
		if( kRemainTime.GetTotalMinutes() <= 0 )
		{
			SP2Packet kPacket( STPK_ACCESSORY_SELL );
			PACKET_GUARD_VOID( kPacket.Write( (BYTE)ACCESSORY_SELL_PERIOD ) );
			SendMessage( kPacket );
			return;
		}
	}

	int iMoney = g_AccessoryMgr.GetAccessorySellPeso(pAccessory->GetAccessoryCode());

	if( iMoney <= 0 )
	{
		//실패 패킷 전송
		SP2Packet kPacket( STPK_ACCESSORY_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)ACCESSORY_SELL_EXCEPTION ) );
		SendMessage( kPacket );
		return;
	}

	//아이탬 삭제 후 페소 증가
	if( m_UserAccessory.DeleteAccessoryItem(dwAccessoryIndex) )
	{
		AddMoney(iMoney);
		g_LogDBClient.OnInsertPeso( this, iMoney, LogDBClient::PT_SELL_ACCESSORY );
		g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_SELL_ACCESSORY, PRESENT_ACCESSORY, pAccessory->GetAccessoryCode(), iMoney, NULL);

		SP2Packet kPacket( STPK_ACCESSORY_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)ACCESSORY_SELL_OK ) );
		PACKET_GUARD_VOID( kPacket.Write( dwAccessoryIndex ) );
		PACKET_GUARD_VOID( kPacket.Write( iMoney ) );
		PACKET_GUARD_VOID( kPacket.Write( GetMoney() ) );
		SendMessage( kPacket );
	}
	else
	{
		SP2Packet kPacket( STPK_ACCESSORY_SELL );
		PACKET_GUARD_VOID( kPacket.Write( (BYTE)ACCESSORY_SELL_EXCEPTION ) );
		SendMessage( kPacket );
		return;
	}

	//g_LogDBClient.OnInsertCostumeInfo(this, iCode, (int)iMoney, LogDBClient::COT_DEL);
	SaveUserData();
}

int User::GetItemCashValue( int iItemType, IntVec& vDataValue )
{
	int iCash = -1;

	switch( iItemType )
	{
	case AIT_COSTUME :
		{
			if( vDataValue.size() < 0 || vDataValue[0] <= 0 )
				break;

			//iCash = g_CostumeShopGoodsMgr.GetNeedCash(vDataValue[0]);
			break;
		}
		
	}

	return iCash;
}

int User::GetOutPutType(int iItemType)
{
	switch( iItemType )
	{
	case AIT_COSTUME:
		return OUTPUT_CASH_COSTUME;
	}

	return 0;
}

bool User::SetItemBuyVariableValue(int iItemType, IntVec& vData, SP2Packet &rkPacket)
{
	switch(iItemType)
	{
	case AIT_COSTUME:
		{
			if( vData.size() < 0 || vData[0] <= 0 )
				return false;

			PACKET_GUARD_bool(rkPacket.Write(vData[0]));
		}
		return true;
	}

	return false;
}

//HRYOON BONUS CASH??
void User::CashItemBuyProcess(int iItemType, IntVec& vDataValue, DWORD dwPacketID)
{
	//캐쉬 구매
	if( !IsEntryFormality() )
	{
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID(kPacket.Write(ITEM_BUY_USER_NON_FORMALITY));
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][itembuy] cash entry type error - %s : %d", GetPublicID().c_str(), GetEntryType() );
		return;
	}

	int iBuyCash = GetItemCashValue(iItemType, vDataValue); 
	if( iBuyCash <= 0 )
	{
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID(kPacket.Write(ITEM_BUY_NON_EXIST_GOODS));
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][itembuy] cash value error : [cash:%d]", iBuyCash );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID(kPacket.Write(ITEM_BUY_EXEPTION));
		SendMessage( kPacket );
		return;
	}

	//HRYOON BONUS CASH 사용 가능 여부 파악
	//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();
	int iItemPrice = iBuyCash;

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, dwPacketID, ITEM_BUY_CASH_CHECK, iItemType, vConsumeInfo ) )
		return;

	int iSize	= vConsumeInfo.size();
	int iOutPutType = GetOutPutType(iItemType);

	if( 0 == iOutPutType )
	{
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID(kPacket.Write(ITEM_BUY_EXEPTION));
		SendMessage( kPacket );
		return;
	}

	int iSpendBonusCash	= 0;
	for( int i = 0; i < iSize; i++ )
		iSpendBonusCash += vConsumeInfo[i].value2;

	if( iItemPrice != iSpendBonusCash )
	{
		iBuyCash = iItemPrice - iSpendBonusCash;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		PACKET_GUARD_VOID( kBillingPacket.Write((int) GetChannelingType()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(m_szBillingGUID) );
		PACKET_GUARD_VOID( kBillingPacket.Write( iItemPrice ));
		PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicIP()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(iBuyCash) );

		PACKET_GUARD_VOID( kBillingPacket.Write(iSize) );
		for( int i = 0; i < iSize; i++ )
		{
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_VOID( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		PACKET_GUARD_VOID( kBillingPacket.Write(iOutPutType) );

		//변동이 있는 부분
		if( !SetItemBuyVariableValue( iItemType, vDataValue, kBillingPacket ) )
		{
			SP2Packet kPacket( dwPacketID );
			PACKET_GUARD_VOID(kPacket.Write(ITEM_BUY_EXEPTION));
			SendMessage( kPacket );
			return;
		}

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, dwPacketID, ITEM_BUY_BILLING_FAIL, NULL, NULL ) )
			return;

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_EXTRAITEM_BUY );
			PACKET_GUARD_VOID(kReturn.Write(ITEM_BUY_BILLING_DISCONNECT));
			SendMessage( kReturn );
			m_szBillingGUID.Clear();
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::CashItemBuyProcess Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
		}
	}
	else
	{
		// 보너스 캐쉬만 사용.  -- 이 함수 안씀
		//[HRYOON구매] 유저 구매 중인 상태로 변경함
		SetOutputStatus( true );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::CashItemBuyProcess Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
		LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
	}

}

int User::GetItemBuyPeriodValue( int iItemType, int iCode, int iArray )
{
	int iPeriod = -1;

	switch(iItemType)
	{
	case AIT_COSTUME:
		{
			iPeriod = g_CostumeShopGoodsMgr.GetPeriod(iCode, iArray);
		}
		break;
	}

	return iPeriod;
}

int User::GetItemBuyPesoValue( int iItemType, int iCode, int iArray )
{
	int iPeso = 0;

	switch(iItemType)
	{
	case AIT_COSTUME:
		{
			iPeso = g_CostumeShopGoodsMgr.GetNeedPeso(iCode, iArray);
		}
		break;
	}

	return iPeso;
}

void User::BuyCostumeWithPeso(int iCode, int iPeso, int iPeriod )
{
	int iItemCode = g_CostumeShopGoodsMgr.GetItemCode(iCode);	//상점 상품 코드로 해당 아이템 코드 get
	if( iItemCode <= 0 )
	{
		//error 처리
		SP2Packet kPacket( STPK_COSTUME_BUY );
		PACKET_GUARD_VOID(kPacket.Write(ITEM_BUY_NON_EXIST_GOODS));
		SendMessage( kPacket );
		return;
	}
	
	RemoveMoney( iPeso );
	SaveUserData();
	g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_CONSUME, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_COSTUME, PRESENT_COSTUME, iItemCode, iPeso, NULL);

	int iPeriodType = 0;
	if( 0 == iPeriod )
		iPeriodType = 1;

	CTime kLimiteTime = CTime::GetCurrentTime();
	CTimeSpan kAddTime( 0, iPeriod, 0, 0 );
	kLimiteTime += kAddTime;

	SYSTEMTIME sysTime = {0,0,0,0,0,0,0,0};
	sysTime.wYear = kLimiteTime.GetYear();
	sysTime.wMonth = kLimiteTime.GetMonth();
	sysTime.wDay = kLimiteTime.GetDay();
	sysTime.wHour = kLimiteTime.GetHour();
	sysTime.wMinute = kLimiteTime.GetMinute();

	//DB Insert
	g_DBClient.OnInsertCostumeData(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iItemCode, iPeriodType, sysTime, 1, iCode, iPeriod, iPeso);
}

void User::PesoItemBuyProcess(int iItemType, int iCode, int iArray, DWORD dwPacketID)
{
	int iPeso = GetItemBuyPesoValue(iItemType, iCode, iArray);
	if( iPeso <= 0 )
	{
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID( kPacket.Write(ITEM_BUY_NON_EXIST_GOODS) );
		SendMessage( kPacket );
		return;
	}

	if( GetMoney() < iPeso )
	{
		// 예외처리
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID( kPacket.Write(ITEM_BUY_PESO_SHORTAGE) );
		SendMessage( kPacket );
		return;
	}

	int iPeriod = GetItemBuyPeriodValue(iItemType, iCode, iArray);
	if( iPeriod < 0 )
	{
		SP2Packet kPacket( dwPacketID );
		PACKET_GUARD_VOID( kPacket.Write(ITEM_BUY_NON_EXIST_GOODS) );
		SendMessage( kPacket );
		return;
	}

	switch( iItemType )
	{
	case AIT_COSTUME:
		BuyCostumeWithPeso( iCode, iPeso, iPeriod );
		break;
	}
}

int User::SetPresentCostume( int iCode, int iLimitDate, DWORD dwPresentIndex, DWORD dwPresentSlotIndex )
{
	if( !m_UserCostume.IsEnableAdd() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][presentrecv] user costume slot is full : [nickname:%s]", GetPublicID().c_str());
		return PRESENT_RECV_MAX_SLOT;
	}

	if( !g_CostumeMgr.IsExistCostumeItem(iCode) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][presentrecv] invalid costume code : [nickname:%s code:%d]", GetPublicID().c_str(), iCode);
		return PRESENT_RECV_EXCEPTION;
	}

	Costume cCostume;
	cCostume.SetCostumeCode(iCode);
	
	if( iLimitDate >= 0 )
	{
		CTime kLimiteTime = CTime::GetCurrentTime();
		CTimeSpan kAddTime( 0, iLimitDate, 0, 0 );
		kLimiteTime += kAddTime;

		cCostume.SetDate(kLimiteTime.GetYear(), kLimiteTime.GetMonth(), kLimiteTime.GetDay(), kLimiteTime.GetHour(), kLimiteTime.GetMinute());

		if( iLimitDate == 0 )
		{
			//무제한
			cCostume.SetPeriodType(PCPT_MORTMAIN);
		}
		
		SYSTEMTIME sysTime = {0,0,0,0,0,0,0,0};
		g_CostumeMgr.ConvertCTimeToSystemTime(sysTime, kLimiteTime);

		//DB Insert후 실제 유저 코스튬 인벤토리에 추가.
		g_DBClient.OnInsertCostumeData(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), cCostume.GetCostumeCode(), cCostume.GetPeriodType(), sysTime, 
			2, dwPresentIndex, dwPresentSlotIndex);

		return PRESENT_RECV_OK;
	}

	return PRESENT_RECV_EXCEPTION;
}

int User::SetPresentBonusCash( int iAmount, int iLimitDate, DWORD dwPresentIndex, DWORD dwPresentSlotIndex )
{
	if( iLimitDate >= 0 )
	{
		CTime kLimiteTime = CTime::GetCurrentTime();
		CTimeSpan kAddTime( 0, iLimitDate, 0, 0 );
		kLimiteTime += kAddTime;

		if( iLimitDate == 0 )
			return PRESENT_RECV_EXCEPTION;
		
		/*SYSTEMTIME sysTime = {0,0,0,0,0,0,0,0};
		g_CostumeMgr.ConvertCTimeToSystemTime(sysTime, kLimiteTime);*/

		g_DBClient.OnInsertBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iAmount, kLimiteTime);

		return PRESENT_RECV_OK;
	}

	return PRESENT_RECV_EXCEPTION;
}

int User::SetPresentAccessory( int iCode, int iLimitDate, DWORD dwPresentIndex, DWORD dwPresentSlotIndex )
{
	if( !m_UserAccessory.IsEnableAdd() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][presentrecv] user accessory slot is full : [nickname:%s]", GetPublicID().c_str());
		return PRESENT_RECV_MAX_SLOT;
	}

	if( !g_AccessoryMgr.IsExistAccessoryItem(iCode) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[error][presentrecv] invalid accessory code : [nickname:%s code:%d]", GetPublicID().c_str(), iCode);
		return PRESENT_RECV_EXCEPTION;
	}

	Accessory cAccessory;
	cAccessory.SetAccessoryCode(iCode);

	SYSTEMTIME sysTime = {0,0,0,0,0,0,0,0};
	int iPeriod = g_AccessoryMgr.GetAccessoryPeriod(iCode);
	if( iPeriod == 0 )
	{
		cAccessory.SetPeriodType(AccessoryPeriodType::ASPT_MORTMAIN);
	}
	else
	{
		cAccessory.SetPeriodType(AccessoryPeriodType::ASPT_TIME);
		CTime kLimiteTime = CTime::GetCurrentTime();
		CTimeSpan kAddTime( 0, 0, iPeriod, 0 );
		kLimiteTime += kAddTime;
		g_AccessoryMgr.ConvertCTimeToSystemTime(sysTime, kLimiteTime);
	}

	int iAccessoryValue = g_AccessoryMgr.GetAccessoryValue(iCode);
	cAccessory.SetAccessoryValue(iAccessoryValue);
	

	//DB Insert후 실제 유저 코스튬 인벤토리에 추가.
	g_DBClient.OnInsertAccessoryData(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), cAccessory.GetAccessoryCode(), cAccessory.GetPeriodType(), sysTime, 
		2, dwPresentIndex, dwPresentSlotIndex, cAccessory.GetAccessoryValue());

	return PRESENT_RECV_OK;
}

void User::AddCostumeItem(int iIndex, DWORD dwCode, int iPeriodType, SYSTEMTIME &sysTime)
{
	Costume cCostume;
	cCostume.SetCostumeCode(dwCode);
	cCostume.SetCostumeIndex(iIndex);
	cCostume.SetDate(sysTime.wYear, sysTime.wMonth, sysTime.wDay, sysTime.wHour, sysTime.wMinute);
	cCostume.SetPeriodType(iPeriodType);
	
	m_UserCostume.AddCostumeItem(cCostume);
}

void User::AddCostumeItem(int iIndex, DWORD dwCode, int iPeriodType, int iValue1, int iValue2)
{
	Costume cCostume;
	cCostume.SetCostumeCode(dwCode);
	cCostume.SetCostumeIndex(iIndex);
	cCostume.SetDate(iValue1, iValue2);
	cCostume.SetPeriodType(iPeriodType);

	m_UserCostume.AddCostumeItem(cCostume);
}

void User::AddAccessoryItem(int iIndex, DWORD dwCode, int iPeriodType, SYSTEMTIME &sysTime)
{
	Accessory cAccessory;
	cAccessory.SetAccessoryCode(dwCode);
	cAccessory.SetAccessoryIndex(iIndex);
	cAccessory.SetDate(sysTime.wYear, sysTime.wMonth, sysTime.wDay, sysTime.wHour, sysTime.wMinute);
	cAccessory.SetPeriodType(iPeriodType);
	
	m_UserAccessory.AddAccessoryItem(cAccessory);
}

void User::AddAccessoryItem(int iIndex, DWORD dwCode, int iPeriodType, int iValue1, int iValue2, int iValue3)
{
	Accessory cAccessory;
	cAccessory.SetAccessoryCode(dwCode);
	cAccessory.SetAccessoryIndex(iIndex);
	cAccessory.SetDate(iValue1, iValue2);
	cAccessory.SetPeriodType(iPeriodType);
	cAccessory.SetAccessoryValue(iValue3);

	m_UserAccessory.AddAccessoryItem(cAccessory);
}

void User::SpecialGoodsBuy(DWORD dwEtcType)
{
	//우선적으로 게임서버에 있는 수량 체크
	if( false == g_SpecialGoodsMgr.IsOpen() )
	{
		//error 패킷
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_CLOSE) );
		SendMessage(kPacket);
		return;
	}

	if( false == g_SpecialGoodsMgr.IsPossibleBuy(dwEtcType) )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_SOLD_OUT) );
		SendMessage(kPacket);
		return;
	}

	//메인서버로 체크
	SP2Packet kPacket( MSTPK_SPECIAL_SHOP_GOODS_BUY );
	PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( kPacket.Write(dwEtcType) );
	PACKET_GUARD_VOID( kPacket.Write(SBT_GOODS_BUY) );

	g_MainServer.SendMessage( kPacket );
}

void User::SpecialGoodsPresent(const int iPresentType, const int iBuyValue1, const int iBuyValue2, ioHashString szReceiverPublicID)
{
	//우선적으로 게임서버에 있는 수량 체크
	if( false == g_SpecialGoodsMgr.IsOpen() )
	{
		//error 패킷
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_CLOSE) );
		SendMessage(kPacket);
		return;
	}

	if( false == g_SpecialGoodsMgr.IsPossibleBuy(iBuyValue1) )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_SOLD_OUT) );
		SendMessage(kPacket);
		return;
	}

	//메인서버로 체크
	SP2Packet kPacket( MSTPK_SPECIAL_SHOP_GOODS_BUY );
	PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( kPacket.Write(iBuyValue1) );
	PACKET_GUARD_VOID( kPacket.Write(SBT_GOODS_PRESENT) );
	PACKET_GUARD_VOID( kPacket.Write(iPresentType) );
	PACKET_GUARD_VOID( kPacket.Write(iBuyValue2) );
	PACKET_GUARD_VOID( kPacket.Write(szReceiverPublicID) );

	g_MainServer.SendMessage( kPacket );
}

void User::_OnSpecialGoodsBuy(int iBuyState, SP2Packet &rkPacket )
{
	if( SPECIAL_SHOP_GOODS_BUY_RESERVE == iBuyState )
	{
		//골드 처리 요청
		DWORD dwItemType = 0;
		int		iBuyType = 0;

		PACKET_GUARD_VOID( rkPacket.Read(iBuyType) );
		PACKET_GUARD_VOID( rkPacket.Read(dwItemType) );

		//골드 처리 체크
		switch( iBuyType )
		{
		case SBT_GOODS_BUY:
			{
				if( !SpecialGoodsCashProcess(dwItemType) )
					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][specialshop] goods buy fail");
			}
			break;

		case SBT_GOODS_PRESENT:
			{
				int iPresentType = 0;
				int iBuyValue = 0;
				ioHashString szReceiverPublicID;

				PACKET_GUARD_VOID( rkPacket.Read(iPresentType) );
				PACKET_GUARD_VOID( rkPacket.Read(iBuyValue) );
				PACKET_GUARD_VOID( rkPacket.Read(szReceiverPublicID) );

				PresendCashProcess(iPresentType, dwItemType, iBuyValue, szReceiverPublicID);
			}
			break;
		}
		
	}
	else if( SPECIAL_SHOP_GOODS_BUY_SOLD_OUT == iBuyState )
	{
		// 유저에게 구매 실패 전송 
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_SOLD_OUT) );
		SendMessage( kPacket );
	}
	else if( SPECIAL_SHOP_GOODS_BUY_CLOSE == iBuyState )
	{
		// 유저에게 구매 실패 전송 
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_CLOSE ) );
		SendMessage( kPacket );
	}
	else if( SPECIAL_SHOP_GOODS_BUY_LIMIT == iBuyState )
	{
		// 유저에게 구매 실패 전송 
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_SPECIAL_SHOP_BUY_LIMIT ) );
		SendMessage( kPacket );
	}
	else
	{
		// 유저에게 구매 실패 전송 
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_VOID( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kPacket );
	}
}

bool User::SpecialGoodsCashProcess(int iItemType)
{
	ioEtcItem* pEtcItem =  g_EtcItemMgr.FindEtcItem(iItemType);

	if( GetEntryType() == ET_TERMINATION || !pEtcItem )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_bool( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnEtcItemBuy Cash Entry Type Error - %s : %d",GetPublicID().c_str(), GetEntryType() );

		return false;
	}

	int iBuyCash = pEtcItem->GetCash(0);
	if( iBuyCash <= 0 )
	{
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_bool( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
		SendMessage( kPacket );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][specialshop] cash price error - %s(%d) : %d : %d", GetPublicID().c_str(), GetUserIndex(), iBuyCash, iItemType );
		
		return false;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][specialshop] non type channeling : %d:%s:%s:%d", GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
		SP2Packet kPacket( STPK_ETCITEM_BUY );
		PACKET_GUARD_bool( kPacket.Write(ETCITEM_BUY_BILLING_FAIL) );
		SendMessage( kPacket );

		return false;
	}

	//HRYOON BONUS CASH 사용 가능 여부 파악
	//g_DBClient.OnSelectPossibleBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_BUY);
	static IntOfTwoVec vConsumeInfo;
	vConsumeInfo.clear();

	int iItemPrice = iBuyCash;		//아이템가격

	if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_ETCITEM_BUY, ETCITEM_BUY_BILLING_WANT_OF_CASH, iItemType, vConsumeInfo ) )
		return false;

	int iSize	= vConsumeInfo.size();
	int iSpendBonusCash	= 0;
	bool bBonusCash = false;

	//HRYOON BONUS CASH
	for( int i = 0; i < iSize; i++ )

		iSpendBonusCash += vConsumeInfo[i].value2;		//총 보너스캐시로 사용할 금액


	//보너스 캐쉬로 구매 가능 
	if( iSpendBonusCash >= iItemPrice )
		bBonusCash = true;

	//HRYOON BONUS CASH  ->  iItemPrrice > iSpendBonusCash  => 이걸로 바꿔야 되지 않나?
	if( iItemPrice > iSpendBonusCash )
	{
		iBuyCash = iItemPrice - iSpendBonusCash;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
		kBillingPacket << (int) GetChannelingType();
		kBillingPacket << m_szBillingGUID;
		kBillingPacket << iItemPrice;
		kBillingPacket << GetUserIndex();
		kBillingPacket << GetPublicID();
		kBillingPacket << GetPrivateID();
		kBillingPacket << GetPublicIP();
		kBillingPacket << iBuyCash;

		PACKET_GUARD_bool( kBillingPacket.Write(iSize) );
		//
		for( int i = 0; i < iSize; i++ )
		{
			PACKET_GUARD_bool( kBillingPacket.Write(vConsumeInfo[i].value1) );	//사용할 보너스캐쉬 INDEX
			PACKET_GUARD_bool( kBillingPacket.Write(vConsumeInfo[i].value2) );	// 소비할 금액
		}

		kBillingPacket << OUTPUT_CASH_ETC;
		kBillingPacket << iItemType;
		kBillingPacket << 0;

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_ETCITEM_BUY, ETCITEM_BUY_BILLING_FAIL, NULL, NULL ) )
			return false;

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][specialshop] cash send fail : %s(%d):%s:%d", GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_ETCITEM_BUY );
			PACKET_GUARD_bool( kReturn.Write(ETCITEM_BUY_BILLING_DISCONNECT) );
			SendMessage( kReturn );
			m_szBillingGUID.Clear();

			return false;
		}
	
		return true;
	}
	else 
	{

		if( bBonusCash )
		{
			//HRYOON BONUS CASH 만차감
			ioUserEtcItem::ETCITEMSLOT kEtcItemSlot;
			bool bExist = m_UserEtcItem.GetEtcItem( iItemType, kEtcItemSlot );
			int iServerValue = pEtcItem->GetValue( 0 );


			bool bNewMortmain = false;
			if( g_EtcItemMgr.IsBlockEtcItem( iItemType ) && iServerValue == 0 )
			{
				if( pEtcItem->IsCanMortmain( iItemType ) )
					bNewMortmain = true;
			}


			DWORD dwCompensation = _OnEtcItemSetting( pEtcItem, kEtcItemSlot, iServerValue, bNewMortmain );


			// set my item
			DWORD dwIndex        = 0;
			int   iArrayInIndex  = 0;


			m_UserEtcItem.AddEtcItem( kEtcItemSlot, true, 0,  dwIndex, iArrayInIndex );


			// success
			if( dwIndex != 0 )
			{
				char szItemIndex[MAX_PATH]="";
				StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%u-%u", dwIndex, iArrayInIndex+1 ); // db field는 1부터 이므로 +1
				g_LogDBClient.OnInsertCashItem( this, iItemType, iServerValue, 0, szItemIndex, LogDBClient::CIT_ETC, GetBillingGUID().c_str() );
				StartEtcItemTime(  __FUNCTION__ , iItemType );
			}
			if(m_szBillingGUID.IsEmpty())
			{
				char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
				Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
				m_szBillingGUID = szTempGUID;
			}
			for( int i = 0; i < (int)vConsumeInfo.size(); i++ )
			{
				//보너스 캐쉬 사용.
				if( !m_UserBonusCash.SpendBonusCash(vConsumeInfo[i].value1, vConsumeInfo[i].value2, PRESENT_ETC_ITEM, iItemType, iServerValue) )
				{
					SP2Packet kReturn( STPK_ETCITEM_BUY );
					PACKET_GUARD_bool( kReturn.Write(ETCITEM_BUY_BILLING_FAIL) );
					SendMessage( kReturn );

					LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Spend Bonus Cash Error : publicID:%s(userIndex:%d)guid:%s, index:%d,money:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), vConsumeInfo[i].value1, vConsumeInfo[i].value2 );
					ClearBillingGUID();

					return false;
				}
			}
			ClearBillingGUID();


			int iBonusPeso = pEtcItem->GetBonusPeso( iArrayInIndex );
			if( iBonusPeso > 0 )
			{
				AddMoney( iBonusPeso );
				g_LogDBClient.OnInsertPeso( this, iBonusPeso, LogDBClient::PT_BUY_CASH );
				g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_PESO_GAIN, this, 0, 0, LogDBClient::LET_ITEM, LogDBClient::PT_BUY_CASH, PRESENT_ETC_ITEM, kEtcItemSlot.m_iType, iBonusPeso, NULL);
			}


			//HRYOON BONUS CASH 유저 보너스 캐쉬 실시간 조회
			g_DBClient.OnSelectBonusCash(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GET_BONUS_CASH_PERIOD);


			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_bool( kPacket.Write(ETCITEM_BUY_OK) );
			PACKET_GUARD_bool( kPacket.Write(kEtcItemSlot.m_iType) );
			PACKET_GUARD_bool( kPacket.Write(kEtcItemSlot.m_iValue1) );
			PACKET_GUARD_bool( kPacket.Write(kEtcItemSlot.m_iValue2) );
			PACKET_GUARD_bool( kPacket.Write(GetMoney()) );
			PACKET_GUARD_bool( kPacket.Write(GetCash()) );
			PACKET_GUARD_bool( kPacket.Write(GetChannelingCash()) );
			PACKET_GUARD_bool( kPacket.Write(0) );
			PACKET_GUARD_bool( kPacket.Write(true) );				//구매 알림 팝업
			PACKET_GUARD_bool( kPacket.Write(dwCompensation) );
			PACKET_GUARD_bool( kPacket.Write((BYTE)EBRT_BUY) );

			SendMessage( kPacket );

			SaveEtcItem();

			SP2Packet kMainPacket( MSTPK_SPECIAL_SHOP_GOODS_BUY_RESULT );
			PACKET_GUARD_bool( kMainPacket.Write(SPECIAL_SHOP_GOODS_BUY_RESULT_OK) );
			PACKET_GUARD_bool( kMainPacket.Write(iItemType) );
			PACKET_GUARD_bool( kMainPacket.Write(GetUserIndex()) );

			g_MainServer.SendMessage( kMainPacket );
		}
		else
		{
			SP2Packet kPacket( STPK_ETCITEM_BUY );
			PACKET_GUARD_bool( kPacket.Write(ETCITEM_BUY_EXCEPTION) );
			SendMessage( kPacket );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][specialshop] BonusCash Shortage - %s(%d) : %d : %d", GetPublicID().c_str(), GetUserIndex(), iBuyCash, iItemType );
		}
	}

	//[HRYOON구매] 유저 구매 중인 상태로 변경함
	SetOutputStatus( true );
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::SpecialGoodsCashProcess Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
	return true;
}

void User::OnSpecialShopGoodsList(SP2Packet &rkPacket )
{
	//스패셜상점 상품 정보 요청
	SP2Packet kPacket(STPK_SPECIAL_SHOP_GOODS_LIST);
	bool bOpen = g_SpecialGoodsMgr.IsOpen();
	PACKET_GUARD_VOID( kPacket.Write(bOpen) );
	if( bOpen )
	{
		g_SpecialGoodsMgr.FillGoodsList(kPacket);
	}

	SendMessage(kPacket);
}

void User::OnMissionInfoRequest( SP2Packet &kPacket )
{
	//원래는 유저가 변경 시간에 미션 요청하면 체크 후 전송. 현재는 변경시간에 접속 유저 broadcast 
	/*
	//유저 미션 정보가 이전거 인지 확인
	if( m_UserMission.IsRenewalData() )
	{
		DWORD dwNextActiveDate = g_MissionMgr.GetMostRapidNextActiveDate();

		SP2Packet rkPacket(STPK_MISSION_INFO);
		PACKET_GUARD_VOID(rkPacket.Write((BYTE)MISSION_INFO_SUCCESS));
		PACKET_GUARD_VOID(rkPacket.Write(dwNextActiveDate));
		m_UserMission.FillMissionTableInfoIntoPacket(rkPacket);
		SendMessage(rkPacket);
		m_UserMission.SetRenewalFlag(FALSE);
	}
	else
	{
		SP2Packet rkPacket(STPK_MISSION_INFO);
		PACKET_GUARD_VOID(rkPacket.Write((BYTE)MISSION_INFO_FAIL));
		SendMessage(rkPacket);
	}*/
	
}

void User::OnMissionCompensationRecv( SP2Packet &kPacket )
{
	DWORD dwMissionCode = 0;
	PACKET_GUARD_VOID( kPacket.Read(dwMissionCode) );

	int iResult = m_UserMission.RecvCompensation(dwMissionCode);
	if( -1 == iResult)
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][mission] PACKET_GUARD CRASH : %s", GetPublicID().c_str() );
		return;
	}

	SP2Packet rkPacket( STPK_MISSION_COMPENSATION_RECV);
	PACKET_GUARD_VOID( rkPacket.Write(iResult) );
	PACKET_GUARD_VOID( rkPacket.Write(dwMissionCode) );
	SendMessage(rkPacket);
}

void User::OnMissionTimeCheck( SP2Packet &kPacket )
{
	DWORD dwMissionCode = 0;

	PACKET_GUARD_VOID( kPacket.Read(dwMissionCode) );
	m_UserMission.TimeMissionCheck(dwMissionCode);
}

void User::SaveTimeMission()
{
	m_UserMission.SaveTimeMission();
}

void User::OnTestMissionSetDate( SP2Packet &kPacket )
{
	g_MissionMgr.TestChangeNextDate(kPacket);
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[info][mission] call mission macro : %s", GetPublicID().c_str() );
}

void User::DoAdditiveMission(int iCount, int iUseType)
{
	static DWORDVec vValues;
	vValues.clear();
	vValues.push_back(iUseType);
	vValues.push_back(iCount);
	g_MissionMgr.DoTrigger(MISSION_CLASS_ADDITIVE_USE, this, vValues);
}

void User::SetUserRollBookType(int iType)
{
	m_UserRollBook.SetRollBookType(iType);
}

void User::OnRollBookRenewal( SP2Packet &rkPacket )
{
	if( !m_UserRollBook.IsRenewalDate() || m_UserRollBook.GetSQLUpdateFlag() )
	{
		SP2Packet kPacket(STPK_ROLLBOOK_ATTEND);
		PACKET_GUARD_VOID( kPacket.Write(ROLLBOOK_ATTEND_FAIL) );
		SendMessage(kPacket);
		return;
	}

	int iTableIndex = 0;
	int iNextStamp	= 0;
	m_UserRollBook.GetNextStep(RBR_PROGRESS, iTableIndex, iNextStamp);
	if( 0 == iTableIndex )
	{
		SP2Packet kPacket(STPK_ROLLBOOK_ATTEND);
		PACKET_GUARD_VOID( kPacket.Write(ROLLBOOK_ATTEND_FAIL) );
		SendMessage(kPacket);
		return;
	}

	m_UserRollBook.SetSQLUpdateFlag(TRUE);
	
	CTime kCurrentTime = CTime::GetCurrentTime();

	SYSTEMTIME sysTime = {0,0,0,0,0,0,0,0};
	sysTime.wYear = kCurrentTime.GetYear();
	sysTime.wMonth = kCurrentTime.GetMonth();
	sysTime.wDay = kCurrentTime.GetDay();
	sysTime.wHour = kCurrentTime.GetHour();
	sysTime.wMinute = kCurrentTime.GetMinute();

	g_DBClient.OnUpdateRollBookData(GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iTableIndex, iNextStamp, sysTime );
}

void User::OnTestMissionSetValue( SP2Packet &kPacket )
{
	m_UserMission.MacroSetActiveMissionValue(kPacket);
}

void User::OnTestRollBookProgress( SP2Packet &rkPacket )
{
	m_UserRollBook.ProgressRollBook(rkPacket);
}

void User::OnGuildAttend( SP2Packet &rkPacket )
{
	int iResult = m_UserGuild.CanAttending(rkPacket);
	SP2Packet kPacket(STPK_GUILD_ATTEND);
	PACKET_GUARD_VOID(kPacket.Write(iResult));
	PACKET_GUARD_VOID(kPacket.Write(GetUserIndex()));

	if( GUILD_ATTEND_OK != iResult)
	{
		SendMessage(kPacket);
		return;
	}

	m_UserGuild.SendRelayPacketTcp(kPacket, TRUE);

	//DB 길드 출석 기록!
	m_UserGuild.SQLUpdateAttendDate();
	m_UserGuild.SetTodayAttendanceInfo(TRUE);
	////////
// 	CTime cCurTime = CTime::GetCurrentTime();
// 	CTime cRecvTime( cCurTime.GetYear(), cCurTime.GetMonth(), cCurTime.GetDay(), cCurTime.GetHour(), cCurTime.GetMinute(), 0 );
// 	m_UserGuild.SetRecvAttendRewardDate(cRecvTime.GetTime());
}

void User::GetAttendStandardDate(SYSTEMTIME& sYesterDay, SYSTEMTIME& sToday)
{
	CTime cCurTime = CTime::GetCurrentTime();
	CTime cCheckDate( cCurTime.GetYear(), cCurTime.GetMonth(), cCurTime.GetDay(), g_GuildRewardMgr.GetRenewalHour(), 0, 0);
	CTimeSpan cGap(1,0,0,0);

	if( cCurTime >= cCheckDate )
	{
		sToday.wYear	= cCheckDate.GetYear();
		sToday.wMonth	= cCheckDate.GetMonth();
		sToday.wDay		= cCheckDate.GetDay();

		cCheckDate = cCheckDate - cGap;
		sYesterDay.wYear	= cCheckDate.GetYear();
		sYesterDay.wMonth	= cCheckDate.GetMonth();
		sYesterDay.wDay		= cCheckDate.GetDay();
	}
	else
	{
		cCheckDate = cCheckDate - cGap;
		sToday.wYear	= cCheckDate.GetYear();
		sToday.wMonth	= cCheckDate.GetMonth();
		sToday.wDay		= cCheckDate.GetDay();

		cCheckDate = cCheckDate - cGap;
		sYesterDay.wYear	= cCheckDate.GetYear();
		sYesterDay.wMonth	= cCheckDate.GetMonth();
		sYesterDay.wDay		= cCheckDate.GetDay();
	}
}

void User::OnRecvGuildAttendReward(SP2Packet &rkPacket)
{
	DWORD dwGuildIndex = m_UserGuild.GetGuildIndex();
	if( 0 == dwGuildIndex )
	{
		//error 처리
		SP2Packet kPacket(STPK_RECV_GUILDATTEND_REWARD);
		PACKET_GUARD_VOID( kPacket.Write(GUILD_ATTEND_REWARD_FAIL) );
		SendMessage(kPacket);
		return;
	}

	int iResult = m_UserGuild.DoRecvGuildAttendReward();

	if( GUILD_ATTEND_REWARD_FAIL == iResult )
	{
		//실패
		SP2Packet kPacket(STPK_RECV_GUILDATTEND_REWARD);
		PACKET_GUARD_VOID( kPacket.Write(GUILD_ATTEND_REWARD_FAIL) );
		SendMessage(kPacket);
		return;
	}
	
	if( GUILD_ATTEND_REWARD_OK == iResult )
	{
		//성공
		int iYesterdayAtendance = m_UserGuild.GetYesterdayAttendance();
		SendGuildAttendReward(iYesterdayAtendance);

		m_UserGuild.SQLUpdateAttendRewardDate();
		CTime cCurTime = CTime::GetCurrentTime();
		CTime cRecvTime( cCurTime.GetYear(), cCurTime.GetMonth(), cCurTime.GetDay(), cCurTime.GetHour(), cCurTime.GetMinute(), 0 );
		m_UserGuild.SetRecvAttendRewardDate(cRecvTime.GetTime());
	}
	else
	{
		SP2Packet kPacket(STPK_RECV_GUILDATTEND_REWARD);
		PACKET_GUARD_VOID( kPacket.Write(GUILD_ATTEND_REWARD_DATE_PREV) );
		SendMessage(kPacket);

// 		SYSTEMTIME sYesterDay = {0,0,0,0,0,0,0,0};
// 		SYSTEMTIME sToday = {0,0,0,0,0,0,0,0};
// 
// 		GetAttendStandardDate(sYesterDay, sToday);
// 		g_DBClient.OnSelectGuildAttendanceInfo(GetUserDBAgentID(), GetAgentThreadID(), m_UserGuild.GetGuildIndex(), GetUserIndex(), sYesterDay, YESTERDAY_ATTENDANCE_MEMEBER);
// 		g_DBClient.OnSelectGuildAttendanceInfo(GetUserDBAgentID(), GetAgentThreadID(), m_UserGuild.GetGuildIndex(), GetUserIndex(), sToday, TODAY_ATTENDACE_MEMBER);
	}
}

void User::SendGuildAttendReward(int iCount)
{
	if( 0 == iCount )
	{
		//실패
		SP2Packet kPacket(STPK_RECV_GUILDATTEND_REWARD);
		PACKET_GUARD_VOID( kPacket.Write(GUILD_ATTEND_REWARD_FAIL) );
		SendMessage(kPacket);
		return;
	}

	if( !g_GuildRewardMgr.SendAttendReward(this, iCount) )
	{
		//실패
		SP2Packet kPacket(STPK_RECV_GUILDATTEND_REWARD);
		PACKET_GUARD_VOID( kPacket.Write(GUILD_ATTEND_REWARD_FAIL) );
		SendMessage(kPacket);
		return;
	}
}

void User::OnRenewalGuildMemberAttendInfo(SP2Packet &rkPacket)
{
	CTime cCurTime = CTime::GetCurrentTime();
	int iRenewalHour	= g_GuildRewardMgr.GetRenewalHour();

	if( cCurTime.GetHour() < iRenewalHour )
		return;

	//갱신 체크
	if( m_UserGuild.IsPrevAttendanceInfo() )
	{
		SYSTEMTIME sYesterDay = {0,0,0,0,0,0,0,0};
		SYSTEMTIME sToday = {0,0,0,0,0,0,0,0};

		GetAttendStandardDate(sYesterDay, sToday);
		g_DBClient.OnSelectGuildAttendanceInfo(GetUserDBAgentID(), GetAgentThreadID(), m_UserGuild.GetGuildIndex(), GetUserIndex(), sYesterDay, YESTERDAY_ATTENDANCE_MEMEBER);
		g_DBClient.OnSelectGuildAttendanceInfo(GetUserDBAgentID(), GetAgentThreadID(), m_UserGuild.GetGuildIndex(), GetUserIndex(), sToday, TODAY_ATTENDACE_MEMBER);
	}
	else
	{
		SP2Packet kPacket(STPK_GUILD_MEMBER_ATTEND_INFO);
		PACKET_GUARD_VOID( kPacket.Write(GUILD_ATTEND_INFO_RENWARL_FAIL) );
		SendMessage(kPacket);
	}

}


void User::_OnBillingOutputCashPopup( SP2Packet &rkPacket, int iReturnItemPrice, int iPayAmt, int iTransactionID )
{
	short iPresentType = 0;
	int   iBuyValue1   = 0;
	int   iBuyValue2   = 0;
	int   iPopupIndex = 0;

	rkPacket >> iPresentType;	
	rkPacket >> iBuyValue1;
	rkPacket >> iBuyValue2;
	rkPacket >> iPopupIndex;

	ioLocalParent* pLocal =  g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

	DWORD dwRecvUserIndex = GetUserIndex();	// 구매한 선물
	if( !g_PresentHelper.InsertUserPopupItem( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), iPresentType, iBuyValue1, iBuyValue2, false ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d[%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, iPresentType, iBuyValue1, iBuyValue2 );

		ClearBillingGUID();
		SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(POPUP_ITEM_BILLING_FAIL) );
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( g_EventMgr.isMileageShopOpen() )
	{
		int iMileage = 0;
		if( iPayAmt < 0)
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, 0, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
		}
		else 
		{
			// 20150716 마일리지 비율 수정 z3
			if( IsPCRoomAuthority() )
				iMileage = (iPayAmt / 100) * g_EventMgr.GetPcRoomMileageRatio();
			else
				iMileage = (iPayAmt / 100) * g_EventMgr.GetMileageRatio();



			// 마일리지가 0이면 선물보내지 않음
			if( iMileage <= 0 )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail Mileage 0 : userIndex:%d,userID:%s,mileage:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), iMileage );
				ClearBillingGUID();
				return;
			}
			if( !g_PresentHelper.InsertUserPresent( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), GetPublicID(), GetPublicIP(), GetUserIndex(), iPresentType, ioEtcItem::EIT_ETC_MILEAGE_COIN, iMileage, false, true, true ) )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail User Present : %s:%s:%d:%d[%d:%d:%d:%d]", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt, 0, GetUserIndex(), iPresentType, iBuyValue1, iBuyValue2 );
				ClearBillingGUID();
				SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
				PACKET_GUARD_VOID( kReturn.Write(POPUP_ITEM_BILLING_FAIL) );
				SendMessage( kReturn );

				if( pLocal )
					pLocal->SendRefundCash( this, iTransactionID, true );
				return;
			}
			//HRYOON 20141222 선물함 갱신, 바로 마일리지 들어오도록..
			enum { SELECT_CNT = 30, };
			_OnSelectPresent( SELECT_CNT );
		}
	}

	//일단 없음
	__int64 iPreMoney = GetMoney();
	int iBonusPeso = 0;

	// 선물 받을 유저에게 알림
	UserParent* pUserParent = g_UserNodeManager.GetGlobalUserNode( dwRecvUserIndex );
	if( pUserParent )
	{
		enum { SELECT_CNT = 30, };
		if( pUserParent->IsUserOriginal() )
		{
			User *pUser = (User*)pUserParent;
			if( pUser )
				pUser->_OnSelectPresent( SELECT_CNT );

			//선물이 아니기 때문에 무조건 있을듯?
			if( pUser )
				pUser->AddUsePopupIndex( iPopupIndex );

		}
		else
		{
			UserCopyNode *pUser = (UserCopyNode*)pUserParent;
			SP2Packet kPacket( SSTPK_PRESENT_SELECT );
			PACKET_GUARD_VOID( kPacket.Write(dwRecvUserIndex) );
			PACKET_GUARD_VOID( kPacket.Write(SELECT_CNT) );
			pUser->SendMessage( kPacket );
		}
	}

	int iPreCash = GetCash();
	int iPrePurchasedCash = GetPurchasedCash();
	int iPreChannelingCash = GetChannelingCash();
	ioChannelingNodeParent* pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %s:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), iPayAmt );
		ClearBillingGUID();
		SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(POPUP_ITEM_BILLING_FAIL) );
		SendMessage( kReturn );

		if( pLocal )
			pLocal->SendRefundCash( this, iTransactionID, true );
		return;
	}

	if( pLocal )
	{
		if( !pLocal->UpdateOutputCash( this , rkPacket, iPayAmt, STPK_POPUP_ITEM_BUY_RESULT, POPUP_ITEM_BILLING_FAIL ) )
			return;
	}

	//완료 했을때 서버 작업.
	SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
	PACKET_GUARD_VOID( kReturn.Write(POPUP_ITEM_BUY_SUCCESS) );
	PACKET_GUARD_VOID( kReturn.Write(GetMoney()) );
	PACKET_GUARD_VOID( kReturn.Write(GetCash()) );
	PACKET_GUARD_VOID( kReturn.Write(GetPurchasedCash()) );
	PACKET_GUARD_VOID( kReturn.Write(GetChannelingCash()) );
	SendMessage( kReturn );

	char szItemIndex[MAX_PATH]="";
	StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "%d:%d:%d", iPresentType, iBuyValue1, iBuyValue2 ); // 스트링 형식 수정 불가, DB에서 파싱해서 사용함.

	g_LogDBClient.OnInsertCashItem( this, iBuyValue1, iBuyValue2, iPayAmt, szItemIndex, LogDBClient::CIT_POPUP,GetBillingGUID().c_str() );

	LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s User PopupItem buy Success %s:%s:[%d:%d:%d:%d]%dCash:%dPrice:%dPreCash:%I64dMoney:%I64dPreMoney:%dBonusPeso:%dPreChannelingCash:%dChannelingCash:%dPrePurchasedCash:%dPurchasedCash", __FUNCTION__, GetPublicID().c_str(), GetBillingGUID().c_str(), dwRecvUserIndex, iPresentType, iBuyValue1, iBuyValue2, GetCash(), iPayAmt, iPreCash, GetMoney(), iPreMoney, iBonusPeso, iPreChannelingCash, GetChannelingCash(), iPrePurchasedCash, GetPurchasedCash() );

	ClearBillingGUID();

	if( pLocal )
		pLocal->SendRefundCash( this, iTransactionID, false );

	LogCashItemBuyInfo(iPayAmt, iPreCash, iPrePurchasedCash, GetCash(), GetPurchasedCash(), iPresentType, iBuyValue1, iBuyValue2);
}

void User::OnConnectPopupProcess()
{
	g_DBClient.OnSelectSpentCash( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex() ); 
	g_DBClient.OnSelectPopupIndex( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPublicID(), GetUserIndex() ); 
}

void User::CheckPopupStoreIndex()
{
	//준비 안됨
	if( !m_bOnPopup )
		return;

	m_vecSendPopupIndex.clear();
	DWORD dwArray[5] = { m_dwTotalMoney, m_dwMonthMoney, GetCash(), GetGradeLevel(), m_dwTotalPlayTime } ;
	g_SpecialGoodsMgr.GetPopupStoreIndex( m_vecUsePopupIndex, m_vecSendPopupIndex, dwArray );

	int nSize = m_vecSendPopupIndex.size();
	if( nSize != 0 )
	{
		SP2Packet kPacket(STPK_POPUP_OPEN_INDEX);
		PACKET_GUARD_VOID( kPacket.Write(nSize) );

		LOOP_GUARD();
		for( int i = 0; i < nSize; ++i )
			PACKET_GUARD_VOID( kPacket.Write(m_vecSendPopupIndex[i]) );
		LOOP_GUARD_CLEAR();

		SendMessage( kPacket );
	}
}

void User::SetUserPopupIndex( std::vector<int>& vecPopupIndex )
{
	m_bOnPopup = true;
	m_vecUsePopupIndex = vecPopupIndex;
	CheckPopupStoreIndex();
}

void User::AddUsePopupIndex( int iBuyPopupIndex )
{
	int nSize = m_vecUsePopupIndex.size();
	for( int i = 0; i < nSize; ++i )
	{
		if( m_vecUsePopupIndex[i] == iBuyPopupIndex )
		{
			LOG.PrintTimeAndLog( 0, "[err][user] AddPopUpIndex duplicate %d", iBuyPopupIndex );
			return;
		}
	}

	int iPresentType = 0, iPresentValue1 = 0, iPresentValue2 = 0, iCash = 0;
	g_SpecialGoodsMgr.GetBuyPopupItem( iBuyPopupIndex, iPresentType, iPresentValue1, iPresentValue2, iCash );

	m_vecUsePopupIndex.push_back( iBuyPopupIndex );
	g_DBClient.OnInsertPopupIndex( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), iBuyPopupIndex );
	g_LogDBClient.OnInsertGameLogInfo( LogDBClient::GLT_POPUPSTORE, this, 0, 0, iBuyPopupIndex, iPresentType, iPresentValue1, iPresentValue2, iCash, NULL );
}

void User::OnPopupItemBuy( SP2Packet &rkPacket )
{
	if( !m_bOnPopup )
	{
		SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(POPUP_ITEM_NOT_READY) );
		SendMessage( kReturn );
		return;
	}

	int iPopupIndex = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iPopupIndex) );

	int iResult = 0;

	bool bFind = false;
	int nSize = m_vecSendPopupIndex.size();
	for( int i = 0; i < nSize; ++i )
	{
		if( m_vecSendPopupIndex[i] == iPopupIndex )
		{
			bFind = true;
			break;
		}
	}

	nSize = m_vecUsePopupIndex.size();
	for( int i = 0; i < nSize; ++i )
	{
		if( m_vecUsePopupIndex[i] == iPopupIndex )
		{
			iResult = POPUP_ITEM_SENDINDEX_ERROR;
			break;
		}
	}

	if( bFind == false )
	{
		iResult = POPUP_ITEM_SENDINDEX_ERROR;
	}

	if( IsBillingWait() ) // 빌링응답을 기다리는 중
	{
		iResult = POPUP_ITEM_BILLING_WAIT;
	}  

	int iPresentType = 0, iPresentValue1 = 0, iPresentValue2 = 0, iNeedCash = 0;
	bool bResult = g_SpecialGoodsMgr.GetBuyPopupItem( iPopupIndex, iPresentType, iPresentValue1, iPresentValue2, iNeedCash );
	if( bResult == false )
	{
		iResult = POPUP_ITEM_LIST_NOT_HAVE;
	}

	if( GetCash() < iNeedCash )
	{
		iResult = POPUP_ITEM_CASH_FAIL;
	}

	ioChannelingNodeParent* pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode  )
	{
		iResult = POPUP_ITEM_BILLING_FAIL;
	}

	//fail
	if( iResult > 0 )
	{
		LOG.PrintTimeAndLog( 0, "[err] User::OnPopupItemBuy - User(%s), UID(%u) Result(%d)", GetPublicID().c_str(), GetUserIndex(), iResult );

		SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
		kReturn << iResult;
		SendMessage( kReturn );
		return;
	}


	char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
	Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
	m_szBillingGUID = szTempGUID;
	SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );
	PACKET_GUARD_VOID( kBillingPacket.Write((int) GetChannelingType()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(m_szBillingGUID) );
	PACKET_GUARD_VOID( kBillingPacket.Write( iNeedCash ));
	PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicID()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicIP()) );
	PACKET_GUARD_VOID( kBillingPacket.Write(iNeedCash) );
	PACKET_GUARD_VOID( kBillingPacket.Write(OUTPUT_CASH_POPUP) );
	PACKET_GUARD_VOID( kBillingPacket.Write((short)iPresentType) );
	PACKET_GUARD_VOID( kBillingPacket.Write(iPresentValue1) );
	PACKET_GUARD_VOID( kBillingPacket.Write(iPresentValue2) );
	PACKET_GUARD_VOID( kBillingPacket.Write(iPopupIndex) );

	if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_POPUP_ITEM_BUY_RESULT, POPUP_ITEM_BILLING_FAIL, NULL, NULL ) )
		return;

	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
	if( pLocal )
		pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );

	if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s:%d:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iNeedCash );
		SP2Packet kReturn( STPK_POPUP_ITEM_BUY_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(POPUP_ITEM_BILLING_DISCONNECT) );
		SendMessage( kReturn );
		m_szBillingGUID.Clear();
	}
	else
	{
		//[HRYOON구매] 유저 구매 중인 상태로 변경함
		SetOutputStatus( true );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnPopupItemBuy Status(true) change : %s:%s", GetPublicID().c_str(), m_szBillingGUID.c_str() );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]%s Step 3 : %s:%d:%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), m_szBillingGUID.c_str(), iNeedCash );
	}
}

void User::OnDaumAdultCheckRsp(SP2Packet &rkPacket )
{
	bool bAdult = false;

	PACKET_GUARD_VOID( rkPacket.Read(bAdult) );

	if( !bAdult )
		SetShutDownUser( true );


	bool bExitUser = false;
	if( g_ShutDownMgr.IsActive() && !bAdult )
		bExitUser = true;

	SP2Packet kPacket( STPK_SHUT_DOWN_USER );
	PACKET_GUARD_VOID( kPacket.Write(!bAdult) );		//shutdown user
	PACKET_GUARD_VOID( kPacket.Write(bExitUser ) );

	SendMessage( kPacket );

	if( !bExitUser )
		g_DBClient.OnSelectUserData( GetUserDBAgentID(), GetAgentThreadID(), GetGUID(), GetPrivateID() );      
}

void User::LogCashItemBuyInfo(const int iItemPrice, const int iPreTotalCash, const int iPreRealCash, const int iCurTotalCash, const int iCurRealCash, const int iItemType, const int iItemCode, const int iItemCount)
{
	if( GetChannelingType() == CNT_WEMADEBUY )
	{
		int iPreBonusCash = iPreTotalCash - iPreRealCash;
		int iCurBonusCash = iCurTotalCash - iCurRealCash;

		if( iPreBonusCash != iCurBonusCash )
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_SPEND_CASH, this, 0, iItemPrice, LogDBClient::SCT_BONUS_CASH, iItemType, iItemCode, iItemCount, iPreBonusCash - iCurBonusCash, NULL);

		if( iPreRealCash != iCurRealCash )
			g_LogDBClient.OnInsertGameLogInfo(LogDBClient::GLT_SPEND_CASH, this, 0, iItemPrice, LogDBClient::SCT_REAL_CASH, iItemType, iItemCode, iItemCount, iPreRealCash - iCurRealCash, NULL);
	}
}

bool User::IsExistMedalItem(const DWORD dwCode, bool bPermanentItem, int iSearchingType)
{
	ioUserMedalItem* pItem = GetUserMedalItem();
	ioUserMedalItem::MEDALITEMSLOT rkMedalItem;

	if( !pItem )
		return false;

	if( IST_EQUIP == iSearchingType )
	{
		//추후 장착 중인 장비도 소유 중인지 체크하려면 필요..
		return false;
	}
	else if( IST_RELEASE == iSearchingType )
	{
		if( !pItem->GetNotEquipMedalItem(dwCode, rkMedalItem) )
			return false;
	}
	else
	{
		if( !pItem->GetMedalItem(dwCode, rkMedalItem) )
			return false;
	}

	return true;
}

bool User::IsExistCostumeItem(const DWORD dwIndex, bool bPermanentItem, int iSearchingType)
{
	ioUserCostume* pItem = GetUserCostume();
	int iPeriodType = PCPT_TIME;

	if( !pItem )
		return false;

	Costume* pCostume = pItem->GetCostume(dwIndex);

	if( !pCostume )
		return false;

	if( bPermanentItem )
		iPeriodType = PCPT_MORTMAIN;

	if( pCostume->GetPeriodType() != iPeriodType )
		return false;

	if( IST_EQUIP == iSearchingType )
	{	
		if( pCostume->GetWearingClass() == 0 )
			return false;
	}
	else if( IST_RELEASE == iSearchingType )
	{
		if( pCostume->GetWearingClass() != 0 )
			return false;
	}

	return true;
}

bool User::DoHaveAItem(const int iType, const DWORD dwCode, bool bPermanentItem, int iSearchingType)
{
	switch( iType )
	{
	case PRESENT_MEDALITEM:
		if( IsExistMedalItem(dwCode, bPermanentItem, iSearchingType) )
			return true;

	case PRESENT_COSTUME:
		if( IsExistCostumeItem(dwCode, bPermanentItem, iSearchingType) )
			return true;
	}

	return false;
}

bool User::DeleteItem(int iType, DWORD dwCode)
{
	switch( iType )
	{
	case PRESENT_MEDALITEM:
		{
			ioUserMedalItem::MEDALITEMSLOT kSlot;
			int iMedalListArrayIndex = 0;
			ioUserMedalItem* pItem = GetUserMedalItem();

			if( !pItem )
				return false;

			if( !pItem->GetNotEquipMedalItem( dwCode, kSlot, iMedalListArrayIndex ) )
				return false;

			if( !pItem->DeleteMedalItem(dwCode, iMedalListArrayIndex) )
				return false;
		}
		return true;

	case PRESENT_COSTUME:
		{
			ioUserCostume* pItem = GetUserCostume();

			if( !pItem )
				return false;

			pItem->DeleteCostumeItem(dwCode);
		}
		return true;
	}

	return false;
}

bool User::IsExistMedalItemAsCount(const DWORD dwCode,  bool bPermanentItem, int iSearchingType, int iCount)
{
	ioUserMedalItem* pItem = GetUserMedalItem();

	if( !pItem )
		return false;

	if( IST_RELEASE == iSearchingType )
	{
		int iMedalCount = pItem->GetNotEquipMedalItemCount(dwCode);
		if( iCount > iMedalCount )
			return false;

		return true;
	}

	return false;
}

#ifdef ANTIHACK
void User::UpdateSeed( DWORD dwRand )
{
	DWORD dwNewRand = TIMEGETTIME() % (dwRand + 1);
	IORandom kRandom;
	kRandom.SetRandomSeed( dwNewRand );
	m_dwUserSeed = kRandom.Random( MAX_PASS_SEED_VALUE_USER, 1000000 );
	m_dwNPCSeed = kRandom.Random( MAX_PASS_SEED_VALUE_NPC, 1000000 );

	//CheatLOG.PrintTimeAndLog( 0, "Update Seed UIDX(%u) seed(%u/%u)", GetUserIndex(), m_dwUserSeed, m_dwNPCSeed );
}

void User::UpdateSpPotion()
{
	Room* pMyRoom = GetMyRoom();
	if( !pMyRoom )
		return;
	int iRoomIndex = pMyRoom->GetRoomIndex();

	g_Relay.UpdateSPPotion( iRoomIndex, GetUserIndex() );
}

#endif

void User::SetUserSpentMoney( DWORD dwTotal, DWORD dwMonth, DWORD dwTotalPlayTime )
{
	m_dwTotalMoney = dwTotal;
	m_dwMonthMoney = dwMonth;
	m_dwTotalPlayTime = dwTotalPlayTime;	
}

void User::OnBuyRisingGashapon( SP2Packet &rkPacket )
{
	if( IsBillingWait() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s %s Billing Wait %s", __FUNCTION__, GetPublicID().c_str(), m_szBillingGUID.c_str() );
		SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_BILLING_WAIT) );
		SendMessage( kReturn );
		return;
	}

	int iEtcItemType = 0;
	bool bCash = false;
	PACKET_GUARD_VOID( rkPacket.Read(iEtcItemType) );
	PACKET_GUARD_VOID( rkPacket.Read(bCash) );

	if(!COMPARE(iEtcItemType, ioEtcItem::EIT_ETC_RISING_GASHAPON_001, ioEtcItem::EIT_ETC_RISING_GASHAPON_MAX))
	{
		SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - EtcItem Type Error -%s : %d", __FUNCTION__ , GetPublicID().c_str(), iEtcItemType );
		return;
	}

	ioEtcItem* pEtcItem = g_EtcItemMgr.FindEtcItem( iEtcItemType );
	if( !pEtcItem )
	{
		SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
		SendMessage( kReturn );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Fail - EtcItem NULL -%s : %d", __FUNCTION__ , GetPublicID().c_str(), iEtcItemType );
		return;
	}

	if( GetEntryType() == ET_TERMINATION )
	{
		SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
		PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
		SendMessage( kReturn );	
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Entry Type Error - %s : %d", __FUNCTION__,GetPublicID().c_str(), GetEntryType() );
		return;
	}


	if(bCash)
	{
		// 캐쉬구매
		// 카운트로 가격 가져오기
		// 카운트 초기화 저장 생각 해보자.
		int iBuyCash = pEtcItem->GetCash( m_nRisingBuyCount );
		if( iBuyCash <= 0 )
		{
			SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
			PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
			SendMessage( kReturn );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Price Error - %s(%d) : %d : %d : %d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iBuyCash, iEtcItemType );
			return;
		}

		ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
		if( !pNode  )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s pNode == NULL. : %d:%s:%s:%d", __FUNCTION__, GetUserIndex(), GetPublicID().c_str(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
			PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
			SendMessage( kReturn );
			return;
		}

		if( !pNode->CheckRequestOutputCash( this, iBuyCash, STPK_BUY_RISING_GASHAPON_RESULT, BUY_RISING_GASHAPON_BILLING_WANT_OF_CASH ) )
			return;

		char szTempGUID[USER_GUID_NUM_PLUS_ONE]="";
		Help::GetGUID( szTempGUID, sizeof(szTempGUID) );
		m_szBillingGUID = szTempGUID;
		SP2Packet kBillingPacket( BSTPK_OUTPUT_CASH );

		PACKET_GUARD_VOID( kBillingPacket.Write((int) GetChannelingType()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(m_szBillingGUID) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetUserIndex()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetPrivateID()) );
		PACKET_GUARD_VOID( kBillingPacket.Write(GetPublicIP()) );

		PACKET_GUARD_VOID( kBillingPacket.Write(iBuyCash) );
		PACKET_GUARD_VOID( kBillingPacket.Write(OUTPUT_CASH_ETC) );
		PACKET_GUARD_VOID( kBillingPacket.Write(iEtcItemType) );
		PACKET_GUARD_VOID( kBillingPacket.Write(m_nRisingBuyCount) );

		if( !pNode->AddRequestOutputCashPacket( this, kBillingPacket, STPK_BUY_RISING_GASHAPON_RESULT, BUY_RISING_GASHAPON_BILLING_FAIL, NULL, NULL ) )
		{
			return;
		}

		ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
		if( pLocal )
		{
			pLocal->FillRequestOutputCash( this, kBillingPacket, NULL );
		}

		if( !g_BillingRelayServer.SendMessage( kBillingPacket ) )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Cash Send Fail : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );
			SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
			PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_BILLING_DISCONNECT) );
			SendMessage( kReturn );
			m_szBillingGUID.Clear();
		}
		else
		{
			//[HRYOON구매] 유저 구매 중인 상태로 변경함
			SetOutputStatus( true );
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[GOLD_INFO]User::OnBuyRisingGashapon Status(true) change : %s:%s:%d", GetPublicID().c_str(), m_szBillingGUID.c_str(), iBuyCash );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "[GOLD_INFO]%s Cash Send : %s(%d):%s:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), GetBillingGUID().c_str(), iBuyCash );	
		}

	}
	else
	{
		// 페소구매
		int iPeso = pEtcItem->GetPeso( m_nRisingBuyCount );
		if( iPeso <= 0 )
		{
			SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
			PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
			SendMessage( kReturn );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s Peso price Error - %s(%d) itemType = %d : %d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iEtcItemType, iPeso );
			return;
		}

		if( GetMoney() < iPeso )
		{
			SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
			PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_EXCEPTION) );
			SendMessage( kReturn );	
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "%s out of money - %s(%d) itemType = %d  %I64d:%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iEtcItemType, GetMoney(), iPeso );
			return;
		}


		short iType = 0;
		int iValue1 = 0;
		int iValue2 = 0;
		int iPresentIndex = 0;
		if( g_PresentHelper.SendRandPresentByRisingGashapon( this, iEtcItemType, STPK_BUY_RISING_GASHAPON_RESULT, BUY_RISING_GASHAPON_OK, iType, iValue1, iValue2, iPresentIndex ) )
		{



			// 적절한 돈이 있으니 페소 제거.
			RemoveMoney( iPeso );

			char szItemIndex[MAX_PATH]="";
			StringCbPrintf( szItemIndex, sizeof( szItemIndex ), "rising-gashapon-%u count %d get peso - %d, %d, %d", iEtcItemType, m_nRisingBuyCount + 1, iType, iValue1, iValue2 ); // db field는 1부터 이므로 +1
			g_LogDBClient.OnInsertEtc( this, iEtcItemType, pEtcItem->GetValue( m_nRisingBuyCount ), iPeso, szItemIndex, LogDBClient::ET_BUY );



			// 선물 겟.
			//패킷을 보내자
			SP2Packet kReturn( STPK_BUY_RISING_GASHAPON_RESULT );
			PACKET_GUARD_VOID( kReturn.Write(BUY_RISING_GASHAPON_OK) );
			PACKET_GUARD_VOID( kReturn.Write(iType) );
			PACKET_GUARD_VOID( kReturn.Write(iValue1) );
			PACKET_GUARD_VOID( kReturn.Write(iValue2) );
			PACKET_GUARD_VOID( kReturn.Write(GetMoney()) );
			PACKET_GUARD_VOID( kReturn.Write(GetCash()) );
			PACKET_GUARD_VOID( kReturn.Write(GetChannelingCash()) );
			SendMessage( kReturn );

			SaveUserData();
			SendPresentMemory();


			// 뽑은 아이템 인덱스 추가
			AddRisingGetIndex(iPresentIndex);

			g_LogDBClient.OnInsertGameLogInfo( LogDBClient::GLT_RISING_GASHA, this, 0, iValue1, LogDBClient::RGT_BUY_PESO, iType, iValue2, m_nRisingBuyCount, iPeso, NULL );
			LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "%s buy peso Ok %s(%d) - %d - %d - %d - %d -%d -%d", __FUNCTION__, GetPublicID().c_str(), GetUserIndex(), iEtcItemType, iPeso, m_nRisingBuyCount, iType, iValue1, iValue2 );
		}
	}
}

void User::OnInitRisingGashapon( SP2Packet &rkPacket )
{
	InitRisingGetIndex();
}

void User::CopyLadderUserList( std::vector<int>& vLadderList )
{
	vLadderList.assign( m_ladderList.begin(), m_ladderList.end() );
}

void User::CreateTutorialChar()
{
	CHARACTER kCharInfo;
    
	kCharInfo.m_class_type		= 6;
	kCharInfo.m_iLimitSecond	= 0;
	kCharInfo.m_ePeriodType		=  CPT_MORTMAIN;

	g_DBClient.OnInsertCharData( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), kCharInfo );

	//튜토리얼 완료 처리 및 AI모드진행 상태값으로 변경.
	m_user_data.m_user_state	= US_TUTORIAL_CLEAR;
	bTutorial	= TRUE;
}

int User::GetCountRSoldier()
{
	int iCount	= 0;

	for( int i=0 ; i < GetCharCount() ; i++ )
	{
		if( !m_CharList[i]->IsActive() ) continue;
		if( (m_CharList[i]->GetClassType() < R_SOLDIER_START_NUM) || (m_CharList[i]->GetClassType() > R_SOLDIER_END_NUM) ) continue;
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		if( !m_CharList[i]->IsMortmain() )	continue;

		iCount++;
	}

	return iCount;
}

bool User::IsRSoldier(ioCharacter *pChar)
{
	if( !pChar )
		return false;

	if( !pChar->IsActive() ) return false;
	if( (pChar->GetClassType() < R_SOLDIER_START_NUM) || (pChar->GetClassType() > R_SOLDIER_END_NUM) ) return false;
	if( !pChar->HasExerciseStyle( EXERCISE_NONE ) ) return false;
	if( !pChar->IsMortmain() )	return false;

	return true;
}

void User::OnEnterGuildRoom(SP2Packet &kPacket )
{
	DWORD dwMapIndex	= 0;
	DWORD dwGuildIndex	= GetGuildIndex();
	if( !IsGuild() )
	{
		//실패 패킷.
		SP2Packet kPacket(STPK_SEARCH_PLAZA_ROOM);
		PACKET_GUARD_VOID( kPacket.Write(SEARCH_TRAINING_ERROR_11) );
		SendMessage(kPacket);
		return;
	}

	if( !m_UserGuild.IsActiveGuildRoom() )
	{
		SP2Packet kPacket(STPK_SEARCH_PLAZA_ROOM);
		PACKET_GUARD_VOID( kPacket.Write(SEARCH_TRAINING_ERROR_11) );
		SendMessage(kPacket);
		return;
	}

	PACKET_GUARD_VOID( kPacket.Read(dwMapIndex) );

	//메인서버에 해당 길드룸이 존재 하는지 확인 및 룸 번호 가져온다.
	SP2Packet msPacket(MSTPK_REQ_GUILD_ROOM_INDEX);
	PACKET_GUARD_VOID( msPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( msPacket.Write(dwGuildIndex) );
	PACKET_GUARD_VOID( msPacket.Write(dwMapIndex) );
	
	g_MainServer.SendMessage(msPacket);
}

void User::ResultGuildRoomReq(SP2Packet &kPacket )
{
	DWORD dwGuildIndex	= 0;
	DWORD dwRoomIndex	= 0;
	DWORD dwMapIndex	= 0;
	int iResult	= 0;

	PACKET_GUARD_VOID( kPacket.Read(dwGuildIndex) );
	PACKET_GUARD_VOID( kPacket.Read(dwMapIndex) );
	PACKET_GUARD_VOID( kPacket.Read(iResult) );

	if( GetGuildIndex() != dwGuildIndex )
	{
		//에러 패킷
		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_11 ) );
		SendMessage(kPacket);
		return;
	}

	switch( iResult )
	{
	case GUILD_ROOM_INFO:
		{
			PACKET_GUARD_VOID( kPacket.Read(dwRoomIndex) );

			//입장 처리.
			EnterGuildRoom(dwRoomIndex, false);
		}
		break;

	case GUILD_ROOM_CREATE:
		{
			//방 생성 후 입창 처리.
			CreateGuildRoom(dwMapIndex);
		}
		break;

	default:
		{
			//error 패킷 전송.
			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_12 ) );
			SendMessage(kPacket);
		}
		break;
	}
}

void User::CreateGuildRoom(DWORD dwMapIndex)
{
	// 룸이 적은 서버에 생성 시킨다
	ioHashString szPlazaName, szPlazaPW;
	int iMaxPlayer	= 0, iSubIndex	= dwMapIndex, iPlazaType	= 0;
	bool bResult = false;
	DWORD dwServerIndex = 0;

	SetPlazaInfoWithGuild( iMaxPlayer, iPlazaType );

	bResult = g_ServerNodeManager.GetSelectPlazaServer( g_RoomNodeManager.GetPlazaNodeSize(), dwServerIndex );
	if( bResult )
	{
		if( 0 == dwServerIndex )  // 현재 서버에 방을 생성한다
		{
			bResult = CreatePlazaInThisSvr( szPlazaName, szPlazaPW, iMaxPlayer, iSubIndex, iPlazaType, true );
		}
		else // 다른 서버에 길드 방을 생성한다
		{
			ServerNode* pSelectServer = g_ServerNodeManager.GetServerNode( dwServerIndex );
			if( pSelectServer )
			{
				//룸 생성과 동시에 해당 서버로 이동시킨다.
				SP2Packet kPacket( SSTPK_RESERVE_CREATE_GUILD_ROOM );

				PACKET_GUARD_VOID( kPacket.Write( GetGuildIndex() ) );
				//모드 정보
				PACKET_GUARD_VOID( kPacket.Write( iSubIndex ) );
				
				//광장 정보
				PACKET_GUARD_VOID( kPacket.Write( szPlazaName ) );
				PACKET_GUARD_VOID( kPacket.Write( szPlazaPW ) );
				PACKET_GUARD_VOID( kPacket.Write( iMaxPlayer ) );

				//유저 정보
				PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
	    
				pSelectServer->SendMessage( kPacket );
			}
			else
			{
				bResult = false;
			}
		}
	}

	if( !bResult )
	{
		// 방을 생성할 수 있는 곳이 없다
		SP2Packet kPacket( STPK_CREATE_PLAZA );
		PACKET_GUARD_VOID( kPacket.Write( CREATE_PLAZA_ERROR_1 ) );
		SendMessage( kPacket );
	}
}

void User::EnterGuildRoom(const DWORD dwRoomIndex, const bool bInvite)
{
	RoomParent *pRoomParent = NULL;

	if( GetCharCount() == 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnSearchPlazaRoom ERROR : 구매/체험 용병이 없는 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );

		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_8 ) );
		SendMessage( kPacket );

		return;
	}

	if( GetEntryType() == ET_TERMINATION )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "임시가입만료 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );

		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_9 ) );
		SendMessage( kPacket );

		return;
	}
	
	if( IsReserveServerMoving() )          //서버 이동이 예약되었다.
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "서버 이동이 예약된 유저가 광장 검색 요청 : %s", GetPublicID().c_str() );

		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_10 ) );
		SendMessage( kPacket );

		return;
	}

	pRoomParent	= g_RoomNodeManager.GetJoinGlobalPlazaNodeByNum( dwRoomIndex );

	if( pRoomParent )
	{
		if( pRoomParent->GetPlazaModeType() == PT_GUILD && !IsGuild() )
		{
			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_6 ) );
			SendMessage( kPacket );
			return;
		}

		if( m_pMyRoom )
		{
			if( (RoomParent*)m_pMyRoom == pRoomParent )
			{
				// 동일 룸 
				SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
				PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_1 ) );
				SendMessage( kPacket );
				return;
			}
			else if( !m_pMyRoom->IsNoBattleModeType() )
			{
				// 이미 훈련 / 전투 룸에 입장했으면 광장 이동은 무시
				SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
				PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_5 ) );
				SendMessage( kPacket );
				return;
			}
		}

		if( pRoomParent->IsRoomFull() )       
		{
			// 인원 제한
			SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_3 ) );
			SendMessage( kPacket );
			return;
		}

		if( pRoomParent->IsRoomOriginal() )
		{
			Room *pRoom = (Room*)pRoomParent;
			// 입장
			SP2Packet kPacket( STPK_JOIN_ROOM );   
			PACKET_GUARD_VOID( kPacket.Write( JOIN_ROOM_OK ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeType() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeSubNum() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeMapNum() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRoom->GetRoomNumber() ) );
			PACKET_GUARD_VOID( kPacket.Write( (int)pRoom->GetPlazaModeType() ) );
			SendMessage( kPacket );
			EnterRoom( pRoom );

			if( m_pMyRoom )
				LOG.PrintTimeAndLog( LOG_TEST_LEVEL, "User::OnSearchPlazaRoom : %d", m_pMyRoom->GetRoomIndex() );
		}
		else
		{
			RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;
			// 룸 입장 전송
			SP2Packet kPacket( SSTPK_MOVING_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN_PLAZA ) );
			PACKET_GUARD_VOID( kPacket.Write( dwRoomIndex ) );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( GetKillDeathLevel() ) );

			pCopyRoom->SendMessage( kPacket );
		}
	}
	else
	{
		// 원하는 룸이 없다.
		SP2Packet kPacket( STPK_SEARCH_PLAZA_ROOM );
		PACKET_GUARD_VOID( kPacket.Write( SEARCH_TRAINING_ERROR_4 ) );
		SendMessage( kPacket );
	}
}

void User::GuildConstructBlock(SP2Packet &kPacket)
{
	Room* pRoom	= GetMyRoom();
	if( !pRoom )
		return ;

	GuildRoomInfos* pInfo	= g_GuildRoomBlockMgr.GetGuildRoomInfos(GetGuildIndex());
	if( !pInfo )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	if( pRoom->GetRoomIndex() != pInfo->GetGuildRoomIndex() )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	//누군가 건설 중인가?
	if( pInfo->IsConstructing(GetUserIndex()) )
	{
		//건설 중
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}
	
	if( !m_UserGuild.IsBuilder() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_AUTH_NONE) );
		SendMessage(kPacket);

		if( pInfo->GetConstructingUserIndex() == GetUserIndex() )
			pInfo->SetConstructingState(FALSE);

		return;
	}

	//설치된 최대 수 확인.
	if( pInfo->GetInstalledCount() >= g_GuildRoomBlockMgr.GetLimitedInstallCnt() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_MAX_COUNT) );
		SendMessage(kPacket);
		return;
	}

	DWORD dwItemCode	= 0;
	DWORD iXZIndex		= 0;
	DWORD iY			= 0;
	BYTE  byDirection	= 0;

	PACKET_GUARD_VOID( kPacket.Read(dwItemCode) );

	//길드 인벤 수량 확인.
	if( g_ServerGuildInvenMgr.GetItemCount(GetGuildIndex(), dwItemCode) <= 0 )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_SHORTAGE) );
		SendMessage( kPacket );
		return;
	}

	PACKET_GUARD_VOID( kPacket.Read(iXZIndex) );
	PACKET_GUARD_VOID( kPacket.Read(iY) );
	PACKET_GUARD_VOID( kPacket.Read(byDirection) );

	//위치 검증.
	if( !g_GuildRoomBlockMgr.IsRightPosition(GetGuildIndex(), dwItemCode, iXZIndex, iY, byDirection) )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_POS_INVALID) );
		SendMessage( kPacket );
		return;
	}

	//DB에 상태값 변경 요청.
	g_DBClient.OnConstructOrMoveBlock(GetGuildIndex(), pRoom->GetRoomIndex(), GetPublicID(), 0, dwItemCode, GBT_CONSTRUCT, iXZIndex, iY, byDirection, GetUserIndex());
}

void User::PersonalHQConstructBlock(SP2Packet &kPacket)
{
	Room* pRoom	= GetMyRoom();
	if( !pRoom )
		return ;

	if( pRoom->GetModeType() != MT_HOUSE )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	Mode* pMode	= pRoom->GetModeInfo();
	if( !pMode )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_BLOCK);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	HouseMode* pInfo	= static_cast<HouseMode*>(pMode);
	if( pInfo->GetMasterIndex() != GetUserIndex() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_BLOCK);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	DWORD dwItemCode	= 0;
	DWORD iXZIndex		= 0;
	DWORD iY			= 0;
	BYTE  byDirection	= 0;

	PACKET_GUARD_VOID( kPacket.Read(dwItemCode) );

	int iCount	= m_PersonalHQInven.GetItemCount(dwItemCode);
	if( iCount <= 0 )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_SHORTAGE) );
		SendMessage( kPacket );
		return;
	}

	PACKET_GUARD_VOID( kPacket.Read(iXZIndex) );
	PACKET_GUARD_VOID( kPacket.Read(iY) );
	PACKET_GUARD_VOID( kPacket.Read(byDirection) );

	//위치 검증.
	if( !g_PersonalRoomBlockMgr.IsRightPosition(GetUserIndex(), dwItemCode, iXZIndex, iY, byDirection) )
	{
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_POS_INVALID) );
		SendMessage( kPacket );
		return;
	}

	//DB에 상태값 변경 요청.
	g_DBClient.OnPersonalHQConstructBlock(GetUserDBAgentID(), GetAgentThreadID(), pRoom->GetRoomIndex(), GetPublicID(), 0, dwItemCode, iXZIndex, iY, byDirection, GetUserIndex());
}

void User::OnConstructBlock(SP2Packet &kPacket )
{
	BYTE byModeType	= 0;
	PACKET_GUARD_VOID( kPacket.Read(byModeType) );

	//방에 입장 해 있으면서 길드 본부인지 확인.
	Room* pRoom	= GetMyRoom();
	if( !pRoom )
	{
		//방에 입장해 있지 않다.
		SP2Packet kPacket( STPK_CONSTRUCT_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write(byModeType) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	switch( byModeType )
	{
	case BMT_GUILD:
		GuildConstructBlock(kPacket);
		break;

	case BMT_PERSONAL:
		PersonalHQConstructBlock(kPacket);
		break;
	}

}

void User::GuildRetrieveBlock(SP2Packet &kPacket)
{
	Room* pRoom	= GetMyRoom();
	if( !pRoom )
		return ;

	GuildRoomInfos* pInfo	= g_GuildRoomBlockMgr.GetGuildRoomInfos(GetGuildIndex());
	if( !pInfo )
	{
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	if( pRoom->GetRoomIndex() != pInfo->GetGuildRoomIndex() )
	{
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK  );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	//누군가 건설 중인가?
	if( pInfo->IsConstructing(GetUserIndex()) )
	{
		//실패
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	if( !m_UserGuild.IsBuilder() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_AUTH_NONE) );
		SendMessage(kPacket);

		if( pInfo->GetConstructingUserIndex() == GetUserIndex() )
			pInfo->SetConstructingState(FALSE);

		return;
	}

	__int64 dwItemIndex	= 0;

	PACKET_GUARD_VOID( kPacket.Read(dwItemIndex) );

	//설치되어 있는 아이템 인지 확인.
	if( !g_GuildRoomBlockMgr.IsConstructedBlockAtGuildRoom(GetGuildIndex(), dwItemIndex) )
	{
		//설치 되어진 블럭이 아니다.
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_NONE_INFO) );
		SendMessage( kPacket );
		LOG.PrintTimeAndLog(0, "[%s] : is not construct, itemIndex = %d", __FUNCTION__, dwItemIndex);
		return;
	}

	DWORD dwItemCode	= pInfo->GetBlockItemCode(dwItemIndex);
	if( 0 == dwItemCode )
	{
		//설치 되어진 블럭이 아니다.
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_NONE_INFO) );
		SendMessage( kPacket );
		LOG.PrintTimeAndLog(0, "[%s] : Can't find block itemCode, itemCode = %d", __FUNCTION__, dwItemCode);
		return;
	}

	g_DBClient.OnRetrieveOrDeleteBlock(GetGuildIndex(), pRoom->GetRoomIndex(), dwItemIndex, GBT_RETRIEVE, GetPublicID(), GetUserIndex(), dwItemCode);
}

void User::PersonalHQRetrieveBlock(SP2Packet &kPacket)
{
	Room* pRoom	= GetMyRoom();
	if( !pRoom )
		return ;

	if( pRoom->GetModeType() != MT_HOUSE )
	{
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	Mode* pMode	= pRoom->GetModeInfo();
	if( !pMode )
	{
		SP2Packet kPacket(STPK_RETRIEVE_BLOCK);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	HouseMode* pHouseMode	= static_cast<HouseMode*>(pMode);
	if( pHouseMode->GetMasterIndex() != GetUserIndex() )
	{
		SP2Packet kPacket(STPK_RETRIEVE_BLOCK);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	PersonalHomeInfo* pInfo	= g_PersonalRoomBlockMgr.GetPersonalRoomInfo(GetUserIndex());
	if( !pInfo )
	{
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK  );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	__int64 dwItemIndex	= 0;

	PACKET_GUARD_VOID( kPacket.Read(dwItemIndex) );

	//설치되어 있는 아이템 인지 확인.
	if( !g_PersonalRoomBlockMgr.IsConstructedBlockAtRoom(GetUserIndex(), dwItemIndex) )
	{
		//설치 되어진 블럭이 아니다.
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_NONE_INFO) );
		SendMessage( kPacket );
		return;
	}

	DWORD dwItemCode	= pInfo->GetBlockItemCode(dwItemIndex);
	if( 0 == dwItemCode )
	{
		//설치 되어진 블럭이 아니다.
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_NONE_INFO) );
		SendMessage( kPacket );
		return;
	}

	//해제 요청.
	g_DBClient.OnPersonalHQRetrieveBlock(GetUserDBAgentID(), GetAgentThreadID(), pRoom->GetRoomIndex(), dwItemIndex, GBT_RETRIEVE, GetPublicID(), GetUserIndex(), dwItemCode);
}

void User::OnRetrieveBlock(SP2Packet &kPacket )
{
	BYTE byModeType	= 0;
	PACKET_GUARD_VOID( kPacket.Read(byModeType) );

	//방에 입장 해 있으면서 길드 본부인지 확인.
	Room* pRoom	= GetMyRoom();
	if( !pRoom )
	{
		//방에 입장해 있지 않다.
		SP2Packet kPacket( STPK_RETRIEVE_BLOCK  );
		PACKET_GUARD_VOID( kPacket.Write(byModeType) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)RETRIEVE_BLOCK_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	switch( byModeType )
	{
	case BMT_GUILD:
		GuildRetrieveBlock(kPacket);
		break;

	case BMT_PERSONAL:
		PersonalHQRetrieveBlock(kPacket);
		break;
	}

	
}

void User::GuildConstructMode(BYTE byType)
{
	Room* pRoom		= GetMyRoom();

	if( !pRoom )
		return;

	if( 0 == GetGuildIndex() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}
	
	GuildRoomInfos* pInfo	= g_GuildRoomBlockMgr.GetGuildRoomInfos(GetGuildIndex());
	if( !pInfo )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}

	if( pRoom->GetRoomIndex() != pInfo->GetGuildRoomIndex() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage( kPacket );
		return;
	}
	
	if( pInfo->IsConstructing(GetUserIndex()) )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_PROGRESSING) );
		SendMessage(kPacket);
		return;
	}

	switch( byType )
	{
	case CONSTRUCT_ON:
		{
			if( !m_UserGuild.IsBuilder() )
			{
				SP2Packet kPacket(STPK_CONSTRUCT_MODE);
				PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
				PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_AUTH_NONE) );
				SendMessage(kPacket);
				return;
			}

			g_GuildRoomBlockMgr.SetConstructingState(GetGuildIndex(), TRUE, GetUserIndex());

			// 인벤토리 정보 갱신.
			g_ServerGuildInvenMgr.RequestGuildInvenData(GetGuildIndex(), GetUserIndex(), CONSTRUCT_MODE);
		}
		break;

	case CONSTRUCT_OFF:
		{
			g_GuildRoomBlockMgr.SetConstructingState(GetGuildIndex(), FALSE);

			SP2Packet kPacket(STPK_CONSTRUCT_MODE);
			PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_GUILD) );
			PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_CHANGE_SUCCESS) );
			PACKET_GUARD_VOID( kPacket.Write(byType) );
			PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

			pRoom->RoomSendPacketTcp(kPacket);
			return;
		}
		break;
	}
}

void User::PersonalHQConstructMode(BYTE byType)
{
	Room* pRoom		= GetMyRoom();

	if( !pRoom )
		return;

	if( pRoom->GetModeType() != MT_HOUSE )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	Mode* pMode	= pRoom->GetModeInfo();
	if( !pMode )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	HouseMode* pInfo	= static_cast<HouseMode*>(pMode);

	if( pInfo->GetMasterIndex() != GetUserIndex() )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_AUTH_NONE) );
		SendMessage(kPacket);
		return;
	}

	switch( byType )
	{
	case CONSTRUCT_ON:
		{
			//건설 모드 OK 패킷 전송.
			SP2Packet kPacket(STPK_CONSTRUCT_MODE);
			PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
			PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_CHANGE_SUCCESS) );
			PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_ON) );
			PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
			pRoom->RoomSendPacketTcp(kPacket);
		}
		break;

	case CONSTRUCT_OFF:
		{
			SP2Packet kPacket(STPK_CONSTRUCT_MODE);
			PACKET_GUARD_VOID( kPacket.Write((BYTE)BMT_PERSONAL) );
			PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_CHANGE_SUCCESS) );
			PACKET_GUARD_VOID( kPacket.Write(byType) );
			PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );

			pRoom->RoomSendPacketTcp(kPacket);
			return;
		}
		break;
	}
}

void User::OnConstructMode( SP2Packet &rkPacket )
{
	BYTE byType		= 0;
	BYTE byModeType	= 0;	

	PACKET_GUARD_VOID( rkPacket.Read(byModeType) );
	PACKET_GUARD_VOID( rkPacket.Read(byType) );

	if( !COMPARE(byType, CONSTRUCT_ON, CONSTRUCT_OFF+1) )
	{
		//Error
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write(byModeType) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	Room* pRoom	= GetMyRoom();
	if( !pRoom )
	{
		SP2Packet kPacket(STPK_CONSTRUCT_MODE);
		PACKET_GUARD_VOID( kPacket.Write(byModeType) );
		PACKET_GUARD_VOID( kPacket.Write((BYTE)CONSTRUCT_MODE_EXCEPTION) );
		SendMessage(kPacket);
		return;
	}

	switch( byModeType )
	{
	case BMT_GUILD:
		GuildConstructMode(byType);
		break;

	case BMT_PERSONAL:
		PersonalHQConstructMode(byType);
		break;
	}
}

void User::OnSendGuildInvenInfo( SP2Packet &rkPacket )
{
	if( !IsEnableInterval(CTPK_REQUEST_GUILD_INVEN, G_MAXDELAY_REQUESTUSERDATA) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][guildInven]Cheating : Request frequently guild inven data : [%lu]", GetUserIndex() );
		CloseConnection();
		return;
	}

	if( !IsGuild() )
	{
		//에러 패킷
		SP2Packet kPacket(STPK_GUILD_INVEN_INFO);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)REQUEST_INVEN_GUILD_DATA_NONE) );
		SendMessage( kPacket );
		return;
	}

	if( !m_UserGuild.IsActiveGuildRoom() )
	{
		SP2Packet kPacket(STPK_GUILD_INVEN_INFO);
		PACKET_GUARD_VOID( kPacket.Write((BYTE)REQUEST_INVEN_GUILD_ROOM_DISABLE) );
		SendMessage( kPacket );
		return;
	}

	g_ServerGuildInvenMgr.RequestGuildInvenData(GetGuildIndex(), GetUserIndex(), INVEN_OPEN);
}

void User::ActiveUserGuildRoom()
{
	m_UserGuild.ActiveGuildRoom();

	//입장 가능 하다는걸 패킷 전송.
	SP2Packet kPacket(STPK_GUILD_ROOM_ACTIVE);
	PACKET_GUARD_VOID( kPacket.Write(GUILD_ROOM_ACTIVE_SUCCESS) );
	SendMessage(kPacket);
}

void User::OnTestCheckHousingInfo( SP2Packet &rkPacket )
{
	if( !IsDeveloper() || !IsGuild() )
		return;

	g_GuildRoomBlockMgr.SendBlockVerifyInfo(GetGuildIndex(), this);
}

void User::OnJoinPersonalHQ( SP2Packet &rkPacket )
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		// 이미 훈련 / 전투 룸에 입장했으면 본부 이동은 무시
		SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ALREADY_BATTLE ) );
		SendMessage( kPacket );		
	}
	else if( IsBattleRoom() )
	{
		SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ALREADY_BATTLE ) );
		SendMessage( kPacket );		
	}
	else if( IsLadderTeam() )
	{
		SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ALREADY_BATTLE ) );
		SendMessage( kPacket );		
	}
	else if( IsReserveServerMoving() ) 
	{
		//서버 이동이 예약되었다.
		SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ALREADY_BATTLE ) );
		SendMessage( kPacket );				
	}
	else
	{
		// 본부 정보
		bool bInvited	= false;
		int iMapIndex	= 0;
		ioHashString szOwnerName;

		PACKET_GUARD_VOID( rkPacket.Read( szOwnerName ) );
		PACKET_GUARD_VOID( rkPacket.Read( iMapIndex ) );
		PACKET_GUARD_VOID( rkPacket.Read( bInvited ) );

		//if( IsDeveloper() )  // 개발자는 항상 초대받은거로 처리
		//	bInvited = true;
		
		UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szOwnerName );
		if( pUserParent == NULL )
		{
			// 오너가 오프라인
			SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_OWNER_OFFLINE ) );
			SendMessage( kPacket );
		}
		else if( pUserParent->IsUserOriginal() )
		{
			User *pUser = static_cast< User * >( pUserParent );
			pUser->_OnJoinPersonalHQ( this, iMapIndex, bInvited );
		}
		else
		{
			UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );

			SP2Packet kPacket( SSTPK_JOIN_PERSONAL_HQ_USER );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( pUser->GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( iMapIndex ) );
			PACKET_GUARD_VOID( kPacket.Write( bInvited ) );
			
			pUser->SendMessage( kPacket );
		}
	}
}

void User::_OnJoinPersonalHQ( UserParent *pRequestUser, int iMapIndex, bool bInvited )
{
	if( pRequestUser == NULL ) return;

	if( IsReserveServerMoving() ) 
	{
		//서버 이동이 예약되었다.
		SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ALREADY_BATTLE ) );
		
		pRequestUser->RelayPacket( kPacket );				
		return;
	}

	if( !m_UserEtcItem.HaveAThisItem(ioEtcItem::EIT_ETC_CREATE_HOME) )
	{
		SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_DISABLE ) );
		SendMessage( kPacket );	
		return;
	}

	if( pRequestUser->GetPublicID() != GetPublicID() )
	{
		if( !bInvited )
		{
			if( m_pMyRoom )
			{
				if( m_pMyRoom->GetModeType() != MT_HOUSE )
				{
					SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
					PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_EXCEPTION ) );
					pRequestUser->RelayPacket( kPacket );
					return;
				}

				if( m_pMyRoom->IsRoomFull() )
				{
					SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
					PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ROOM_FULL ) );
					pRequestUser->RelayPacket( kPacket );
				}
				else
				{
					SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
					PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_JOIN_REQUEST ) );
					pRequestUser->RelayPacket( kPacket );		

					SP2Packet kPacket2( STPK_PERSONAL_HQ_JOIN_REQUEST );
					PACKET_GUARD_VOID( kPacket2.Write( pRequestUser->GetPublicID() ) );
					SendMessage( kPacket2 );
				}
				return;
			}
			else
			{
				SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
				PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_EMPTY ) );
				pRequestUser->RelayPacket( kPacket );
				return;
			}
		}
	}

	RoomParent* pRoomParent	= static_cast<RoomParent*>(m_pMyRoom);

	if( pRoomParent )
	{
		if( pRoomParent->IsRoomFull() )
		{
			SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ROOM_FULL ) );
			pRequestUser->RelayPacket( kPacket );
			return;
		}

		if( pRequestUser->GetUserIndex() != GetUserIndex() )
		{
			if( pRoomParent->GetModeType() != MT_HOUSE )
			{
				SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
				PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_EXCEPTION ) );
				pRequestUser->RelayPacket( kPacket );	
				return;
			}
		}
	}
	
	// 해당 서버에 개인 본부 있는지 확인.
	if( g_PersonalRoomBlockMgr.IsExistPersonalHQ(GetUserIndex()) )
	{
		DWORD dwRoomIndex	= g_PersonalRoomBlockMgr.GetPersonalHQIndex(GetUserIndex());
		Room *pRoom = g_RoomNodeManager.GetHeadquartersNode(dwRoomIndex);

		if( !pRoom )
		{
			SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_EXCEPTION ) );
			pRequestUser->RelayPacket( kPacket );
			return;
		}
			
		pRoomParent	= pRoom;
	}
	else
	{
		// 룸 생성
		Room *pRoom = g_RoomNodeManager.CreateNewPersonalHQRoom( iMapIndex );
		if( !pRoom)
		{
			// 메모리가 부족하다
			SP2Packet kPacket( STPK_JOIN_PERSONAL_HQ );
			PACKET_GUARD_VOID( kPacket.Write( JOIN_PERSONAL_HQ_ROOM_CREATE_FAILED ) );
			pRequestUser->RelayPacket( kPacket );				
			return;
		}

		pRoom->SetHouseModeMaster( GetPublicID(), GetUserIndex() );
		pRoom->SetMaxPlayer( MAX_PLAZA_PLAYER );
		Mode* pMode	= pRoom->GetModeInfo();
		if( pMode )
		{
			HouseMode* pHouse	= static_cast<HouseMode*>(pMode);
			pHouse->SetCreateTime();
		}

		//pRoomParent = pRoom;
		g_DBClient.OnSelectPersonalBlocksInfo(GetUserDBAgentID(), GetAgentThreadID(), pRoom->GetRoomIndex(), GetUserIndex());
		return;
	}
	
	
	if( pRoomParent )
	{
		//m_dwMyHeadquartersIndex = pRoomParent->GetRoomIndex();
		if( pRoomParent->IsRoomOriginal() )
		{
			Room *pRoom = static_cast< Room * >( pRoomParent );

			// 입장
			if( pRequestUser->IsUserOriginal() )
			{				
				User *pUser = static_cast< User * >( pRequestUser );

				SP2Packet kPacket( STPK_JOIN_ROOM );   
				PACKET_GUARD_VOID( kPacket.Write( JOIN_ROOM_OK ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeType() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeSubNum() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeMapNum() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetRoomNumber() ) );
				PACKET_GUARD_VOID( kPacket.Write( (int)pRoom->GetPlazaModeType() ) );
				
				pUser->SendMessage( kPacket );
				pUser->EnterRoom( pRoom );
			}
			else
			{
				pRoom->EnterReserveUser( pRequestUser->GetUserIndex() );

				// 해당 유저에게 입장 알림
				UserCopyNode *pUser = static_cast< UserCopyNode * >( pRequestUser );

				SP2Packet kPacket( SSTPK_MOVING_ROOM_RESULT );
				PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN ) );
				PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN_PERSONAL_HQ ) );
				PACKET_GUARD_VOID( kPacket.Write( (int)pRoom->GetModeType() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetRoomIndex() ) );
				PACKET_GUARD_VOID( kPacket.Write( pUser->GetUserIndex() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeSubNum() ) );
				PACKET_GUARD_VOID( kPacket.Write( pRoom->GetModeMapNum() ) );

				pUser->SendMessage( kPacket );
			}
		}
		else
		{
			// 본부가 진짜 있는지 확인하고 있으면 입장하고 없으면 다시 와야한다.  
			RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;
			// 룸 입장 전송
			SP2Packet kPacket( SSTPK_MOVING_ROOM );
			PACKET_GUARD_VOID( kPacket.Write( SS_MOVING_ROOM_JOIN_PERSONAL_HQ ) );
			PACKET_GUARD_VOID( kPacket.Write( pCopyRoom->GetRoomIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( pRequestUser->GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( GetUserIndex() ) );
			PACKET_GUARD_VOID( kPacket.Write( iMapIndex ) );
			PACKET_GUARD_VOID( kPacket.Write( bInvited ) );

			pCopyRoom->SendMessage( kPacket );
		}
	}
	else
	{   // 룸생성 실패
		SP2Packet kPacket( STPK_JOIN_HEADQUARTERS );
		PACKET_GUARD_VOID( kPacket.Write( JOIN_HEADQUARTERS_ROOM_CREATE_FAILED ) );

		pRequestUser->RelayPacket( kPacket );
	}
}

void User::OnPersonalHQInviteList( SP2Packet &rkPacket )
{
	if( m_pMyRoom == NULL ) return;
	if( m_pMyRoom->GetModeType() != MT_HOUSE ) return;

	int iCurPage = 0, iMaxCount = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCurPage) );
	PACKET_GUARD_VOID( rkPacket.Read(iMaxCount) );
	MAX_GUARD(iCurPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_UserNodeManager.SendPersonalHQInviteList( this, iCurPage, iMaxCount, 0 );
}

void User::OnPersonalHQJoinAgree( SP2Packet &rkPacket )
{
	if( m_pMyRoom == NULL ) return;
	if( m_pMyRoom->GetModeType() != MT_HOUSE ) return;

	ioHashString kRequestName;
	PACKET_GUARD_VOID( rkPacket.Read(kRequestName) );

	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( kRequestName );
	if( pUserParent == NULL )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnHeadquartersJoinAgree - %s - Owner Offline.", kRequestName.c_str() );
	}
	else if( pUserParent->IsUserOriginal() )
	{
		User *pUser = static_cast< User * >( pUserParent );
		pUser->_OnPersonalHQJoinAgree( m_pMyRoom->GetRoomIndex() );
	}
	else
	{
		UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );

		SP2Packet kPacket( SSTPK_PERSONAL_HQ_JOIN_AGREE );
		PACKET_GUARD_VOID( kPacket.Write(pUser->GetUserIndex()) );
		PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetRoomIndex()) );

		pUser->SendMessage( kPacket );
	}
}

void User::OnPersonalHQInfo( SP2Packet &rkPacket )
{
	// 본부 정보
	ioHashString szOwnerName;
	PACKET_GUARD_VOID( rkPacket.Read(szOwnerName) );

	UserParent *pUserParent = g_UserNodeManager.GetGlobalUserNode( szOwnerName );
	if( pUserParent == NULL )
	{
		// 오너가 오프라인
		SP2Packet kPacket( STPK_PERSONAL_HQ_INFO );
		PACKET_GUARD_VOID( kPacket.Write(szOwnerName) );
		PACKET_GUARD_VOID( kPacket.Write((MAX_PLAYER / 2)) );
		PACKET_GUARD_VOID( kPacket.Write(0) );
		SendMessage( kPacket );
	}
	else if( pUserParent->IsUserOriginal() )
	{
		User *pUser = static_cast< User * >( pUserParent );
		//pUser->_OnHeadquartersInfo( this );
		pUser->_OnPersonalHQInfo(this);
	}
	else
	{
		UserCopyNode *pUser = static_cast< UserCopyNode * >( pUserParent );

		SP2Packet kPacket( SSTPK_PERSONAL_HQ_INFO );
		PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
		PACKET_GUARD_VOID( kPacket.Write(pUser->GetUserIndex()) );
		PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
		pUser->SendMessage( kPacket );
	}
}

void User::_OnPersonalHQInfo( UserParent *pRequestUser )
{
	if( pRequestUser == NULL ) return;

	if( !m_pMyRoom )
	{
		SP2Packet kPacket( STPK_PERSONAL_HQ_INFO );
		PACKET_GUARD_VOID( kPacket.Write(GetPublicID()) );
		PACKET_GUARD_VOID( kPacket.Write((MAX_PLAYER / 2)) );
		PACKET_GUARD_VOID( kPacket.Write(0) );
			
		pRequestUser->RelayPacket( kPacket );
		return;
	}

	if( m_pMyRoom->IsRoomOriginal() )
	{
		SP2Packet kPacket( STPK_PERSONAL_HQ_INFO );
		m_pMyRoom->FillPersonalHQInfo( GetPublicID(), kPacket );
		pRequestUser->RelayPacket( kPacket );
	}
}

void User::OnPersonalHQCommand( SP2Packet &rkPacket )
{
	if( !m_pMyRoom ) return;
	if( m_pMyRoom->GetModeType() != MT_HOUSE ) return;

	int iCommand = 0;
	PACKET_GUARD_VOID( rkPacket.Read(iCommand) );

	switch( iCommand )
	{
	case PERSONAL_HQ_CMD_MAXPLAYER_CHANGE:
		{
			int iMaxPlayer = 0;
			PACKET_GUARD_VOID( rkPacket.Read(iMaxPlayer) );
			m_pMyRoom->SetMaxPlayer( iMaxPlayer );

			SP2Packet kPacket( STPK_PERSONAL_HQ_COMMAND );
			PACKET_GUARD_VOID( kPacket.Write(PERSONAL_HQ_CMD_MAXPLAYER_CHANGE) );
			PACKET_GUARD_VOID( kPacket.Write(m_pMyRoom->GetMaxPlayer()) );

			m_pMyRoom->RoomSendPacketTcp( kPacket );
		}
		break;
	case PERSONAL_HQ_CMD_KICK_OUT:
		{
			ioHashString szKickOutUser;
			PACKET_GUARD_VOID( rkPacket.Read(szKickOutUser) );
			m_pMyRoom->RoomKickOut( szKickOutUser );
		}
		break;
	}
}

void User::_OnPersonalHQJoinAgree( DWORD dwRoomIndex )
{
	if( m_pMyRoom && !m_pMyRoom->IsNoBattleModeType() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnPersonalHQJoinAgree - %d Is Battle/Ladder Room", GetUserIndex() );
	}
	else if( IsBattleRoom() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnPersonalHQJoinAgree - %d Is Battle/Ladder Room", GetUserIndex() );
	}
	else if( IsLadderTeam() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnPersonalHQJoinAgree - %d Is Battle/Ladder Room", GetUserIndex() );
	}
	else if( IsReserveServerMoving() ) 
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnPersonalHQJoinAgree - %d Already Server Moving...", GetUserIndex() );
	}
	else
	{
		RoomParent *pRoomParent = g_RoomNodeManager.GetHeadquartersGlobalNode( dwRoomIndex );
		if( pRoomParent )
		{
			if( pRoomParent->IsRoomFull() )
			{
				LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnPersonalHQJoinAgree - %d - Full HQ.", dwRoomIndex );
				return;
			}		
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::_OnPersonalHQJoinAgree - %d - None HQ.", dwRoomIndex );
			return;
		}

		if( pRoomParent )
		{
			if( pRoomParent->IsRoomOriginal() )
			{
				Room *pRoom = static_cast< Room * >( pRoomParent );

				// 입장
				SP2Packet kPacket( STPK_JOIN_ROOM );
				PACKET_GUARD_VOID( kPacket.Write(JOIN_ROOM_OK) );
				PACKET_GUARD_VOID( kPacket.Write(pRoom->GetModeType()) );
				PACKET_GUARD_VOID( kPacket.Write(pRoom->GetModeSubNum()) );
				PACKET_GUARD_VOID( kPacket.Write(pRoom->GetModeMapNum()) );
				PACKET_GUARD_VOID( kPacket.Write(pRoom->GetRoomNumber()) );
				PACKET_GUARD_VOID( kPacket.Write((int)pRoom->GetPlazaModeType()) );
				SendMessage( kPacket );
				EnterRoom( pRoom );
			}
			else
			{
				// 본부가 진짜 있는지 확인하고 입장
				RoomCopyNode *pCopyRoom = (RoomCopyNode*)pRoomParent;

				// 룸 입장 전송
				SP2Packet kPacket( SSTPK_MOVING_ROOM );
				PACKET_GUARD_VOID( kPacket.Write(SS_MOVING_ROOM_JOIN_PERSONAL_HQ_AGREE) );
				PACKET_GUARD_VOID( kPacket.Write(pCopyRoom->GetRoomIndex()) );
				PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );

				pCopyRoom->SendMessage( kPacket );
			}
		}
	}
}

void User::AddPersonalInvenItem(const DWORD dwItemCode, const int iCount)
{
	m_PersonalHQInven.AddBlockCount(dwItemCode, iCount);
}

void User::DecreasePersonalInvenItem(const DWORD dwItemCode, const int iCount)
{
	m_PersonalHQInven.DecreaseBlockCount(dwItemCode, iCount);
}

void User::OnReqPersonalHQInvenData(SP2Packet &kPacket)
{
	m_PersonalHQInven.SendInvenInfo();
}

void User::InsertUserLadderList( int competitorIndex, int ladderIndex )
{
	if( competitorIndex != 0 )
	{
		g_DBClient.OnSetLadderUserList( GetUserDBAgentID(), GetAgentThreadID(), GetUserIndex(), competitorIndex, Help::GetLaddeLimitTime(), ladderIndex );
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "UserCopyNode::InsertUserLadderList UserID:%s,UserIndex:%d,LadderTeamIndex:%d(competitorIndex:%d)", 
			GetPublicID().c_str(), GetUserIndex(),ladderIndex, competitorIndex );
	}
	else
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::InsertUserLadderList %d(competitorIndex Error)", GetUserIndex() );

}


void User::SendFreeDayEvent(DWORD dwPCRoom)
{
	SetPCRoomNumber(dwPCRoom);

	LOG.PrintTimeAndLog( 0, "User Select Hero Event [%d]", GetPCRoomNumber() );

	SP2Packet kPacket( STPK_PCROOM_AUTHORITY );
	PACKET_GUARD_VOID( kPacket.Write( GetPCRoomNumber() ) );
	PACKET_GUARD_VOID( kPacket.Write( m_UserPcRoom.GetPcRoomCharMax() ) );
	SendMessage( kPacket );
}
#ifdef ANTIHACK
void User::SetDieState()
{
	if(GetMyRoom())
		g_Relay.UpdateDieState(GetMyRoom()->GetRoomIndex(), GetUserIndex(), TRUE);
}
#endif

/****
전투룸을 검색합니다. 
검색에 성공할 경우, 해당 전투룸 인덱스에 해당하는 룸정보를 클라이언트에게 전달해 줍니다.
실패할 경우 STPK_SEARCH_ROOM_RESLUT 를 통해 실패 패킷을 클라이언트에게 전달합니다.
****/
void User::OnSearchRoom( SP2Packet &rkPacket )
{
	CheckLeaveBattleRoomIndex();

	DWORD dwBattleRoomIndex;
	rkPacket >> dwBattleRoomIndex;

	if( g_BattleRoomManager.SearchRoomIndex( this, dwBattleRoomIndex ) )
		g_BattleRoomManager.SendBattleRoomJoinInfo( (UserParent*)this, dwBattleRoomIndex, m_iLeaveBattleRoomIndex );
}

/****
기존 전투룸 대신 GM계정은 레더룸을 관전할 수 있습니다.
****/
void User::OnJoinLadderRoomList( SP2Packet &rkPacket )
{
	CheckLeaveBattleRoomIndex();

	bool bSameTeamPlayer = false;
	int iPage = 0, iMaxCount = 0, iSelectTerm = 0, iMinPlayer = 0, iMaxPlayer = 0;
	PACKET_GUARD_VOID(rkPacket.Read(iPage));
	PACKET_GUARD_VOID(rkPacket.Read(iMaxCount));
	MAX_GUARD(iPage, 300);
	MAX_GUARD(iMaxCount, 300);

	g_RoomNodeManager.SendCurLadderRoomList( this, iPage, iMaxCount );
}

void User::OnLadderRoomInfo( SP2Packet &rkPacket )
{
	CheckLeaveBattleRoomIndex();

	DWORD dwLadderRoomIndex;
	rkPacket >> dwLadderRoomIndex;
	
	g_RoomNodeManager.SendLadderRoomJoinInfo( (UserParent*)this, dwLadderRoomIndex, m_iLeaveBattleRoomIndex );
}

void User::OnLadderRoomObserverJoin( SP2Packet &rkPacket )
{
	CheckLeaveBattleRoomIndex(); //park 빼도 될거같은디? ㅋ

	bool bObserver = false;
	PACKET_GUARD_VOID( rkPacket.Read(bObserver) );

	int iPenaltyPeso = 0;
	bool bInvite = false;
	bool bMovePenalty = false ;
	PACKET_GUARD_VOID( rkPacket.Read(bInvite) );
	PACKET_GUARD_VOID( rkPacket.Read(bMovePenalty) );
	PACKET_GUARD_VOID( rkPacket.Read(iPenaltyPeso) );
	PACKET_GUARD_VOID( rkPacket.Read(m_iSearchBatleRoomIndex) );
	
	int result    = USER_BATTLEROOM_JOIN_OK;
	Room *pRoomNode = NULL;
	if( m_iSearchBatleRoomIndex == -1 )  //자동 접속.
	{		
		return; //무조건 옵져버만
	}
	else
	{
		pRoomNode = g_RoomNodeManager.GetGlobalLadderRoomNode( m_iSearchBatleRoomIndex);
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnLadderRoomObserverJoin - RoomNode TEST" );
		if( pRoomNode == NULL )
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnLadderRoomObserverJoin - RoomNode is Empty" );
			//존재하지 않는 파티입니다.
			_OnBattleRoomJoinResult( USER_BATTLEROOM_JOIN_NOT_NODE, bMovePenalty, iPenaltyPeso ); //
			return;
		}
 	}

	InitCharDie();
	g_RoomNodeManager.EnterUserToLadderRoom( this, *pRoomNode ,bObserver );
	g_UserNodeManager.UpdateUserSync( this );
	LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnLadderRoomObserverJoin - User(%s) Enter room", m_user_data.m_public_id );
}

/*******************
유저의 네트워크 정보를 채워 넣습니다.
********************/
void User::FillUserNetworkInfo( SP2Packet &rkPacket )
{
	ServerNode* node = NULL;
	ioHashString szIpAddr;
	int iPort;
	SetTransferAddress(node, szIpAddr, iPort); //for relay 
	PACKET_GUARD_VOID( rkPacket.Write( m_public_ip ) );
	PACKET_GUARD_VOID( rkPacket.Write( m_client_port ) );
	PACKET_GUARD_VOID( rkPacket.Write( m_private_ip ) );
	PACKET_GUARD_VOID( rkPacket.Write( szIpAddr ) );
	PACKET_GUARD_VOID( rkPacket.Write( iPort ) );
}

void User::FillTimeCashDate( SP2Packet &rkPacket )
{
	m_UserTimeCashTabel.FillMoveData(rkPacket);
}

void User::ApplyTimeCashDate( SP2Packet &rkPacket )
{
	m_UserTimeCashTabel.ApplyMoveData(rkPacket);
}

void User::LoginSelectCashTable(CQueryResultData *query_data)
{
	m_UserTimeCashTabel.DBToData(query_data);
}

void User::InsertCashTable(CQueryResultData *query_data)
{
	m_UserTimeCashTabel.ResultSQLInsertCashTable(query_data);
}

void User::UpdateCashTable(const DWORD dwCode, const int iResult, const DWORD dwReceiveDate, ioHashString& szBillingGUID)
{
	m_UserTimeCashTabel.DisposeUpdateReceiveData(dwCode, iResult, dwReceiveDate, szBillingGUID);
}

void User::RequestTimeCash(const DWORD dwCode, ioHashString& szBillingGUID, BOOL bFirst)
{
	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][timecash]invalid time cash billing guid : [%d][%s][%s][%d]", GetUserIndex(), szBillingGUID.c_str(), GetBillingGUID().c_str(), bFirst);
		return;
	}

	if( GetChannelingType() != CNT_WEMADEBUY )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][timecash]invalid channeling user : [%d][%d]", GetUserIndex(), bFirst);
		return;
	}

	TimeCashInfo stInfo;
	int iCash	= 0;

	g_TimeCashMgr.GetTimeCashInfo(dwCode, stInfo);
	if( 0 == stInfo.m_dwCode )
		return;

	if( bFirst )
		iCash = stInfo.m_iFirstCash;
	else
		iCash = stInfo.m_iContinueCash;

	SP2Packet kPacket( BSTPK_REQUEST_TIME_CASH );
	PACKET_GUARD_VOID( kPacket.Write(GetUserIndex()) );
	PACKET_GUARD_VOID( kPacket.Write(szBillingGUID) );
	PACKET_GUARD_VOID( kPacket.Write(stInfo.m_iEvenID) );
	PACKET_GUARD_VOID( kPacket.Write(iCash) );
	PACKET_GUARD_VOID( kPacket.Write(stInfo.m_iCashExpire) );
	PACKET_GUARD_VOID( kPacket.Write(GetPublicIP()) );
	
	g_BillingRelayServer.SendMessage( kPacket );
}

void User::OnBillingTimeCashResult(SP2Packet &rkPacket )
{
	ioHashString szBillingGUID;
	int          iReturnValue = 0;

	PACKET_GUARD_VOID( rkPacket.Read(szBillingGUID) );
	PACKET_GUARD_VOID( rkPacket.Read(iReturnValue) );

	if( BILLING_TIME_CASH_RESULT_SUCCESS != iReturnValue )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingTimeCashResult return value is invalid: [%s] [%d]", GetPublicID().c_str(), iReturnValue );
		//ClearBillingGUID();
		return;
	}

	if( szBillingGUID.IsEmpty() )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingTimeCashResult BillingGUID Is Empty: %s", GetPublicID().c_str() );
		return;
	}

	if( GetBillingGUID() != szBillingGUID )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingTimeCashResult Wrong BillingGUID: %s", GetPublicID().c_str() );
		return;
	}

	ioChannelingNodeParent *pNode = g_ChannelingMgr.GetNode( GetChannelingType() );
	if( !pNode )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::OnBillingTimeCashResult node is null: %s %d", GetPublicID().c_str(), GetChannelingType() );
		return;
	}

	_OnBillingPresentCash(rkPacket);
}

void User::_OnBillingPresentCash(SP2Packet &rkPacket)
{
	int iAddCash	= 0;
	int iCash		= 0;
	int iRealCash	= 0;

	PACKET_GUARD_VOID( rkPacket.Read(iAddCash) );
	PACKET_GUARD_VOID( rkPacket.Read(iCash) );
	PACKET_GUARD_VOID( rkPacket.Read(iRealCash) );
	SetCash( iCash );
	SetPurchasedCash( iRealCash );

	//성공 패킷!
	SP2Packet kPacket(STPK_TIME_CASH_INFO);
	PACKET_GUARD_VOID( kPacket.Write(TIME_CASH_GIVE_SUCCESS) );
	PACKET_GUARD_VOID( kPacket.Write(iAddCash) );
	PACKET_GUARD_VOID( kPacket.Write(GetCash()) );
	PACKET_GUARD_VOID( kPacket.Write(GetChannelingCash()) );
	SendMessage(kPacket);

	ClearBillingGUID();
}

void User::OnTestTournamentMacro(SP2Packet &rkPacket)
{
	int iState	= 0;
	PACKET_GUARD_VOID( rkPacket.Read(iState) );

	SP2Packet kPacket(MSTPK_TOURNAMENT_MACRO);
	PACKET_GUARD_VOID( kPacket.Write(iState) );
	g_MainServer.SendMessage(kPacket);
}

void User::UpdateUserTitleStatus()
{
	m_TitleInven.ConvertNewToActiveStatus();
}

void User::UpdateUserTitle(const DWORD dwCode, const __int64 iValue, const int iLevel, const BYTE byPremium, const BYTE byEquip, const BYTE byStatus, const BYTE byActionType)
{
	m_TitleInven.UpdateTitle(dwCode, iValue, iLevel, byPremium, byEquip, byStatus, byActionType);

	switch( byActionType )
	{
	case TUT_PREMIUM:
		{
			SP2Packet kPacket(STPK_TITLE_PREMIUM);
			PACKET_GUARD_VOID( kPacket.Write(SET_PREMIUM_TITLE_SUCCESS) );
			PACKET_GUARD_VOID( kPacket.Write(dwCode) );
			SendMessage(kPacket);
		}
		break;

	case TUT_INSERT_ETC:
		{
			SP2Packet kPacket(STPK_TITLE_ETC_USE);
			PACKET_GUARD_VOID( kPacket.Write(TITLE_ETC_USE_SUCCESS) );
			PACKET_GUARD_VOID( kPacket.Write(dwCode) );
			SendMessage(kPacket);
		}
		break;
	}
}

void User::SelectUserTitle(CQueryResultData *query_data)
{
	m_TitleInven.DBtoData(query_data);
}

void User::OnTitleChange(SP2Packet &rkPacket)
{
	bool bEquip		= false;
	DWORD dwCode	= 0;

	PACKET_GUARD_VOID( rkPacket.Read(bEquip) );
	PACKET_GUARD_VOID( rkPacket.Read(dwCode) );

	if( bEquip )
	{
		//장착
		m_TitleInven.EquipTitle(dwCode);
	}
	else
	{
		//해제
		m_TitleInven.ReleaseTitle(dwCode);
	}
}

void User::OnSyncTimeEquipTitle(SP2Packet &rkPacket)
{
	if( !IsEnableInterval(CTPK_TITLE_SYNC_EQUIP_TIME, g_TitleManager.GetMinCheckTime()) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][title]Cheating : Request frequently title premium check : [%lu]", GetUserIndex() );
		//CloseConnection();
		return;
	}

	DWORD dwCode		= 0;

	PACKET_GUARD_VOID( rkPacket.Read(dwCode) );

	m_TitleInven.PremiumLevelUpCheck(dwCode);
}

void User::OnNewTitleConfirm(SP2Packet &rkPacket)
{
	if( !IsEnableInterval(CTPK_NEW_TITLE_CONFIRM, G_MAXDELAY_REQUESTUSERDATA) )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "[warning][title]Cheating : Request frequently title renewal data : [%lu]", GetUserIndex() );
		CloseConnection();
		return;
	}

	m_TitleInven.ConfirmNewData();
}

int User::GetStartNumOfSpecialSoldier(int iSpecialType)
{
	switch( iSpecialType )
	{
	case SST_GFRIEND:
		return GFRIEND_SOLDIER_START_NUM;
	}

	return 0;
}

int User::GetEndNumOfSpecialSoldier(int iSpecialType)
{
	switch( iSpecialType )
	{
	case SST_GFRIEND:
		return GFRIEND_SOLDIER_END_NUM;
	}

	return 0;
}

int User::GetCountOfSpecialSoldier(int iSpecialType)
{
	int iCount	= 0;

	for( int i=0 ; i < GetCharCount() ; i++ )
	{
		if( !m_CharList[i]->IsActive() ) continue;
		if( GetStartNumOfSpecialSoldier(iSpecialType) == 0 ) continue;
		if( m_CharList[i]->GetClassType() < GetStartNumOfSpecialSoldier(iSpecialType) ) continue;
		if( m_CharList[i]->GetClassType() > GetEndNumOfSpecialSoldier(iSpecialType) ) continue;
		if( !m_CharList[i]->HasExerciseStyle( EXERCISE_NONE ) ) continue;
		if( !m_CharList[i]->IsMortmain() )	continue;

		iCount++;
	}

	return iCount;
}

bool User::IsSpecialSoldier(ioCharacter *pChar, int iSpecialType, BOOL bCheckMortmain)
{
	if( !pChar )
		return false;

	if( !pChar->IsActive() ) return false;
	if( GetStartNumOfSpecialSoldier(iSpecialType) == 0 ) return false;
	if( pChar->GetClassType() < GetStartNumOfSpecialSoldier(iSpecialType) ) return false;
	if( pChar->GetClassType() > GetEndNumOfSpecialSoldier(iSpecialType) ) return false;
	if( !pChar->HasExerciseStyle( EXERCISE_NONE ) ) return false;
	if( bCheckMortmain )
	{
		if( !pChar->IsMortmain() )	
			return false;
	}

	return true;
}

int User::GetSpecialSoldierType(int iClassType)
{
	if( R_SOLDIER_START_NUM <= iClassType  && iClassType <= R_SOLDIER_END_NUM )
		return SST_RSOLDIER;
	else if( GFRIEND_SOLDIER_START_NUM <= iClassType && iClassType <= GFRIEND_SOLDIER_END_NUM )
		return SST_GFRIEND;

	return SST_END;
}


void User::GiveWomanGender(int iClassType)
{
	int iCharArray	=  GetCharArrayByClass(iClassType);
	if( -1 == iCharArray )
	{
		SP2Packet kPacket(STPK_CHANGE_GENDER);
		PACKET_GUARD_VOID( kPacket.Write(CHANGE_GENDER_NON_EXIST_CHAR) );
		return;
	}

	//해당 용병 치장 있는지 확인.
	int iDecoType	= iClassType * 100000 + UID_KINDRED;
	int iCode		= 1;
	
	ITEMSLOT kSlot;
	kSlot.m_item_type = iDecoType;	
	kSlot.m_item_code = iCode;	

	if( m_Inventory.IsSlotItem(kSlot) )
		return;

	if( !m_CharList[iCharArray]->SetCharDecoration( kSlot.m_item_type, kSlot.m_item_code ) )	
	{
		SP2Packet kPacket(STPK_CHANGE_GENDER);
		PACKET_GUARD_VOID( kPacket.Write(CHANGE_GENDER_EXCEPTION) );
		return;
	}

	DWORD dwIndex = 0;
	int   iArray  = 0;

	m_Inventory.AddSlotItem( kSlot, false, 0, LogDBClient::DT_DEFAULT,  dwIndex, iArray );
	m_Inventory.SetEquipItem( kSlot.m_item_type, kSlot.m_item_code);

	if( kSlot.m_item_type % 1000 == UID_KINDRED )	
	{		
		const CHARACTER &rkCharInfo = m_CharList[iCharArray]->GetCharInfo();
		CHARACTER kCharInfo = const_cast<CHARACTER&>(rkCharInfo);
		//m_Inventory.GetEquipItemCode( rkChangeInfo );
		kCharInfo.m_sex        = 2; // 1남자, 2여자
		kCharInfo.m_face       = g_DecorationPrice.GetDefaultDecoCode( 1, UID_FACE, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_FACE, kCharInfo.m_class_type ); // 0남자, 1여자
		kCharInfo.m_hair       = g_DecorationPrice.GetDefaultDecoCode( 1, UID_HAIR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR, kCharInfo.m_class_type );
		kCharInfo.m_skin_color = g_DecorationPrice.GetDefaultDecoCode( 1, UID_SKIN_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_SKIN_COLOR, kCharInfo.m_class_type );
		kCharInfo.m_hair_color = g_DecorationPrice.GetDefaultDecoCode( 1, UID_HAIR_COLOR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_HAIR_COLOR, kCharInfo.m_class_type );	
		kCharInfo.m_underwear  = g_DecorationPrice.GetDefaultDecoCode( 1, UID_UNDERWEAR, GetPrivateID().GetHashCode() + kCharInfo.m_class_type + UID_UNDERWEAR, kCharInfo.m_class_type );	
		m_CharList[iCharArray]->SetChangeKindred( kCharInfo, GetPrivateID().GetHashCode() );
		SetDefaultDecoItem( m_CharList[iCharArray]->GetCharInfo() );
		m_UserGrowthLevel.AddCharGrowthPointByDecoWoman( kSlot.m_item_type, kSlot.m_item_code );

		SP2Packet kPacket(STPK_CHANGE_GENDER);
		PACKET_GUARD_VOID( kPacket.Write(CHANGE_GENDER_SUCCESS) );
		PACKET_GUARD_VOID( kPacket.Write(kSlot.m_item_type) );
		PACKET_GUARD_VOID( kPacket.Write(kSlot.m_item_code) );
		PACKET_GUARD_VOID( kPacket.Write(m_CharList[iCharArray]->GetCharIndex()) );	
		PACKET_GUARD_VOID( kPacket.Write((CHARACTER)m_CharList[iCharArray]->GetCharInfo()) );
		SendMessage(kPacket);
		//kSlot.m_item_type << kSlot.m_item_code<< m_CharList[iCharArray]->GetCharIndex() << (CHARACTER)m_CharList[iCharArray]->GetCharInfo() 
	}
}


void User::GivePCRoomRodAndBait()
{
	// 강제로 PC방 낚싯대, 미끼 지급!
	/*DWORD dwIndex = 0;
	int iArray = 0;
	ioUserEtcItem::ETCITEMSLOT rkInfo;

	if( IsPCRoomAuthority() )
	{
		if( !m_UserEtcItem.HaveAThisItem(ioEtcItem::EIT_ETC_PCROOM_FISHING_ROD) )
		{
			rkInfo.m_iType = ioEtcItem::EIT_ETC_PCROOM_FISHING_ROD;
			rkInfo.m_iValue1 = 1;

			m_UserEtcItem.AddEtcItem(rkInfo, false, 0, dwIndex, iArray);

			SP2Packet kPacket(STPK_ETC_ITEM_ADD);
			PACKET_GUARD_VOID( kPacket.Write(rkInfo.m_iType) );
			PACKET_GUARD_VOID( kPacket.Write(rkInfo.m_iValue1) );
			PACKET_GUARD_VOID( kPacket.Write(rkInfo.m_iValue2) );
			SendMessage(kPacket);
		}
			
		if( !m_UserEtcItem.HaveAThisItem(ioEtcItem::EIT_ETC_PCROOM_FISHING_BAIT) )
		{
			rkInfo.m_iType = ioEtcItem::EIT_ETC_PCROOM_FISHING_BAIT;
			rkInfo.m_iValue1 = 1;
			m_UserEtcItem.AddEtcItem(rkInfo, false, 0, dwIndex, iArray);

			SP2Packet kPacket2(STPK_ETC_ITEM_ADD);
			PACKET_GUARD_VOID( kPacket2.Write(rkInfo.m_iType) );
			PACKET_GUARD_VOID( kPacket2.Write(rkInfo.m_iValue1) );
			PACKET_GUARD_VOID( kPacket2.Write(rkInfo.m_iValue2) );
			SendMessage(kPacket2);
		}
	}*/
}


// 거래소 아이템 리스트 요청
void User::ReqTradeItemList( SP2Packet &kPacket )
{
	g_TradeSyncMgr.SendTradeItemList( this );}
void User::DeleteExpiredBonusCash()
{
	m_UserBonusCash.CheckExpiredBonusCash();
}

int User::GetAmountOfBonusCash()
{
	return m_UserBonusCash.GetAvailableBonusCash();
}

void User::FillBonusCashData( SP2Packet &rkPacket )
{
	m_UserBonusCash.FillMoveData(rkPacket);
}

void User::ApplyBonusCashData( SP2Packet &rkPacket )
{
	m_UserBonusCash.ApplyMoveData(rkPacket);
}

void User::InsertUserBonusCash(const DWORD dwIndex, const int iAmount, const DWORD dwExpirationDate)
{
	if( m_UserBonusCash.ResultAddBonusCash(dwIndex, iAmount, dwExpirationDate) )
	{
		SP2Packet kPacket(STPK_BONUS_CASH_ADD);
		PACKET_GUARD_VOID( kPacket.Write(dwIndex) );
		PACKET_GUARD_VOID( kPacket.Write(iAmount) );
		PACKET_GUARD_VOID( kPacket.Write(dwExpirationDate) );

		SendMessage(kPacket);
	}
}


//인덱스 별로 클라에 보내줌
void User::UpdateUserBonusCash(BonusCashUpdateType eType, const DWORD dwStatus, const DWORD dwCashIndex, const int iAmount, const int iUsedAmount, const int iType, const int iValue1, const int iValue2, const char *szBillingGUID)
{

	DWORD dwPacketID    = 0;
	DWORD dwReturnType  = 0;

	if( dwStatus > 0 )
	{
		//OUTPUT_CASH_SOLDIER
		if( iType == 1 )
		{
			dwPacketID	 = STPK_CHAR_CREATE;
			dwReturnType = CREATE_CHAR_BILLING_FAIL;
		}
		//OUTPUT_CASH_DECO
		else if( iType == 2 )
		{
			dwPacketID	 = STPK_CHAR_DECORATION_BUY;
			dwReturnType = CHAR_DECORATION_BILLING_FAIL;
		}
		//OUTPUT_CASH_ETC
		else if( iType == 3 )
		{
			dwPacketID   = STPK_ETCITEM_BUY;
			dwReturnType = ETCITEM_BUY_BILLING_FAIL;
		}
		//OUTPUT_CASH_EXTRA
		else if( iType == 5 )
		{
			dwPacketID   = STPK_EXTRAITEM_BUY;
			dwReturnType = EXTRAITEM_BILLING_FAIL;
		}
		else if( iType == OUTPUT_CASH_SUBSCRIPTION )
		{
			dwPacketID   = STPK_SUBSCRIPTION_BUY;
			dwReturnType = SUBSCRIPTION_BUY_BILLING_FAIL;
		}
		else if( iType == OUTPUT_CASH_COSTUME )
		{
			dwPacketID	 = STPK_COSTUME_BUY;
			dwReturnType = ITEM_BUY_BILLING_FAIL;
		}
		else
		{
			LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::UpdateUserBonusCash Error Typs is %d:%d:%d:%s", iType, iValue1, iValue2, GetPublicID().c_str() );
			return;
		}
		//실패 로그 
		g_LogDBClient.OnInsertUsageOfBonusCash( this, dwCashIndex, -iUsedAmount, iType, iValue1, iValue2, szBillingGUID, dwStatus);

		//실패 패킷을 보내줘야함
		SP2Packet kPacket(dwPacketID);
		PACKET_GUARD_VOID( kPacket.Write(dwReturnType) );
		SendMessage(kPacket);
		return;
	}
	 m_UserBonusCash.ResultSpendBonusCash(eType, dwStatus, dwCashIndex, iAmount, iUsedAmount, iType, iValue1, iValue2, szBillingGUID);
	 
	 SP2Packet kPacket(STPK_BONUS_CASH_UPDATE);
	 //PACKET_GUARD_VOID( kPacket.Write((BYTE)UPDATE_CASH_BALANCE) );
	 PACKET_GUARD_VOID( kPacket.Write(dwCashIndex) );
	 PACKET_GUARD_VOID( kPacket.Write(iAmount) );

	 SendMessage(kPacket);
	 
	 /*
	이걸로 쓰다가 그냥 실패 했을때만 클라에 보내주도록 수정함
	if( m_UserBonusCash.ResultSpendBonusCash(eType, dwStatus, dwCashIndex, iAmount, iType, iValue1, iValue2) )
	{
		//해당 인덱스에 잔액이 부족하여 구매 실패 한 경우
		if( dwStatus < 0 )
		{
			//실패 패킷을 보내줘야함
			SP2Packet kPacket(STPK_BONUS_CASH_UPDATE);
			PACKET_GUARD_VOID( kPacket.Write((BYTE)UPDATE_CASH_BALANCE) );
			PACKET_GUARD_VOID( kPacket.Write(dwCashIndex) );
			PACKET_GUARD_VOID( kPacket.Write(iAmount) );

			SendMessage(kPacket);
			return;
		}
		if( iAmount == 0 )
		{
			SP2Packet kPacket(STPK_BONUS_CASH_UPDATE);
			PACKET_GUARD_VOID( kPacket.Write((BYTE)RUN_OUT_OF_CASH) );
			PACKET_GUARD_VOID( kPacket.Write(dwCashIndex) );
			PACKET_GUARD_VOID( kPacket.Write(iAmount) );
			SendMessage(kPacket);
		}
		else
		{
			SP2Packet kPacket(STPK_BONUS_CASH_UPDATE);
			PACKET_GUARD_VOID( kPacket.Write((BYTE)UPDATE_CASH_BALANCE) );
			PACKET_GUARD_VOID( kPacket.Write(dwCashIndex) );
			PACKET_GUARD_VOID( kPacket.Write(iAmount) );
			SendMessage(kPacket);
		}
		*/
		/*
		switch( eType )
		{

		case BUT_END:
			{
				SP2Packet kPacket(STPK_BONUS_CASH_UPDATE);
				PACKET_GUARD_VOID( kPacket.Write((BYTE)RUN_OUT_OF_CASH) );
				PACKET_GUARD_VOID( kPacket.Write(dwCashIndex) );
				PACKET_GUARD_VOID( kPacket.Write(iAmount) );

				SendMessage(kPacket);
			}
			break;


		case BUT_CHANGE:
			{
				SP2Packet kPacket(STPK_BONUS_CASH_UPDATE);
				PACKET_GUARD_VOID( kPacket.Write((BYTE)UPDATE_CASH_BALANCE) );
				PACKET_GUARD_VOID( kPacket.Write(dwCashIndex) );
				PACKET_GUARD_VOID( kPacket.Write(iAmount) );

				SendMessage(kPacket);
			}
			break;
		}
	}
		*/
}


ioUserCoin * User::GetUserCoin()
{
	return &m_UserCoin;
}

bool User::GetLastRaidTicketTime( CTime & outLastRefillTime )
{
	return m_UserCoin.GetLastCoinTime(outLastRefillTime, USER_COIN_RAID);
}

void User::UpdateRaidTicketTime()
{
	m_UserCoin.UpdateCoinData( USER_COIN_RAID );
}

// 레이드 티켓 지급용
void User::CheckRefillRaidTicket( bool bLogin )
{
	if( GetUserIndex() == 0 ) return;
	if( Help::GetRefillRaidTicketTime() > 23 || Help::GetRefillRaidTicketMax() <= 0 ) return;

	int iCurRaidTicket = GetRaidTicket();
	if( iCurRaidTicket >= Help::GetRefillRaidTicketMax() ) return;

	CTime lastRefillTime;
	bool bRet = GetLastRaidTicketTime(lastRefillTime);
	if(!bRet)
	{
		LOG.PrintTimeAndLog(LOG_DEBUG_LEVEL, "Raid : [%s], No Raid TicketTime in DB User %d", __FUNCTION__, GetUserIndex());
		return;
	}
	if(lastRefillTime == 0)
	{
		// 갱신된 시간이 저장안되었음... 첫접속이면 이렇게 나올수 있음
		LOG.PrintTimeAndLog(LOG_DEBUG_LEVEL, "Raid : [%s], Not Updated! TicketTime in DB User %d (maybe first login user)", __FUNCTION__, GetUserIndex());
		return;
	}

	if(bLogin == false &&
		m_UserCoin.GetNeedResult())
	{
		// 로그인 시가 아니면 db에서 업데이트 시간 받을때까지는 대기 시키자.
		return;
	}

	int iHourCheck = Help::GetRefillRaidTicketTime();

	CTime curTime = CTime::GetCurrentTime();

	CTime curDay = Help::GetSafeValueForCTimeConstructor(curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), 0, 0, 0);
	CTime lastDay = Help::GetSafeValueForCTimeConstructor(lastRefillTime.GetYear(), lastRefillTime.GetMonth(), lastRefillTime.GetDay(), 0, 0, 0);

	CTimeSpan gapTimeSpan = curDay - lastDay;
	int gapDays = max(0, gapTimeSpan.GetDays());

	if(lastRefillTime.GetHour() < iHourCheck)
		++gapDays;
	if(curTime.GetHour() < iHourCheck)
		--gapDays;

	// 하루에 얻는 티켓갯수 만큼 배수.
	gapDays *= Help::GetRefillRaidTicketCount();

	// 최대 보유 갯수 체크
	int iCurTicketCount = GetRaidTicket();
	if(gapDays + iCurTicketCount > Help::GetRefillRaidTicketMax())
	{
		gapDays = Help::GetRefillRaidTicketMax() - iCurTicketCount;
	}

	if(gapDays > 0)
	{
		AddEtcRaidTicket(gapDays);
		UpdateRaidTicketTime();

		//  지급 패킷도 보내서 유저한테 알려줘야함.
		byte byType = RAID_COIN_INFO_SYNC;
		int iTicketCount = GetRaidTicket();

		SP2Packet kPacket(STPK_RAID_COIN_INFO);
		PACKET_GUARD_VOID(kPacket.Write(byType));
		PACKET_GUARD_VOID(kPacket.Write(iTicketCount));

		SendMessage(kPacket);

		// 아이템 갯수 저장.
		SaveUserData();

	}
}

int User::AddEtcRaidTicket( int iAddTicket )
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_RAID_TICKET, kSlot );
	if( kSlot.m_iType <= 0 )
	{
		LOG.PrintTimeAndLog( LOG_DEBUG_LEVEL, "User::AddEtcRaidTicket : None Etc Item : %s - AddCoin : %d", GetPublicID().c_str(), iAddTicket );
		return 0;
	}
	kSlot.AddUse( iAddTicket );
	m_UserEtcItem.SetEtcItem( kSlot );
	return kSlot.GetUse();
}

int User::GetRaidTicket()
{
	ioUserEtcItem::ETCITEMSLOT kSlot;
	m_UserEtcItem.GetEtcItem( ioEtcItem::EIT_ETC_RAID_TICKET, kSlot );
	if( kSlot.m_iType <= 0 )
	{
		return 0;
	}

	return kSlot.GetUse();

}

void User::ExitRoomToLobby()
{
	if( IsBattleRoom() )
		LeaveBattleRoom();

	ClearPreRoomNum();
	LeaveRoom();

	SP2Packet kPacket( STPK_EXIT_ROOM );
	PACKET_GUARD_VOID( kPacket.Write((BYTE)EXIT_ROOM_ANTIHACK_PENALTY) );
	PACKET_GUARD_VOID( kPacket.Write(0) );
	PACKET_GUARD_VOID( kPacket.Write(true) );
	SendMessage( kPacket );
}
